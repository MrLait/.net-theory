 Pages 48 - 65
 XAML - eXtensible Application Markup Language (расширяемый язык разметки для приложений)
 
 Page 69 - 90 (не читал только про удаленную отладку )
Оператор using позволяет воспользоваться кодом из .NET Framework например для анимации врагов

enemyTimer.Tick += enemyTimer_Tick; два раза TAB позволяет сгенирировать метод, который называется обработчиком события
        void enemyTimer_Tick(object sender, EventArgs e)
        {
            throw new NotImplementedException();
        }
Обработчики событий будут рассматриваться в главе 15

Page 91 - 100
IDE связывает все файлы программы в решение путем создания файла(.sln) и папки, в которой оказываются все материалы. 
Решение содержит список всех входящих в проект файлов (оно имеет расширение .csproj), последние же, в свою очередь, включают в себя список
всех файлов, связанных с программой

Создание исполняемого файла
Выбор команды Build Solution (меню Build) начинает компиляцию вашей программы. Запускается компилятор, то есть
инструмент, читающий код программы и преобразующий его в исполняемый файл. 
Компилятор - инструмент, читающий код программы и преобразующий его в исполняемый файл.
Этот файл с расширением .exe представляет собой программу, которую запускает Windows. Он создается внутри папки bin, вложенной в свою очередь в папку проекта. 
При публикации решения исполняемый файл (вместе с остальными нужными файлами) копируется в пакет, который можно отправить 
в магазин Windows или загрузить без публикации. В ответ на команду Start Debugging (меню Debug) IDE компилирует программу и запускает полученный файл на выполнение.

Инструменты от .NET Framework
Сам по себе C# не более чем язык, не умеющий ничего делать. Но на помощь приходит .NET Framework. 
NET Framework — программная платформа, выпущенная компанией Microsoft в 2002 году. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), 
которая подходит для разных языков программирования. Функциональные возможности CLR доступны в любых языках программирования, использующих эту среду.

Окно Solution Explorer содержит список всех частей проекта

Ваша программа работает в CLR
Основой всех программ в Windows 8 является модель программирования Windows Runtime. Но между Windows Runtime и вашей программой существует дополнительный «слой» 
общеязыковой исполняющей среды, или CLR (Common Language Runtime).

Структура программы.
Код всех программ на C# структурирован одинаково. Везде для простоты управления кодом применяются пространства имен, классы и методы
Класс содержит фрагмент вашей программы. 
Класс включает один или несколько методов. Методы всегда принадлежат какому-либо классу. Методы, в свою очередь, состоят из операторов.

1) Файл кода начинается с перечисления инструментов .NET Framework.
        В верхней части любого файла программы находится набор строк с оператором using. Они указывают, с какой частью .NET Framework 
или Windows Store API будет работать программа. Чтобы воспользоваться классами из других пространств имен, нужно указать их с помощью оператора using.

Без оператора using можно обойтись, если пользоваться полными именами. 

2) Программы на C# используют классы
Класс может делать что угодно, но большинство классов заточено на определенное действие. При создании программы добавляется отображающий
страницу класс MainPage.
При присвоении программе имени Save the Humans IDE создала пространство имен Save_the_Humans namespace Save_the_Humans {

3) Классы содержат методы
Для выполнения различных действий классы используют методы. Методы производят некое действие на основе входных данных. Данные в метод 
передаются при помощи параметров. Именно параметры влияют на поведение метода. Некоторые методы возвращают значение. 
Ключевое слово void перед именем метода означает, что он не возвращает никаких данных.
void startButton_Click(object sender, object e) У этого метода два параметра: sender и e. 
 {
 StartGame(); Эта строка вызывает метод StartGame(), в создании которого вам помогла IDE, когда вы попросили добавить заглушку метода
 }
 
4) Каждый опператор выполняет всего одно действие
При заполнении метода StartGame() вы добавили набор операторов. Именно операторы составляют тело любого метода. 
При вызове метода сначала выполняется первый оператор, потом следующий и т. д. При достижении конца списка или оператора return 
метод завершает работу, и программа продолжает работу после вызвавшего метод оператора.
private void StartGame() Это метод StartGame(), вызываемый при нажатии игроком кнопки Start.
 {
 Метод StartGame() содержит девять операторов. После каждого оператора ставится точка с запятой.
 human.IsHitTestVisible = true;
 humanCaptured = false;
 progressBar.Value = 0;
 startButton.Visibility =
 Visibility.Collapsed;
 playArea.Children.Clear();
 playArea.Children.Add(target);
 playArea.Children.Add(human);
 enemyTimer.Start();
 targetTimer.Start();
 } 
  Зачем нужны все эти фигурные скобки? - В C# фигурные скобки объединяют операторы в блоки. Скобки всегда используются парами.
 
 Page 101 - 108

Классы могут принадлежать одному пространству имен
Рассмотрим два файла с классами из программы PetFiler2 (Домашний любимец). В них содержатся три класса: Dog (Собака), Cat (Кошка) и Fish (Рыбка). 
Так как все они принадлежат пространству имен PetFiler2, операторы в методе Dog.Bark() (Собака лает) могут вызывать операторы Cat.Meow()(Кошка мяукает) 
и Fish.Swim() (Рыбка плавает). Распределение различных имен пространств и классов по файлам не влияет на действия, выполняемые после запуска
MoreClasses.cs
namespace PetFiler2 {
 class Fish {
 public void Swim() Ключевое слово public означает, что методы этого класса доступны из любого другого класса.
 {
 // операторы
 }
 }
 partial class Cat {
 public void Meow() Ключевое слово public означает, что методы этого класса доступны из любого другого класса.
 {
 // операторы
 }
 }
 
 SomeClasses.cs
 namespace PetFiler2 {
 class Dog {
 public void Bark() Ключевое слово public означает, что методы этого класса доступны из любого другого класса.
 {
 // Здесь операторы
 }
 }
 partial class Cat {
 public void Meow() Ключевое слово public означает, что методы этого класса доступны из любого другого класса.
 {
 // Еще операторы
 }
 }
}
Классы из одного пространства имен могут «видеть» друг друга, даже находясь в разных файлах. Для помещения класса в разные файлы
пользуйтесь ключевым словом “partial”. так поступает IDE, разбивая страницу на два файла и помещая код XAML в файл MainPage.xaml,
а код C# — в файл MainPage.xaml.cs.


Что такое переменные
Все программы работают с данными. Данные могут быть представлены в виде документа, графического фрагмента, видео игры
или мгновенного сообщения. Для их хранения программа использует переменные.

Объявление переменных
Объявить (declare) переменную — значит указать программе ее тип и имя. Благодаря типам невозможно скомпилировать программы 
в случае, когда вы сделали ошибку и пытаетесь сделать нечто лишенное смысла, например вычесть Fido из 48353.
int maxWeight; <типы переменных> <имена переменных>
Лучше выбирать значимые имена, отражающие суть переменных. Тип переменной определяет, какие именно данные в ней могут храниться.

Переменные меняются
В процессе работы программы любой переменной может быть присвоено произвольное значение. То есть значения переменных меняются. 
Это ключевая идея любой программы

Математические символы
Оператор += означает, что к значению переменной number нужно прибавить 10. Так как ее значение сейчас равно 6, добавив 10, вы получите 16.
Оператор *= 
Целочисленные переменные используются в счетчике в сочетании с операторами ++ и --. Инкремент ++ увеличивает значения на 1, 
а декремент — уменьшает на 1.
result += " again " + result; Оператор + в данном случае соединяет вместе две строки. При этом числа автоматически преобразовываются к типу string.
output.Text = result; Элемент управления TextBlocke вызывает окно с текстом «hello again hello». 
result = ""; Пустые кавычки обозначают строку, не содержащую символов.

Переменные типа bool принимают значения true или false. Оператор ! обозначает отрицание и меняет значение с true на false и обратно.
bool yesNo = false;
bool anotherBool = true;
yesNo = !anotherBool;

Циклы
Циклы (loops) — они заставляют программу выполнять набор операторов — до тех пор, пока указаанное вами
условие не примет значение true (или false!).

В цикле while операторы внутри фигурных скобок выполняются до тех пор, пока условие имеет значение true.
while (x > 5) 
{
 x = x - 3;
}

Цикл for состоит из трех операторов. Первый задает начало цикла. 
Третий оператор цикла будет выполняться, пока соблюдается условие, заданное вторым оператором.
for (int i = 0; i < 8; i = i + 2) 
{
 // Все находящееся в этих скобках
 // запускается 4 раза
}

Опператор выбора
Операторы if/else инициируют действия при выполнении или невыполнении заданных условий. В большинстве случаев речь идет о проверке равенства. 
Для этого используется оператор ==. Не путайте его с оператором (=), который присваивает переменным определенное значение. 
string message = "";
if (someValue == 24)
{
 // Количество операторов в скобках
 // может быть произвольным
 message = "Значение 24."; Оператор в фигурных скобках выполняется только при соблюдении условия.
} else {
 message = "Значение отлично от 24."; При соблюдении заданного условия выполняется первый оператор, в противном случае — второй.
}
Следите за количеством знаков равенства в операторе!
Оператор, состоящий из одного знака (=), присваивает переменной значение, а из двух знаков (==) — сравнивает две переменные. 
Это очень распространенная ошибка. Если вы видите сообщение «невозможно преобразовать тип ‘int’ в тип ‘bool’», скорее всего,
именно эта ошибка является его причиной.

Page 109 - 122  Programm 1 and Programm 2

Используйте свойство x:Name, чтобы дать кнопкам имена
Переменные объявляются указанием имени и типа int weight;
Код классов и методов помещается в фигурные скобки:
public void Go() {
 // ваш код
 }
Объект PI относится к встроенному классу Math из пространства имен System, поэтому в верхней части файла есть строка using System. 

\n — это esc-последовательность, добавляющая в текст элемента TextBlock символ переноса строки.

Оператор != в отличие от оператора == принимает значение true, если переменные не равны.
Операторы > и < выявляют, какая переменная больше.
Операторы ==, !=, > и < называются операторами сравнения. С их помощью осуществляется проверка условий.
Операторы сравнения можно комбинировать при помощи оператора && (И) и оператора || (ИЛИ). К примеру, условие i равно 3 или j
 меньше 5 записывается как (i == 3) || (j < 5).

Часто задаваемые вопросы 
        Всегда ли оператор принадлежит к классу? - Да. Все операторы принадлежат к определенным классам,
а все классы в свою очередь принадлежат пространствам имен.
        Существуют ли пространства имен, которыми нельзя пользоваться? А как насчет тех, которые я обязан использовать? - Да, некоторых названий
лучше избегать. К примеру, пространство имен System зарезервировано для Windows Store API и .NET Framework. Именно здесь находятся такие инструменты, 
как позволяющий управлять последовательностями данных System.Linq и предназначенный для работы с файлами и потоками данных System.IO. 
Но по большей части вы можете называть пространства имен как вам нравится. Или отдать это на откуп IDE, которая автоматически будет присваивать имена, 
взяв за основу название программы.
        А все-таки, зачем нужно ключевое слово partial? - Оно позволяет распределять код одного класса между разными файлами. 
При создании страницы IDE сохраняет редактируемый код в один файл (MainPage.xaml), а автоматически модифицируемый код — в другой файл (MainPage.xaml.cs). 
При этом если объявить в верхней части файла пространство имен, в него попадут все файлы, перечисленные в расположенных ниже фигурных скобках. 
В одном файле могут находиться объекты из разных пространств имен и классов.

Ключевые моменты 
        Вашу программу заставляют работать операторы, которые всегда принадлежат к какому-либо  классу. Класс же в свою очередь находится
в каком-то пространстве имен.
        Блоки кода, такие как классы, цикл while, операторы if/else и многие другие виды операторов, заключаются в фигурные скобки { }.
        Для хранения данных используются переменные. Оператор = присваивает переменной значение, а оператор == сравнивает значения двух переменных.

		
Page 123 - 136 Chapter2 - Program 4
Свойство AutoSize элемента Label поменяйте на False. По умолчанию метки подгоняют свой размер под текст. Убрав у параметра AutoSize значение true, 
мы сделаем видимыми манипуляторы, чтобы растянуть метку на ширину окна.

Дважды щелкните на кнопке, чтобы добавить метод обработчика событий. 
При двойном щелчке на кнопке IDE сгенерировала обработчик события и присвоила ему имя changeText_Click(), в соответствии с именем кнопки changeText.
prive void changeText_Click(object sender, EventsArg e)
 {код для метода обработчика события. }

Оператор using добавляет в класс методы из других пространств имен.
using System;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace SomeNamespace
{
 class MyClass { Мы указываем, к какому классу принадлежит этот фрагмент кода.
 public static void DoSomething() {
 MessageBox.Show(“Здесь будет собщение”); Этот оператор вызывает окно с текстовым сообщением.
 }
 }
}

Начало новой программы
При создании нового приложения Windows Forms IDE добавляет файл Program.cs. Файл содержит класс Program, обладающий методом Main(). 
Этот метод представляет собой точку входа, то есть именно отсюда программа начинает свою работу

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms; (1)  Имя этого пространства имен IDE сгенерировала, взяв за основу имя проекта. В данном случае проект назывался
“Chapter 2 - Program 4”. Имя с пробелами и дефисом было выбрано намеренно, чтобы продемонстрировать, как IDE превращает их в нижние подчеркивания.

namespace Chapter_2___Program_4 (2)
{
 static class Program (3)
 {
 /// <summary>
 /// Точка входа в приложение.
 /// </summary>
 [STAThread]
 static void Main()(5) Программа начинает работу с точка входа.
 {
 Application.EnableVisualStyles();
 Application.SetCompatibleTextRenderingDefault(false); (4)
 Application.Run(new Form1()); Этот оператор создает и отображает форму Contacts, а также завершает программу при закрытии формы.
 }
 }
}
(1) Встроенные функции C# и .NET. 
Подобные строки находятся в верхней части почти всех файлов классов C#. System.Windows.Forms — это пространство имен. Строка using System.
Windows.Forms дает программе доступ ко всем объектам этого пространства, в данном случае к визуальным элементам — кнопкам и формам.
Без строчки using вам придется в явном виде вводить System.Windows. Forms при обращении к объекту из этого пространства имен.
(2) Выбор пространства имен для кода.
IDE называет созданное пространство имен в соответствии с именем проекта. Именно к этому пространству относится весь код.
Пространства имен позволяют использовать одни и те же имена в различных программах, при условии, что программы не принадлежат к одному пространству. 
(3) Код принадлежит к конкретному классу.
В вашей программе этот класс называется Program. Он содержит код запуска программы и код вызова формы Form 1.
В одном пространстве имен может находится несколько классов.
(4)Наш код содержит один метод, состоящий из нескольких операторов.
Внутри любого метода может находиться произвольное количество операторов. В нашей программе именно операторы вызывают форму
(5) Точка входа.
Каждая программа на C# должна иметь только один метод с названием Main. Именно он выполняется первым. C# проверяет классы на его наличие,
пока не находит строчку static void Main(). После этого выполняется первый и все следующие за ним операторы.
Технически программа может иметь несколько методов Main(), нужно только указать, какой из них будет точкой входа. НООООО
Любое приложение на C# должно иметь единственный метод Main. Он является точкой входа для вашего кода. При запуске кода метод Main() выполняется ПЕРВЫМ.



Редактирование точки входа
В программе главное — точка входа. При этом не имеет значения, к какому классу принадлежит содержащий ее метод и какие действия производит.

Создадим новую точку входа. Добавьте класс с именем AnotherClass.cs. Для этого щелкните правой кнопкой мыши на имени файла в окне Solution Explorer 
и выберите команду Add>>Class… IDE добавит в программу класс AnotherClass.cs. 

Добавьте этот метод к классу AnotherClass, написав его внутри фигурных скобок:
Класс MessageBox принадлежит пространству имен System.Windows.Forms, поэтому на шаге #3 вы и добавили оператор using.
Метод Show () является частью класса MessageBox
class AnotherClass
{
 public static void Main()
 {
 MessageBox.Show(“Pow!”); // <class><method>();
 }
}

Часто Задаваемые вопросы
 Объясните, пожалуйста, еще раз, что такое точка входа. -  Программа состоит из множества операторов, но они не могут выполняться одновременно. 
Операторы принадлежат разным классам. Как же при запуске программы определить, какой оператор выполнять первым? Компилятор просто не будет 
работать при отсутствии метода Main(), который и называется точкой входа. Первый оператор этого метода и будет выполняться самым первым.

Переменная, объявленная внутри цикла for (int c = 0; …), действует только внутри этого цикла. Поэтому при наличии двух циклов for loops, 
использующих одну переменную, нужно объявлять ее в каждом из них. Если переменная c уже объявлена вне циклов, в них ее использовать нельзя.

this.BackColor = Color.FromArgb(c, 255 - c, c);
Application.DoEvents(); - Попробуйте убрать эту строчку, и вы увидите, что форма перестанет обновляться, так как цикл еще не закончен и 
перейти к процедуре обновления невозможно. Метод DoEvents () принудительно обновляет форму на каждом витке цикла, но это «обходной» путь, который
не следует использовать в серьезных программах. 

Чтобы цвета менялись медленнее, после строки Application.DoEvents() напишите: System.Threading.Thread.Sleep(3); 
Этот оператор добавляет задержку 3 миллисекунды. Он находится в библиотеке .NET и принадлежит пространству имен System.Threading.

Цикл, находящийся внутри другого цикла, называется вложенным		

Page 137 -151  Chapter3 - Program 1

Класс Navigator содержит методы, которые выполняют все действия. В отличие от уже знакомых вам методов button_Click() они решают другую задачу:
прокладывают маршрут по городу. Именно поэтому Майк поместил эти методы в единый класс и присвоил ему имя Navigator. Для определения маршрута 
сначала вызывается метод SetDestination(), указывающий конечную точку, затем применяется метод GetRoute(), выводящий маршрут в виде символьной строки. 
Если маршрут требуется изменить, на помощь приходит метод ModifyRouteToAvoid(), позволяющий избежать определенных улиц. Затем метод GetRoute() 
выводит новый вариант маршрута.
class Navigator {
 public void SetCurrentLocation(string locationName) { ... } Майк выбирает для методов значимые имена.
 public void SetDestination(string destinationName) { ... };
 public void ModifyRouteToAvoid(string streetName) { ... };
 public string GetRoute() { ... }; Это тип(string) возвращаемого методом GetRoute() значения. Если указан тип void, метод не возвращает значения
 (string route =  GetRoute();)
}

Методы возвращающие значения

Методы состоят из операторов. Некоторые из них выполняют все входящие операторы и заканчивают работу. Другие же возвращают какое-то значение. 
Это значение принадлежит к определенному типу (например, string или int). Оператор return прерывает работу метода. Если метод не возвращает
значение, тип возвращаемого значения объявляется как void, присутствие этого оператора является необязательным. Но если метод возвращает
значение, без оператора return не обойтись.
public int MultiplyTwoNumbers(int firstNumber, int secondNumber) {
 int result = firstNumber * secondNumber;
 return result; Оператор return возвращает значение вызвавшему метод оператору.
}
Оператор вызывает метод, перемножающий два числа. Возвращаемое значение принадлежит к типу int: 
int myResult = MultiplyTwoNumbers(3, 5); В методы можно подставлять не только константы, но и переменные.

Ключевые моменты
        Классы состоят из методов, которые в свою очередь состоят из операторов. Осмысленный выбор методов позволяет получить удобный для работы класс.
        Некоторые методы могут возвращать значение. Тип этого значения нужно объявлять. Например, метод, объявленный как public int, 
возвращает целое число. Пример такого оператора: return 37;
        Метод, возвращающий значение, обязан включать в себя оператор return. Если в объявлении метода указано public string, значит, оператор return 
возвращает значение типа string.
        После оператора return программа возвращает управление оператору, вызывающему метод.
        Метод, при объявлении которого было указано public void, не возвращает значение. Но оператор return может использоваться для прерывания 
такого метода: if (finishedEarly) { return; }.

Программа с использованием классов

class Talker {
 public static int BlahBlahBlah(string thingToSay, int numberOfTimes)
 {
 string finalString = “”; Оператор объявляет переменную finalString и присваивает ей нулевое значение (пустую строку)
 for (int count = 1; count <= numberOfTimes; count++)
 {
 finalString = finalString + thingToSay + “\n”; К переменной finalString добавляется значение переменной thingToSay и знак переноса строки (\n).
 }
 MessageBox.Show(finalString);
 return finalString.Length; Метод BlahBlahBlah() возвращает значения типа int. Свойство .Length можно добавить к любой строке и узнать ее длину 
 Свойством Length обладают все строки. Знак переноса (\n) считается за один символ.
 }
}
Что мы только что посмтроили?

Новый класс содержит метод с именем BlahBlahBlah() и двумя параметрами. Первый параметр — строка с произносимым текстом, а второй — количество
повторений. Этот метод вызывает окно, в котором фраза повторяется указанное количество раз. Метод возвращает длину строки. Ему следует передать
строку для параметра thingToSay и число для параметра numberOfTimes. Указанные значения вводятся в поля формы, созданные на основе элементов
управления TextBox и NumericUpDown.

private void button1_Click(object sender, EventArgs e)
{
 int len = Talker.BlahBlahBlah(textBox1.Text, (int)numericUpDown1.Value);
 MessageBox.Show(“The message length is ” + len); Параметр length равен 21. В строке “Hello!” шесть символов, \n тоже считается символом, 
 итого 7 x 3 = 21.
}

Метод BlahBlahBlah() вызывает окно с сообщением, сформированным на основе введенных пользователем параметров.
Возвращенное методом значение форма показывает в этом окне диалога.
Методы добавленного к проекту класса можно использовать и в других классах

Почему бы не создать три класса Navigator? - Майк может скопировать код класса Navigator и вставить его в другие классы. В результате программа 
получит возможность одновременно сохранять три маршрута. Получается, что редактировать метод теперь придется три раза вместо одного?


Объекты как способ решения
Объектами (objects) называются инструменты C#, позволяющие работать с набором одинаковых сущностей. Именно благодаря им, один раз написав
класс Navigator, Майк сможет использовать его нужное количество раз.

Для создания объекта достаточно ключевого слова new и имени класса.

Navigator navigator1 = new Navigator(); Для создания объекта достаточно ключевого слова new и имени класса.
navigator1.SetDestination(“Fifth Ave & Penn Ave”);
string route;
route = navigator1.GetRoute(); Объект уже можно использовать! Так как он получен из класса, то содержит все входившие в класс методы.

Возьмите класс и постройте объект
Класс можно представить как копию объекта. Скажем, для построения пяти одинаковых домов в коттеджном поселке архитектору
не нужно рисовать пять одинаковых чертежей. Для выполнения задачи вполне достаточно одного. Определяя класс, вы определяете и его методы, точно так же 
как чертеж определяет внешний вид дома. На основе одного чертежа можно построить сколько угодно домов, а из одного класса можно получить
сколько угодно объектов.

Объект берет методы из класса
Оператор new позволяет создать произвольное количество объектов одного класса. При этом все методы исходного класса становятся частью объекта.

Экземпляры
Все элементы окна Toolbox являются классами: класс Button, класс TextBox, класс Label и т. п. При перетаскивании на форму кнопки из окна Toolbox 
автоматически создается экземпляр класса Button, которому присваивается имя button1. Перетаскивание второй кнопки приводит к появлению 
второго экземпляра с именем button2. Каждый экземпляр имеет собственные свойства и методы. Но при этом все кнопки работают одинаково, так как
они были созданы из одного класса. 
House mapleDrive115 = new House(); После: В памяти появился экземпляр класса House.

Экземпляр, сущ. — образец, вещь, подобная другим. Функция поиска и замены находит все экземпляры слова и заменяет их.
Встроенный в .NET Framework метод Math.Min() сравнивает два числа и возвращает меньшее.

Я написал уже несколько новых классов, но ни разу не воспользовался ключевым словом new! Получается, я могу вызывать методы, не создавая объекты?
Да! И именно поэтому в методах использовалось ключевое слово static.
class Talker
 {
 public static int BlahBlahBlah(string thingToSay, int numberOfTimes)
 {
 string finalString = "";
 }
 }
 При вызове метода не создавался новый экземпляр Talker. Вы написали только:  Talker.BlahBlahBlah("Hello hello hello", 5);
 Именно так вызываются статические методы, с которыми вы работали до сих пор. Если убрать модификатор static из объявления метода BlahBlahBlah(), 
вызов метода окажется уже невозможным без создания экземпляра Talker. Впрочем, это единственное отличие статических методов. Вы можете передавать им 
параметры, они возвращают значения и принадлежат определенным классам. Модификатором static можно отметить целый класс. Все входящие в этот класс
методы также должны быть статическими. Добавив в статический класс нестатический метод, вы сделаете компиляцию невозможной.

Часто Задаваемые вопросы
        Слово «статический» ассоциируется у меня с вещами, которые не меняются. Означает ли это, что нестатические методы могут меняться, а 
статические нет? - Нет. Единственным отличием статического метода от нестатического является невозможность создавать его экземпляры. 
Слово «статический» в данном случае не следует воспринимать слишком буквально.
        То есть я не смогу пользоваться классом, не создав экземпляр объекта? - Создание экземпляров является обязательным условием для работы с 
нестатическими классами. Для статических классов это не требуется.
        Почему не сделать статическими все методы? - При наличии объектов, отслеживающих данные, например экземпляров класса Navigator, 
каждый из которых отслеживал свой маршрут, для работы с этими данными можно использовать собственные методы экземпляра. Скажем, при вызове метода 
ModifyRouteToAvoid() для экземпляра navigator2 менялся только маршрут номер два. На маршруты экземпляров navigator1 и navigator3 эта процедура 
никак не влияла. Именно поэтому программаМайка могла работать с тремя маршрутами одновременно.
        А как именно экземпляры отслеживают данные? - Переверните страницу — и узнаете!
		
Page 152 -  Chapter3 - Program 2

Поля
Редактирование расположенного текста на кнопке осуществляется при помощи свойства Text. При внесении подобных изменений в конструктор добавляется 
следующий код:  button1.Text = "Текст для кнопки";
Как вы уже знаете, button1 — это экземпляр класса Button. Код же редактирует поле этого экземпляра. На диаграмме классов список полей находится сверху, 
а список методов — снизу.

Метод - это то что объект делает. Поле - это то, что объект знает.
Поведение объекта определяется его методами, поля используются для отслеживания его состояния.

Создаем экземпляры!
Для добавления полей достаточно объявить переменные вне методов. Так, все экземпляры будут иметь свои копии этих переменных.
class Clown {
 public string Name;
 public int Height;
 public void TalkAboutYourself() { Модификатор void указывает на отсутствие возвращаемых методом значений.
 MessageBox.Show(“My name is ” + Name + “ and I’m ” + Height + “ inches tall.”);
 }
 При создании экземпляра не используйте ключевое слово static ни в объявлении класса, ни в объявлении метода.
}

Спасибо за память
Создаваемые объекты находятся в так называемой куче (heap) — области динамической памяти, выделяемой на стадии исполнения программы. 
Применение оператора new автоматически резервирует место в памяти под хранение данных.
Clown oneClown = new Clown(); Операторы new создают экземпляры класса Clown, резервируя участки памяти и заполняя их данными об объекте.
Новые объекты добавляются в кучу — динамически распределяемую память.

Что происходит в памяти программы 
Программа создает новый экземпляр класса Clown:
 Clown myInstance = new Clown();
В выражении использованы два оператора. Первый объявляет переменную типа Clown (Clown myInstance;). Второй создает новый объект и присваивает его 
только что созданной переменной (myInstance = new Clown();).

Помогите парням
Создадим класс Guy и добавим в форму два его экземпляра Первое поле формы будет называться joe, а второе bob.
Оператор new, создающий экземпляры, запускается в момент загрузки формы.
Итак, наш класс называется Guy (Парень). Метод GiveCash() отвечает за передачу денег в долг, а метод ReceiveCash() — за их получение. Поля
Name и Cash содержат информацию об имени и сумме соответственно. 
Сопоставим каждому объекту Guy поля Name и Cash
Два объекта соответствуют двум парням, у каждого из которых есть свое имя и некоторое количество денег в кошельке.
Парни дают деньги и получают их назад
Метод ReceiveCash() увеличивает количество денег у объекта, а метод GiveCash() уменьшает этот параметр.
bob.ReceiveCash(25); Форма вызывает метод ReceiveCash(). Метод возвращает сумму, которую объект добавил к полю Cash.

Проект парни

class Guy {
 public string Name; Поле Name — это строка, с именем парня (Joe), а поле Cash — целое число, указывающее на количество наличных денег.
 public int Cash;
 public int GiveCash(int amount) { Метод GiveCash() имеет единственный параметр amount, указывающий, сколько денег следует отдать.
 if (amount <= Cash && amount > 0) { Требуемая сумма должна быть больше нуля, иначе деньги будут добавлены в кошелек, а не взяты оттуда.
 Cash -= amount;
 return amount;
 } else {
 MessageBox.Show(
 “У меня не хватает денег ” + amount,
 Name + “ говорит...”);
 return 0; В случае нехватки денег появляется  окно с сообщением, а метод GiveCash() возвращает значение 0 (ноль).
 }
 }
 public int ReceiveCash(int amount) { Метод ReceiveCash() также использует в качестве параметра переменную amount, проверяет ее знак, и если
она больше нуля, добавляет к переменной cash
 if (amount > 0) {
 Cash += amount;
 return amount;
 } else {
 MessageBox.Show(amount + “ мне не нужно”,
 Name + “ говорит...”); Если переменная amount больше  нуля, метод ReceiveCash () добавляет ее к переменной Cash. В противном
случае появляется окно с сообщением и возвращается значение 0 (ноль).
 return 0;
 }
 }
Форма для взаимодействия с кодом
Теперь нам нужна форма, которая будет работать с экземплярами класса Guy. Она должна содержать метки с именами парней и количеством
денег у каждого их них, а также кнопки, управляющие процессом взятия и возврата денег. Еще парни должны откуда-то брать деньги,
которые они одалживают друг другу, значит, нам следует добавить банк

Поля формы
Для отслеживания финансового состояния наших героев потребуются два поля. Назовите их joe и bob. Затем добавьте поле с именем bank для расчета, 
сколько форма должна взять у объектов, а сколько отдать им. Дважды щелкните на третьей метке и добавьте в появившийся код строки:
namespace Your_Project_Name {
 public partial class Form1 : Form {
 Guy joe; Поля Joe и Bob объявлены в классе Guy.
 Guy bob;
 int bank = 100; Значение поля bank то возрастает, то уменьшается в зависимости от того, сколько денег форма отдала объектам Guy и сколько взяла от них.
 public Form1() {
 InitializeComponent();
 }
Метод, обновляющий метки
Добавим к форме метод UpdateForm(), чтобы метки всегда показывали актуальное количество денег. Убедитесь в наличии модификатора void, так как 
данный метод не должен возвращать значение. Добавьте эти строчки под предыдущий код:
 public void UpdateForm() {
 joesCashLabel.Text = joe.Name + “ имеет $” + joe.Cash; Этот метод обновляет метки, изменяя их свойство Text.
 bobsCashLabel.Text = bob.Name + “ имеет $” + bob.Cash;
 bankCashLabel.Text = “В банке сейчас $” + bank;
 } 
 
 Код взаимодействия кнопок с объектами
 
private void button1_Click(object sender, EventArgs e) {
 if (bank >= 10) { По щелчку на кнопке Give $10 to Joe, форма вызывает метод ReceiveCash() объекта Joe, но только если в банке достаточно денег.
 bank -= joe.ReceiveCash(10);
 UpdateForm();
 } else {
 MessageBox.Show(“В банке нет денег.”);
 }
 }
 private void button2_Click(object sender, EventArgs e) {
 bank += bob.GiveCash(5);
 UpdateForm();
 } 
 
Начальный капитал Джо $50, а Боба — $100
А теперь самостоятельно укажите начальное состояние полей Cash и Name для обоих экземпляров. Код расположите под строкой InitializeComponent(), 
ведь процедура должна выполняться при инициализации формы.

public Form1() {
 InitializeComponent();
 Мы задаем свойства первого экземпляра Guy. Первая строчка создает объект, а две другие определяютзначения его полей.
 bob = new Guy();
 bob.Name = “Bob”;
 bob.Cash = 100;
 joe = new Guy();
 joe.Name = “Joe”;
 joe.Cash = 50;
 Метод UpdateForm() экземпляра класса Guy. обеспечивает актуальный вид меток после вызова формы.
 UpdateForm();
}
Часто Задаваемые вопросы
В: Почему мы не написали Guy bob = new Guy()?
О: Потому что поле bob уже было объявлено в верхней части формы. Помните, что оператор int i = 5; — это по сути два оператора int i и i = 5;? 
Сейчас происходит то же самое. Разумеется, можно объявить поле bob, написав: Guy bob = new Guy();. Но первая часть этого оператора уже имеется
в коде формы. Так что вам нужна только вторая часть кода, помещающая в поле bob новый образец Guy().
В: А почему бы нам не избавиться от строчки Guy bob;
в верхней части кода формы?
О: После этого переменная bob будет существовать только внутри метода public Form1(), поскольку к переменным, объявленным внутри метода, невозможен 
доступ из других методов. Объявив же переменную вне метода, но при этом внутри добавленной вами формы или класса, вы даете к ней доступ из
любого другого метода, принадлежащего этой же форме.
В: Что произойдет если оставить слово Guy? Если все-таки написать Guy bob = new Guy() вместо bob = new Guy()?
О: Форма не будет работать, так как переменная bob не задана. Если в начале кода формы было объявлено:
 public partial class Form1 : Form {
 Guy bob;
а затем внутри метода объявлено еще раз:  Guy bob = new Guy();
получается, что вы объявили две переменные с одинаковыми именами. Одна из них действительна для всей формы, а вторая — только внутри метода. 
Следующая строка (bob.Name = "Bob";) обновляет только локальную переменную. В итоге при запуске программы появляется сообщение об ошибке
(«NullReferenceException не обработано»), означающее, что ссылка на объект не указывает на экземпляр объекта. То есть вы пытаетесь сослаться на объект, 
который еще не был создан.

Более простые способы присвоения начальных значений 
Практически всегда создание объектов сопровождается присвоением им начальных значений. Объект Guy не исключение — он бесполезен, если не заданы 
значения полей Name и Cash. Для решения этой задачи в C# существует инициализатор объектов. В его основе лежит технология IntelliSense.

1) Рассмотрим исходный код, присваивающий полям объекта Joe начальные значения. 
joe = new Guy();
joe.Name = "Joe";
joe.Cash = 50;
2) Удалите две последние строки и точку с запятой после Guy() и добавьте справа фигурную скобку
joe = new Guy() {
3) Нажмите пробел. Появится окно со списком полей, для которых могут быть заданы начальные параметры.
4) Нажмите Tab, чтобы добавить поле Cash. Затем присвойте ему значение 50
5) Введите запятую, и сразу после нажатия пробела появится еще одно поле.
6) Завершите работу инициализатора. Итак, вы уменьшили свой код на две строчки!
joe = new Guy() { Cash = 50, Name = "Joe" };

Создание интуитивно понятных классов
1)Программа должна решать какую-то задачу.
Обдумайте проблему. Ответьте на вопросы: легко ли ее поделить на несколько частей? и как бы вы объяснили ее другому человеку?
2)С какими реальными объектами работает программа?
Программе кормления животных в зоопарке наверняка потребуются классы для различных видов корма и различных видов животных.
3) Присваивайте классам и методам значимые имена.
Другие пользователи должны понимать назначение классов и методов по виду их имен.
4) Ищите сходство между классами.
Классы, выполняющие одинаковые функции, имеет смысл объединить. В системе, производящей батончики, может быть несколько турбин, но для 
закрытия клапана достаточно одного метода, в котором номер турбины будет использован в качестве параметра. 

private void joeGivesToBob_Click(object sender, EventArgs e) {
 bob.ReceiveCash(joe.GiveCash(10));
 UpdateForm();
 }
 private void bobGivesToJoe_Click(object sender, EventArgs e) {
 joe.ReceiveCash(bob.GiveCash(5));
 UpdateForm();
 }		
 
Page 174 - 218  Chapter 4 - programm 1 - 5
Типы и ссылки
объекты — это тоже данные

Тип переменной определяет, какие данные она может сохранять
Наиболее часто используемы типы:
int хранит целые числа от –2 147 483 648 до 2 147 483 647;
string хранит текст произвольной длины (в том числе и пустую строку "");
bool хранит логические значения — true или false;
double хранит вещественные числа от ±5.0 · 10^324 до ±1.7 · 10^308 до 16 значащих цифр. Словосочетание «значащие цифры»
указывает на точность числа: и 35 048 410 000 000, и 1 743 059, и 14.43857, и 0.00004374155 имеют по семь значащих цифр. Запись 10^308 означает, что
вы можете хранить любое число не больше 10^308, при условии, что количество значащих цифр не превышает 16. С другой стороны диапазона — 10^–324,
позволяет хранить числа не меньше 10^–324… но, как несложно догадаться, опять же при условии, что количество значащих цифр не превышает 16.

Форма представления, при которой число хранится в виде мантиссы и показателя степени, называется числом с плавающей точкой (запятой).

Целочисленные типы (Буква «u» означает «без знака», Буква «s» означает «со знаком». То есть число может быть отрицательным.)
byte хранит целые числа от 0 до 255;
sbyte хранит целые числа от –128 до 127;
short хранит целые числа от –32 768 до 32 767;
ushort хранит целые числа от 0 до 65,535;
uint хранит целые числа от 0 до 4 294 967 295;
long хранит целые числа в диапазоне от минус до плюс 9 триллионов;
ulong хранит целые числа от 0 до примерно 18 триллионов.

Типы для хранения больший и очень маленьких чисед
float хранит любое число в диапазоне от ±1.5 · 10^–45 до ±3.4 · 10^38 с 7 значащими цифрами;
double хранит любое число в диапазоне от ±5.0 · 10^–324 до ±1.7 · 10^308 с 15–16 значащими цифрами.
decimal хранит любое число в диапазоне от ±1.0 · 10^–28 до ±7.9 · 10^28 с 28–29 значащими цифрами

Константы тоже имеют тип
присвоить int myInt = 14.7 т.к 14.7 принадлежит типу double. Нужно вставив в конец букву F (14.7F), а для decimal 14.7M

Тип char используется для хранения  единичных символов, например'Q','7' или '$'Константы этого типа всегда заключаются в одиночные кавычки ('x','3')

В кавычки можно заключить и esc-последовательность ('\n' — это перенос строки, '\t' — знак табуляции). Хотя в коде эти последовательности 
фигурируют в виде пары символов, программа хранит их в памяти в виде одного.

И наконец, тип таких данных, как object. Вы уже получали объекты, создавая экземпляры классов. Любой из них мог быть переменной типа object. 

Наглядное представление переменных
Данные занимают место в памяти. Значит, следует учитывать, сколько пространства требуется под строку или число в программе. Именно поэтому мы
пользуемся переменными. Они позволяют выделить достаточно места для хранения данных. В C# используются разные переменные для хранения данных 
разных типов. Чем больше переменная, тем больший стакан ей требуется. 
 long int short byte
 64   32  16    8 -Количество битов, выделяемое под переменную в момент ее объявления. 

Числа с десятичной точкой хранятся по-другому. Для большинства таких чисел подойдет тип float, занимающий меньше всего места в памяти. 
Если вам требуется большая точность, используйте тип double. А для финансовых приложений, в которых хранится информация о курсах валют, 
используется тип decimal.  
float double decimal
32    64     128 Чем больше места занимает переменная, тем больше знаков после точки можно указать.

Компилятор C# умеет обрабатывать и нечисленные типы данных. Тип char хранит один символ, а тип string позволяет хранить целый набор символов. 
При этом под объект string не выделяется предустановленное место в памяти. Он расширяется в зависимости от количества помещаемой в него информации.
А тип данных bool хранит значения true и false, с которыми вы уже сталкивались при работе с оператором if. 
bool char string
8    16   зависит от
          размера строки

Объявив тип переменной, вы фактически объясняете компилятору, как ее следует воспринимать. Компилятор видит стаканы, а не то, что в них налито. 
Поэтому такой код работать не будет:
 int leaguesUnderTheSea = 20000;
 short smallerLeagues = leaguesUnderTheSea;
Хотя число 20 000 попадает в диапазон, заданный для типа данных short, переменная leaguesUnderTheSea была объявлена как int, и компилятор 
не может положить ее в контейнер short. Следовательно, вам всегда нужно следить за совпадением типов данных. 

Операторы + (или *, / или -), примененные к значениям различных типов, автоматически преобразовывают меньший тип в больший. 
Вот пример:
 int myInt = 36;
 float myFloat = 16.4F;;
 myFloat = myInt + myFloat;
Диапазон значений типа int больше диапазона значений типа float, оператор + преобразует переменную myInt к типу float и только потом прибавляет
ее к переменной myFloat. 

Иногда приведение типо происходит автоматически
Есть два случая, когда вам не требуется делать приведение типов. Автоматически эта процедура выполняется, во-первых, при проведении 
арифметических операций:
long l = 139401930;
short s = 516;
double d = l - s; Параметр типа short вычитается из параметра типа long, а оператор = преобразует результат к типу double.
d = d / 123.456;
MessageBox.Show("Ответ " + d); Благодаря оператору + происходит преобразование типа decimal к типу string.

Во-вторых, автоматическое преобразование происходит при объединении строк оператором +. Все числа при этом преобразуются к типу string. 
Рассмотрим пример, в котором первые две строки кода написаны правильно, третья не может быть скомпилирована.
long x = 139401930;
MessageBox.Show("Ответ " + x);
MessageBox.Show(x);
Компилятор выдает сообщение об ошибке в связи с неправильным аргументом (аргументом в C# называется значение, передаваемое методу в качестве 
параметра). Параметр метода MessageBox.Show() должен принадлежать типу string, код же передает переменную типа long. Впрочем, вы легко 
можете осуществить это преобразование при помощи метода ToString().
Этим методом обладают все объекты. (И все созданные вами классы имеют метод ToString(), возвращающий имя класса.) Именно с его помощью можно 
преобразовать x в параметр метода MessageBox.Show(): MessageBox.Show(x.ToString());

int myInt = 10;
byte myByte = (byte)myInt;
double myDouble = (double)myByte;
bool myBool = (bool)myDouble; -- низя
string myString = "false";
myBool = (bool)myString; -- низя
myString = (string)myInt; -- низя
myString = myInt.ToString();
myBool = (bool)myByte; -- низя
myByte = (byte)myBool; -- низя
short myShort = (short)myInt;
char myChar = ‘x’;
myString = (string)myChar; -- низя
long myLong = (long)myInt;
decimal myDecimal = (decimal)myLong;
myString = myString + myInt + myByte + myDouble + myChar;

Аргументы метода должны быть совметсимы с типами параметров
public int MyMethod(bool yesNo) { Код, вызывающий этот параметр, не должен передавать ему переменную yesNo. Передать он должен только логическое
значение. Переменная yesNo будет вызываться исключи
 if (yesNo) {
 return 45;
 } else {
 return 61;
 }
}
Все работает, пока вы передаете методу то, что он ожидает получить (логическую переменную), вызов MyMethod(true) или MyMethod(false) позволяет
легко скомпилировать код. Но что получится, если передать методу число или строку? Вы получите уже знакомое сообщение об ошибке.

Объект тоже использует переменные
До этого момента мы рассматривали объекты отдельно. На самом же деле это еще один тип данных. Объекты обрабатываются аналогично цифрам,
строкам и логическим значениям. И точно так же используют переменные:
        Работа с типом int                      Работа с объектом
        Пишем оператор объявления типа.         Пишем оператор объявления типа.
                int myInt;                              Dog spot; При объявлении переменной название класса используется в качестве типа.
        Присваиваем новой переменной значение. Присваиваем новой переменной значение.
                myInt = 3761;                           spot = new Dog();
        Используем переменную в коде.           Используем переменную в коде.
                while (i < myInt) {                     while (spot.IsHappy) {

Получается, что нет разницыс чем работать, с объектом или с числом.В любом случае я работаю с переменной. Да, объекты — это всего лишь еще один
тип переменных.Если программе нужны целые большие числа, используйте тип long. Для целых малых чисел используйте тип short. Если вам 
нужны значения Да/Нет, используйте тип boolean. А если вам нужно нечто лающее, используйте тип Dog. Во всех случаях вы работаете с переменными.

Переменные ссылочного типа

Для создания нового объекта вы пишете new Guy(). Но этого недостаточно; в куче появится объект Guy, но у вас не будет к нему доступа. 
Вам требуется ссылка на объект. Здесь на помощь приходят переменные ссылочного типа — это переменные типа Guy, имеющие имя, например joe. 
В итоге получается, что joe — это ссылка на только что созданный объект Guy. Именно она используется для доступа к объекту.
Все переменные типа object являются ссылочными. Давайте рассмотрим пример:
public partial class Form1 : Form
{
 Guy joe; Это переменная joe, ссылающаяся на объект Guy
 public Form1()
 {
 InitializeComponent();
 joe = new Guy(); (Это ссылочная переменная… = …а это объект, на который она ссылается.
 }
Для работы с хранящимисяв памяти объектами используются ссылки, которые являются переменными. Тип этих переменных определяется классом объекта,
на который они ссылаются. 

Обращение к объекту никогда не проиходит напрямую. К примеру, невозможно записать Guy.GiveCash(), если Guy принадлежит типу object.
Компилятор не понимает, куда именно вы обращаетесь, так как в куче может храниться несколько экемпляров Guy. Вам нужна ссылочная переменная, 
например joe, которой будет присвоен конкретный экземпляр Guy joe = new Guy().
Теперь можно вызывать не статические методы joe.GiveCash(), ведь компилятор «знает», к какому экземпляру обратиться. Как показано на
рисунке, возможен набор ссылок на один экземпляр. Можно написать Guy dad = joe и вызвать метод dad.GiveCash() (папа.ДайДенег()).

При отсутствие ссылок объект превращается в мусор
Если все ссылки на объект исчезают, программа теряет к нему доступ. Теперь объект предназначен для сборки мусора (garbage
collection). C# избавляется от всех объектов, на которые нет ссылок, освобождая место в памяти. 
Объект остается в куче, пока на него есть хотя бы одна ссылка. Как толькопоследняя ссылка исчезает, объект удаляется. 

Вот код создания объекта.
Guy joe = new Guy()  { Name = "Joe", Cash = 50 }; Оператор new создает новый объект, а ссылочная переменная Joe указывает на него.
Был создан второй объект.
Guy bob = new Guy()  { Name = "Bob", Cash = 75 };
Теперь у вас два экземпляра Guy и две ссылочные переменные.
Пусть ссылка на первый экземпляр начнетуказывать на второй.
 joe = bob;
Теперь переменные joe и bob ссылаются на один и тот же объект. Ссылок на первый экземпляр не осталось.. …поэтому объект (2) удаляется!
joe принял поля { Name = "Bob", Cash = 75 };

Упражнение
Напишите программу для класса elephant (слон). Получите два экземпляра elephant и поменяйте указывающие на них ссылки таким образом, чтобы ни один
из экземпляров не был уничтожен.
Класс Elephant. Согласно диаграмме классов Elephant вам потребуется поле типа int с названием EarSize и поле типа String с названием Name. 
(Убедитесь в наличии модификатора public.) Добавьте метод WhoAmI(), вызывающий окно с информацией о размере уха и имени слона.

Еще два экземпляра Elephant и ссылки на них. Добавьте к классу Form1 два поля Elephant (сразу под объявлением класса) с именами Lloyd
и Lucinda. Присвойте им следующие начальные значения:
 lucinda = new Elephant() { Name = ″Lucinda″, EarSize = 33 };
 lloyd = new Elephant() { Name = ″Lloyd″, EarSize = 40 };
Кнопки Lloyd и Lucinda. Кнопка Lloyd должна вызывать метод lloyd.WhoAmI(), а кнопка Lucinda — метод lucinda. WhoAmI().
Кнопка переключения. Кнопка Swap должна поменять местами две ссылки. То есть щелчок на ней заставляет переменные Lloyd и Lucinda ссылаться 
на другие объекты и вызвает окно с сообщением «Objects swapped» (Замена объектов). После щелчка на кнопке Swap щелчок на
кнопке Lloyd должен вызывать окно Lucinda, и наоборот. Повторный щелчок на кнопке Swap должен возвращать все обратно.

 class Elephant {
 public int EarSize;
 public string Name;
 public void WhoAmI() {
 MessageBox.Show(″My ears are ″ + EarSize + ″ inches tall.″,
 Name + ″ says…″);
 }

 public partial class Form1 : Form {
 Elephant lucinda;
 Elephant lloyd;
 public Form1() Это код класса Form1 из файла Form1.cs
 {
 InitializeComponent();
 lucinda = new Elephant()
 { Name = ″Lucinda″, EarSize = 33 };
 lloyd = new Elephant()
 { Name = ″Lloyd″, EarSize = 40 };
 }
 private void button1_Click(object sender, EventArgs e) {
 lloyd.WhoAmI();
 }
 private void button2_Click(object sender, EventArgs e) {
 lucinda.WhoAmI();
 }
 private void button3_Click(object sender, EventArgs e) {
 Elephant holder;
 holder = lloyd; Ссылка Holder нужна для того, чтобы объект Lloyd не исчез, после того как ссылка будет перенаправлена на объект Lucinda
 lloyd = lucinda; Оператор new не используется, так как нам не нужен еще один экземпляр Elephant.
 lucinda = holder;
 MessageBox.Show(″Objects swapped″);
 }
}

Две ссылки это два способа редактировать данные объекта
Наличие множественных ссылок на объект создает опасность непреднамеренного редактирования. 

private void button4_Click(object sender, EventArgs e)
{
 lloyd = lucinda; После запуска кода переменные lloyd и lucinda будут ссылаться на ОДИН объект Elephant.
 lloyd.EarSize = 4321; Этот оператор присваивает переменной EarSize значение 4321, а значит тому объекту, на который покажет ссылка lloyd.
 lloyd.WhoAmI(); Метод WhoAmI() вызывается для объекта lloyd.
}
 Смотрите, это окно Lucinda. При том что вы вызывали метод WhoAmI() для Ллойда.
 Исчезла разница между переменными  lloyd и lucinda. Какую бы из них вы ни редактировали, будет меняться объект, на который они ОБЕ указывают.
 Данные при этом не переписывались, изменились только ссылки.
 
 
 
 Особый случай Массивы
Для слежения за набором данных одного типа, например списка высот или группы собак, используются массивы (array). Этот термин обозначает 
группу переменных, которая обрабатывается как единый объект. Вы получаете возможность хранить и редактировать большие наборы данных. 
Массивы объявляются аналогично другим переменным. Нужно указать имя массива и его тип:
bool[] myArray; Для объявления массива нужно указать его тип, поставив следом квадратные скобки.
myArray = new bool[15]; Этот массив состоит из 15 элементов. Новый массив создается командой new, как и любой другой объект.
myArray[4] = true; Нумерация элементов массива начинается с 0. Эта строка присваивает пятому элементу массива значение true.
Объявление переменной myArray можно совместить с присвоением начальных значений:
bool[] myArray = new bool[15];

Каждый элемент массива - это всего лишь переменная
Прежде всего вы должны объявить ссылочную переменную для массива. Затем при помощи оператора new создается объект с указанием размера. 
Все готово для помещения элементов в массив. 
int[] heights; (Тип элементов массива) (Имя)
heights = new int[7];
heights[0] = 68; Вы ссылаетесь на элементы массива по их индексу
heights[1] = 70;
Массив — это единый объект, хотя и состоящий из семи обычных переменных.

Массив может состоять из сылочных переменных
Массив может содержать не только числа или строки, но и ссылки на объекты. Словом, только от вас зависит, переменные какого типа
вы хотите таким образом организовать. Можно создать как массив целых чисел, так и массив объектов типа Duck. Рассмотрим код создания массива 
из 7 переменных типа Dog. Строка инициализации создает только ссылочные переменные. За ней следуют две строки new Dog(), то есть создаются 
два экземпляра класса Dog.
Dog[] dogs = new Dog[7]; Эта строка объявляет переменные, в которых будет храниться массив ссылок на объекты Dog. 
 dogs[5] = new Dog();
 dogs[0] = new Dog();
Длину массива позволяет узнать свойство Length. Для массива heights это метод heights.Length. Если в результате получено 7, значит, массив
содержит элементы от нулевого до шестого.
Все элементы массива являются ссылками, в то время как массив — это объект.

Новый проект, содержащий класс MenuMaker
class MenuMaker {
 public Random Randomizer; Поле Randomizer содержит ссылку на объект Random. Метод Next() генерирует случайные числа.
 string[] Meats = { "Roast beef", "Salami", "Turkey", ″Ham", "Pastrami" };
 string[] Condiments = { "yellow mustard", "brown mustard",  "honey mustard", "mayo", "relish", "french dressing" };
 string[] Breads = { "rye", "white", "wheat", "pumpernickel",  "italian bread", "a roll" };

}
Метод GetMenuItem(). Наш класс должен создавать сэндвичи, поэтому добавим к нему соответствующий метод. Он будет использовать метод Next() 
объекта Random для выбора элемента из каждого массива. 
Но как узнать, какой параметр нужен методу Next()? Он легко вычисляется при помощи свойства массивов Length. Именно так вы получите 
случайный номер элемента массива.
public string GetMenuItem() {
 string randomMeat = Meats[Randomizer.Next(Meats.Length)];
 string randomCondiment = Condiments[Randomizer.Next(Condiments.Length)];
 string randomBread = Breads[Randomizer.Next(Breads.Length)];
 return randomMeat + " with " + randomCondiment + " on " + randomBread; Метод GetMenuItem() возвращает строку с названием сэндвича.
 }
 
 Как это работает… Meats.Length возвращает число элементов массива Meats. Так что randomizer. Next(Meats.Length) дает случайное число,
большее или равное нулю, но меньшее, чем количество элементов массива Meats.
Meats[Randomizer.Next(Meats.Length)] Meats — это массив строк, состоящий из пяти элементов. Meats[0] = “Roast Beef” (Ростбиф), 
а Meats[3] = “Ham” (Ветчина).
public Form1() {
 InitializeComponent();
 MenuMaker menu = new MenuMaker() { Randomizer = new Random() }; Присвойте полю Randomizer объекта MenuMaker новый экземпляр класса Random.
 }

Ссылки позволяют объектам образаться друг к другу
Вы уже видели, как формы обращаются к объектам при помощи ссылочных переменных, которые вызывают методы и проверяют значения полей. Для
объектов определены те же операции, что и для форм, потому что форма — это объект. При обращении объектов друг к другу используется ключевое
слово this. С его помощью делается ссылка на текущий экземпляр класса.

Метод, заставляющий слона говорить.
Добавим к классу Elephant метод, первым параметром которого будет сообщение от объекта elephant. Вторым параметром будет имя слона:
 public void TellMe(string message, Elephant whoSaidIt) {
 MessageBox.Show(whoSaidIt.Name + " says: " + message);
 }
 lloyd.TellMe("Hi", lucinda);
Вызов одного метода другим.
Добавим метод SpeakTo() к классу Elephant. Именно здесь мы используем ключевое слово this. Оно является ссылкой, позволяющей объекту 
рассказать о себе.
public void SpeakTo(Elephant whoToTalkTo, string message) {
 whoToTalkTo.TellMe(message, this); Этот метод класса Elephant вызывает метод TalkTo() (Поговори с), позволяющий одному слону разговаривать с другим.
 }
Посмотрим, как это работает.
 lloyd.SpeakTo(lucinda, "Hello");
 
При вызове метода SpeakTo() для Ллойда вы используете параметр talkTo (являющийся ссылкой на Люсинду), чтобы вызвать метод TellMe() для Люсинды.
 whoToTalkTo.TellMe(message, this);
 Ллойд использует whoToTalkTo (со ссылкой на Люсинду) для вызова TellMe() | ключевое слово this заменяется ссылкой на объект Ллойд 
 lucinda.TellMe(message, [ссылка на Ллойда]);
В результате появляется окно диалога с обращением к Люсинде

Часто Задаваемые вопросы
В: Форма — это только объект? О: Да! Именно поэтому код класса начинается с объявления этого класса. Откройте файл Program.cs для любой из 
написанных программ и посмотрите на метод Main(), вы найдете там строку new Form1().
В: Зачем мне может потребоваться ключевое слово null? О: Вот для такой проверки условия:  if (lloyd == null) {
Оно имеет значение true, если ссылка lloyd указывает на null. Кроме того, ключевое слово null позволяет быстро избавиться от ставшего ненужным 
объекта. Если ссылки на объект остаются, а вам он уже не нужен, достаточно воспользоваться ключевым словом null, и объект будет уничтожен.
В: Что на самом деле происходит с объектами после попадания в мусор? О: Помните, в начале второй главы мы говорили об Общеязы ковой исполняющей 
среде (CLR)? Это виртуальная машина, управляющая всеми программами .NET. Виртуальной машиной называется способ изоляции работающих программ 
от остальной оперативной системы. Виртуальная машина управляет используемой памятью. Она следит за всеми объектами, и как только последняя 
ссылка на какой-нибудь из объектов исчезает, она освобождает оперативную память, которая была выделена под этот объект.
В: Я до сих пор не очень понимаю, как работают ссылки. О: Ссылки — это способ доступа к методам и полям. Создав ссылку на объект Dog, 
вы получаете возможность пользоваться любыми методами, определенными для этого объекта. Для нестатических методов Dog.Bark() и Dog.Beg()
можно определить ссылку spot. После чего для доступа к ним достаточно написать spot.Bark() и spot.Beg(). Ссылки позволяют редактировать поля
объекта. Например, для внесения изменений в поле Breed достаточно написать spot.Breed.
В: Получается, что, редактируя объект посредством одной ссылки, я меняю его значение для остальных ссылок? О: Да. Если rover ссылается на тот
же объект, что и spot, заменив rover. Breed на beagle, вы получите значение beagle и для spot.Breed.
В: Я не понимаю, почему переменные разных типов имеют разный размер. Зачем это нужно? О: Переменные определяют размер присваиваемого значения. 
Если вы объявите переменную типа long и присвоите ей значение (например, 5), CLR все равно выделит памяти на большое значение. В конце концов, 
на то они и переменные, чтобы все время меняться. CLR предполагает, что вы выбираете тип осознанно и не будете объявлять переменную ненужного типа. 
Сейчас переменная хранит небольшое значение, но потом оно может стать большим. Поэтому для нее заранее выделен нужный объем памяти.
В: Напомните мне еще раз, какую функцию выполняет ключевое слово this? О: this — это специальная переменная, используемая только внутри объекта.
Она ссылается на поля и методы выбранного экземпляра. Это полезно при работе с классом, методы которого обращаются к другим классам. 
Объект может передать ссылку на себя другому объекту. Если Spot вызывает один из методов Rover при помощи параметра this, объект
Rover получает ссылку на объект Spot.

Ключевые моменты
Объявляя переменную, вы ВСЕГДА указываете ее тип. Иногда при этом задаются и начальные значения.
 Существует множество значимых типов для хранения значений разного размера. Для огромных чисел используйте тип long, а для самых маленьких (до 255)
 — bytes.
 Невозможно присвоить значение большего типа переменной, принадлежащей к меньшему типу.
 При работе с константами используйте суффикс F для обозначения типа float (15.6F), а суффикс M — для обозначения типа decimal (36.12M). Некоторые 
типы могут преобразовываться друг в друга автоматически (например, short в int).Для других случаев используйте операцию приведения типов.
 Зарезервированные слова (например, for, while, using, new) нельзя использовать в качестве имен переменных.
 Ссылки подобны наклейкам: вы можете иметь множество ссылок на один и тот же объект.  Если на объект нет ни одной ссылки, он отправляется
в мусор, и место, занимаемое им в памяти, освобождается.
 
Играем в печатную машинку
форма (209)
Параметры элемента управления Timer. (210)
Вы заметили, что элемент управления Timer на форме отсутствует? Дело в том, что это невизуальный элемент управления. Он не меняет вид формы. 
Его функция — снова и снова вызывать некий метод. Присвойте свойству Interval значение 800, чтобы вызов метода происходил каждые 800 миллисекунд. 
Затем дважды щелкните на значке timer1 в конструкторе, чтобы добавить к форме метод timer1_Tick. Вот код для этого метода:
private void timer1_Tick(object sender, EventArgs e)
{
 // Добавим случайную клавишу к элементу ListBox
 listBox1.Items.Add((Keys)random.Next(65, 90));
 if (listBox1.Items.Count > 7)
 {
 listBox1.Items.Clear();
 listBox1.Items.Add("Игра окончена!");
 timer1.Stop(); Класс Timer обладает методом Start() , но в этом проекте мы его вызывать не будем. Вместо этого присвоим его свойству Enabled 
 значение True, что приведет к автоматическому пуску.
 }
Класс, отслеживающий статистику игры.
Так как в форме должно отображаться общее количество нажатых, пропущенных и правильно нажатых клавиш, а также точность, значит, мы должны 
отслеживать все эти данные. Кажется, нам потребуется новый класс! Назовите его Stats. 
class Stats
{
 public int Total = 0;
 public int Missed = 0;
 public int Correct = 0;
 public int Accuracy = 0;
 public void Update(bool correctKey)
 {
 Total++;
 if (!correctKey) {
 Missed++;
 }
 else {
 Correct++;
 }
 Accuracy = 100 * Correct / (Missed + Correct); При каждом вызове метода Update() вычисляется процент правильных попаданий, а результат этих 
 вычислений помещается в поле Accuracy.
 }
 Поля для отслеживания объектов Stats и Random.
Вам потребуется экземпляр класса Stats для хранения информации, поэтому добавьте поле stats. Как вы уже видели, поле random, 
содержащее объект Random, пока отсутствует. Напишите в верхней части кода формы:
public partial class Form1 : Form
{
 Random random = new Random();
 Stats stats = new Stats();
 
Контроль за нажатием клавиш.
Осталось сделать так, чтобы правильно нажатая игроком буква удалялась из окна ListBox), а статистика StatusStrip обновлялась. 
Вернитесь к конструктору форм и выделите форму. Щелкните на кнопке с изображением молнии в верхней части окна Properties, а затем дважды 
щелкните на строчке KeyDown, чтобы добавить метод Form1_KeyDown(), вызываемый при каждом нажатии клавиши. Вот код для этого метода:

private void Form1_KeyDown(object sender, KeyEventArgs e)
{
 // Если пользователь правильно нажимает клавишу, удалите букву из ListBox и увеличьте скорость появления букв
 if (listBox1.Items.Contains(e.KeyCode))
 {
 listBox1.Items.Remove(e.KeyCode);
 listBox1.Refresh();
 if (timer1.Interval > 100)
 timer1.Interval -= 2;
 difficultyProgressBar.Value = 800 - timer1.Interval;
 // При правильном нажатии клавиши обновляем объект Stats,
 // вызывая метод Update() с аргументом true
 stats.Update(true); При нажатии клавиши метод Form1_ KeyDown() вызывает метод Update() объекта Stats, обновляющий статистику, 
 а затем результат отображается в StatusStrip.
 }
 else
 {
 // При неправильном нажатии клавиши обновляем объект Stats,
 // вызывая метод Update() с аргументом false
 stats.Update(false);
 }
 // Обновление меток элемента StatusStrip
 correctLabel.Text = "Correct: " + stats.Correct;
 missedLabel.Text = "Missed: " + stats.Missed;
 totalLabel.Text = "Total: " + stats.Total;
 accuracyLabel.Text = "Accuracy: " + stats.Accuracy + "%";
}

Элементы управления - это тоже объекты
Вы построили множество форм, перетаскивая элементы управления с панели. И вот выясняется, что они являются нашими старыми знакомыми — объектами.
А следовательно, на них можно ссылаться и работать с ними так же, как и с собственноручно написанными экземплярами классов. Убедимся в этом 
на примере программы, заставляющей элементы Label прыгать по форме.

using System.Windows.Forms; Строка “using" нужна потому, что Label находится в этом пространстве имен.

class LabelBouncer {
 public Label MyLabel; Этому классу принадлежит поле MyLabel с типом Label, значит, в поле находится ссылка на объект Label. Как и любая
ссылка, она начинается со значения null. Затем она будет указывать на одну из меток формы.
 public bool GoingForward = true; Значение этой переменной типа Boolean в процессе перемещения метки по форме меняется с true на false и обратно.
 public void Move() {
 if (MyLabel != null) {
 if (GoingForward == true) {
 MyLabel.Left += 5;
 if (MyLabel.Left >= MyLabel.Parent.Width - MyLabel.Width) { Метод Move() определяет, коснулась ли метка правого края формы, используя
оператор >= для сравнения Left с шириной формы.

 GoingForward = false;
 } }
 else {
 MyLabel.Left -= 5;
 if (MyLabel.Left <= 0) {
 GoingForward = true; В процессе перетаскивания элемента управления по форме IDE задает свойства Top и Left. Ваша программа
может воспользоваться этими свойствами.
 } } } }}
 
 Вот код формы. Попробуйте понять, как он функционирует. Массив объектов LabelBouncer перемещает метки взад и вперед, а обработчик события Tick 
 элемента Timer снова и снова вызывает методы Move().
 
public partial class Form1 : Form {
 public Form1() {
 InitializeComponent();
 }
 LabelBouncer[] bouncers = new LabelBouncer[3];
 private void ToggleBouncing(int index, Label labelToBounce) { Каждая кнопка вызывает метод ToggleBouncing(), передавая ему индекс массива
и ссылку на один из элементов Labels формы
 if (bouncers[index] == null) {
 bouncers[index] = new LabelBouncer();
 bouncers[index].MyLabel = labelToBounce;
 }
 else {
 bouncers[index] = null;
 } }
 private void button1_Click(object sender, EventArgs e) {
 ToggleBouncing(0, label1);
 }
 private void button2_Click(object sender, EventArgs e) {
 ToggleBouncing(1, label2);
 }
 private void button3_Click(object sender, EventArgs e) {
 ToggleBouncing(2, label3);
 }
 private void timer1_Tick(object sender, EventArgs e) { Элемент Timer использует цикл for для вызова каждого метода Move() объекта LabelBouncer,
при условии, что он не равен null. Равенство null останавливает перемещение по форме
 for (int i = 0; i < 3; i++) {
 if (bouncers[i] != null) {
 bouncers[i].Move(); } } }}
 
namespace       Пространство имен — это логическое понятие, объединяющее связанные друг с другом классы и типы.
for             Это цикл, выполняющий оператор или блок операторов, пока определенное выражение не примет значение false.
class           Класс — это определение объекта. Классы имеют свойства и методы.
public          Ключевое слово, дающее уровень доступа с максимальными правами. Public class может использоваться любым другим классом.
else            Оператор, который выполняется, если проверка условия if вернула значение false.
new             Оператор, создающий новый экземпляр объекта.
using           Определяет пространства имен, предустановленные и созданные вами классы, которые используются в программе.
if              Оператор, выбирающий другие операторы по результатам проверки условия.
while           Цикл while выполняется до тех пор, пока условие имеет значение true.

page 219 - 257 Chapter 5

Для переменных, содержащих цены, выбирается тип decimal. Всегда помещайте букву M после цифры: чтобы присвоить переменной значение $35.26, 
нужно написать 35.26M. Это легко запомнить, потому что M — первая буква в слове money (деньги)!

Метод ToString() преобразует переменные в строки. Аргумент «c» при этом преобразуется в локальную денежную единицу. Аргумент «f3»
форматирует результат в виде типа decimal с тремя знаками после запятой, «0» (ноль) превращает результат в целое число, «0%» —
в целое с процентами, а «n» дает число с запятой в качестве разделителя групп разрядов. Вы сами можете посмотреть, как это работает!

К сожалению, пользователи не всегда используют классы так, как предполагал разработчик. К счастью, в C# есть функция, позволяющая гарантировать 
корректную работу программы, даже когда пользователь делает вещи, о которых вы и предположить не могли. Она называется инкапсуляцией (encapsulation). 

Инкапсуляция как управление доступа к данным
Подобных проблем можно избежать: достаточно оставить один способ работы с классом. Для этого в C# в объявлении переменных используется 
ключевое слово private. До этого момента вы встречали только модификатор public. Поля объектов, помеченные этим модификатором,
были доступны для чтения и редактирования любым другим объектом. Модификатор private делает поле доступным только изнутри объекта
(или из другого объекта этого же класса). Статические методы имеют доступ к закрытым полям всех экземпляров класса.
В C# поля по умолчанию считаются закрытыми, поэтому модификатор private зачастую опускается.
class DinnerParty {
 private int numberOfPeople; Для ограничения доступа к полю достаточно воспользоваться ключевым словом private при его объявлении. В итоге доступ 
к полю numberOfPeople экземпляра DinnerParty будет только у экземпляров этого класса. Другие объекты не смогут его «увидеть».

 ...
 Но другим объектам также требуется информация о количестве гостей. Значит, нужно добавить задающие этот параметр методы. Это
позволит гарантировать вызов метода CalculateCostOfDecorations() при каждом изменении количества гостей, избавив нас от надоевшей ошибки.
 public void SetPartyOptions(int people, bool fancy) {
 numberOfPeople = people;
 CalculateCostOfDecorations(fancy);
 }
 public int GetNumberOfPeople() {
 return numberOfPeople;
 }
Закрыв поле, содержащее информацию о количестве гостей, мы оставим форме всего один способ передать эти данные классу DinnerParty, гарантировав 
правильный расчет стоимости оформления. Закрытие доступа к данным с последующим написанием кода для их использования называется инкапсуляцией (encapsulation). 
Инкапсулированный — заключенный в защитный слой или мембрану. Подводники полностью инкапсулированы в подводной лодке.

Доступ к методам и полям класса
Доступ к полям и методам, помеченным словом public, имеет любой класс. Вся содержащаяся в них информация подобна открытой книге… 
вы уже видели, как подобные вещи могут стать причиной непредсказуемых результатов. Инкапсуляция меняет уровень доступа к данным. 

Закрытые поля и методы доступны только изнутри класса
Существует всего один способ доступа к информации, хранящейся в закрытых полях: использование полей и методов общего доступа, возвращающих значение.
Но любой класс имеет доступ к закрытым полям любого своего экземпляра.
Единственным способом получения информации из закрытых полей являются методы общего доступа, которые возвращают данные.

Часто Задаваемые Вопросы
В: Что произойдет, если класс с закрытыми полями не даст мне доступа к данным, в то время как мне это нужно? О: В этом случае вы не сможете получить 
доступ извне. При конструировании классов нужно гарантировать доступ для других объектов. Закрытые поля являются важной частью инкапсуляции,
но нужно оставлять удобный способ доступа к данным на случай, если вдруг возникнет такая необходимость.

В: А зачем запрещать доступ к полям объектам из другого класса? О: Иногда классу приходится отслеживать информацию, необходимую для 
выполнения каких-то операций, но при этом другим объектам эта информация не нужна. Скажем, при генерации случайных чисел применяются так 
называемые начальные числа (seeds). О том, как именно происходит генерация, мы говорить не будем, достаточно знать, что каждый экземпляр Random 
содержит массив из нескольких дюжин чисел, которые гарантируют, что метод Next() всегда даст на выходе случайное число.
Создав новый экземпляр Random, вы не сможете увидеть этот массив. Да это и не нужно. Имея доступ, вы могли бы добавлять
значения, что привело бы к генерации неслучайных чисел. Поэтому начальные числа должны быть полностью инкапсулированы.

В: А почему все обработчики событий объявляются со словом private? О: Формы в C# сконструированы таким образом, что запуск 
обработчиков событий может осуществляться только при помощи элементов формы. Модификатор private означает, что метод может использоваться только 
внутри класса. По умолчанию обработчики событий не могут управляться посторонними формами или объектами. Но нет правила, это предписывающего. 
Вы можете щелкнуть два раза на кнопке и указать в объявлении обработчика событий модификатор public. И код все равно будет
компилироваться и запускаться.

Ничего не понимаю. Закрытое поле не позволяет другом классу использовать себя. Но если поменять private на public, программа все равно будет
построена! А вот добавление модификатора private делает компиляцию невозможной. Зачем мне тогда вообще его использовать?
Потому что иногда возникает необходимость скрыть некую информацию от остальной части программы. Большинство пользователей поначалу не могут 
принять идею инкапсуляции, так как не понимают, зачем нужно скрывать поля, методы или свойства одного класса от другого. Но постепенно вы 
поймете причины, по которым отдельные классы имеет смысл делать невидимыми для остальной части программы.

Инкапсуляция делает классы:
Легкими в применении
Вы уже знаете, что поля нужны для отслеживания данных. И большинство из них применяют методы для обновления информации — эти методы не нужны 
никакому другому классу. Часто поля, методы и свойства одного класса совершенно не нужны в других частях программы. Пометив их словом
private, вы уберете их из окна IntelliSense.
Легкими в управлении
Помните программу Кэтлин? Проблема возникала потому, что форма имела непосредственный доступ к полю. Если бы поле было закрытым, программа 
работала бы правильно.
Гибкими
Иногда по прошествии времени возникает необходимость внести в программу изменения. С хорошо инкапсулированными классами не возникает вопросов 
по их дальнейшему использованию.

Инкапсуляция означает скрытие информации одного класса от другого. Она помогает предотвратить появление ошибок.
Основное отличие инкапсулированного класса в том, что он предотвращает появление ошибок и более прост в использовании.

Как правильно инкапсулировать классы?
Думайте о способах неправильного использования полей.
Что может пойти не так, если выбрать неправильный уровень доступа?
Вся ли информация в классе может быть открытой?
Если все поля и методы в классе являются открытыми, следует более детально подумать об инкапсуляции.
Какие поля будут участвовать в вычислениях?
Они — первые кандидаты на инкапсуляцию. Если позже к программе будет добавлен метод, использующий значение одного из таких полей, это может
привести к ошибке.
Открывайте доступ к полям и методам только в случае необходимости.
Если у вас нет веской причины оставлять общий доступ к полю или методу, не делайте этого. Оставив доступ ко всем полям, вы только запутаете
программу. Впрочем, не стоит впадать и в другую крайность — делать все поля закрытыми. Правильно выбрав уровни доступа, вы сэкономите время
в будущем.

Инкапсуляция сохраняет данные нетронутыми
Иногда значение поля меняется по ходу выполнения программы. Если программе в явном виде не сказано возвращать поля в исходное состояние, 
вычисления делаются с новыми значениями. В некоторых случаях именно это и требуется, то есть программа должна выполнять некие вычисления 
при каждом изменении значения поля. Помните программу Кэтлин, в которой стоимость мероприятия пересчитывалась при каждом
изменении количества гостей? Мы можем избежать такого поведения, просто инкапсулировав поля. После этого потребуется метод, получающий их 
значение, и другой метод, который присваивает значения полям и выполняет все необходимые расчеты.

Для закрытых полей мы использовали стильВерблюда, а для открытых СтильВерблюда. Во втором случае все слова в пишутся с прописной буквы,
в то время как в первом случае первое слово целиком пишется строчными буквами. Прописные буквы при таком написании выглядят как «горбы» верблюда

Пример инкапсуляции
Класс Farmer (Фермер) использует поле для хранения информации о количество коров (numberOfCows), которое затем умножается на количество мешков 
с кормом, необходимое для одной коровы:
class Farmer
{
 private int numberOfCows; Сделаем это поле закрытым, чтобы никто не мог изменить его, не отредактировав при этом поле bagsOfFeed (мешки с кормом). 
 Рассинхронизация этих полей приводит к ошибкам в программе!
}
Ввод пользователем количества коров в форму должен менять значение поля numberOfCows. Значит, потребуется метод, возвращающий значение этого поля 
форме: 
public const int FeedMultiplier = 30;
public int GetNumberOfCows() Этот метод сообщает другим классам количество коров.
{
 return numberOfCows;
}
public void SetNumberOfCows(int newNumberOfCows) Метод, задающий число коров, который гарантирует одновременное изменение переменной BagsOfFeed.
{
numberOfCows = newNumberOfCows;
 BagsOfFeed = numberOfCows * FeedMultiplier;
}

Инкапсуляция при помощи свойств
Свойства (properties) объединяют функции полей и методов. Они используются для чтения и записи вспомогательного поля (backing field). 
Именно так называется поле, заданное свойством.

private int numberOfCows; Закрытое поле numberOfCows станет вспомогательным полем свойства NumberOfCows
public int NumberOfCows Свойства часто объединяются с обычным объявлением полей. Это объявление для NumberOfCows. 
{
 get Метод чтения вызывается каждый раз, когда свойство NumberOfCows нужно прочитать. В данном случае он возвращает
значение закрытого свойства numberOfCows.
 {
 return numberOfCows;
 }
 set Метод записи вызывается при каждой записи в свойство NumberOfCows. Он имеет параметр записи value, содержащий значение, записываемое в поле.
 {
 numberOfCows = value;
 BagsOfFeed = numberOfCows * FeedMultiplier;
 }
}
Методы чтения и записи используют так же, как поля. Вот код для кнопки, которая задает количество коров, а в ответ получает
количество мешков с кормом:

private void button1_Click(object sender, EventArgs e) {
 Farmer myFarmer = new Farmer();
 myFarmer.NumberOfCows = 10; В этой строчке метод записи задает значение закрытого поля numberOfCows и тем самым обновляет открытое поле BagsOfFeed.
 int howManyBags = myFarmer.BagsOfFeed; Так как метод записи NumberOfCows обновил поле BagsOfFeed, вы можете получить его значение
 myFarmer.NumberOfCows = 20; 
 howManyBags = myFarmer.BagsOfFeed; Поле NumberOfCows запускает метод записи, передавая значение 20. Запрос к полю BagsOfFeed запускает метод чтения,
 возвращающий значение 20*30=600
}

Приложение для проверки класса Farmer
Код формы использует метод Console.WriteLine() для отправки итоговых данных в окно Output (это окно вызывается также командой Output из меню 
Debug >> Windows). Методу WriteLine() можно передать несколько параметров, и первый — это выводимая строка. Включив в эту строку «{0}», вы выведете 
первый параметр, «{1}» — второй параметр, «{2}» — третий параметр и т. д.
class Farmer {
 public int BagsOfFeed;
 public const int FeedMultiplier = 30;
 private int numberOfCows;
 public int NumberOfCows {
 {
 get
 {
 return numberOfCows;
 }
 set
 {
 numberOfCows = value;
 BagsOfFeed = numberOfCows * FeedMultiplier;
 }
}


public partial class Form1 : Form {
 Farmer farmer;
 public Form1() {
 InitializeComponent();
 farmer = new Farmer() { NumberOfCows = 15 };
 }
 private void numericUpDown1_ValueChanged(object sender, EventArgs e) {
 farmer.NumberOfCows = (int)numericUpDown1.Value;
 }
 private void calculate_Click(object sender, EventArgs e) {
 Console.WriteLine("I need {0} bags of feed for {1} cows", Метод WriteLine () замещает “{0}” значением первого параметра, а “{1}” —
значением второго параметра. 
 farmer.BagsOfFeed, farmer.NumberOfCows);
 }
}
Но есть небольшая проблема. Добавьте к форме кнопку, которая выполняет оператор:
 farmer.BagsOfFeed = 5;

Полностью инкапсулируем класс Farmer
Удалите поле BagsOfFeed из класса Farmer. Вместо него введите prop и дважды нажмите
tab. Появится следующая строка кода:
 public int MyProperty { get; set; }
Снова нажмите Tab, чтобы выделить поле MyProperty. Введите имя BagsOfFeed:
 public int BagsOfFeed { get; set; }
Теперь у вас свойство вместо поля. Компилятор обрабатывает эту информацию как вспомогательное поле.

Впрочем, проблема еще не решена. Для ее решения сделайте свойство доступным только для чтения:
 public int BagsOfFeed { get; private set; }
При попытке построить код вы получите сообщение об ошибке в строчке, задающей свойство BagsOfFeed: метод записи недоступен, — ведь вы 
не можете редактировать свойство BagsOfFeed вне класса Farmer. Удалите строчку кода, соответствующую второй кнопке.
Теперь класс Farmer хорошо инкапсулирован!

Редактируем множество Feed
При построении счетчика коров множитель, указывающий количество корма на одну особь, мы определили как константу. Но представим, что
нам требуется его изменить. Вы уже видели, как доступ к полям одного класса со стороны других классов может стать причиной ошибки. 
Именно поэтому общий доступ к полям и методам имеет смысл оставлять только там, где это необходимо. Так как программа никогда не обновляет 
FeedMultiplier, нам не требуется запись в это поле из других классов. Поэтому сделаем его свойством доступным только для чтения,
которое использует вспомогательное поле.

Удалите строчку
 public const int FeedMultiplier = 30;
Воспользуйтесь комбинацией prop-tab-tab, чтобы добавить свойство, доступное только для чтения. Но вместо автоматического свойства
добавьте вспомогательное поле:
 private int feedMultiplier;
 public int FeedMultiplier { get { return feedMultiplier; } } Так как вместо константы общего доступа у нас закрытое поле
типа int, его имя теперь начинается со строчной буквы f.
Свойство возвращает вспомогательное поле feedMultiplier. Метод записи отсутствует, то есть оно доступно только для чтения.
Метод чтения при этом открыт, то есть значение поля FeedMultiplier можно прочитать из любого другого класса.

Добавим инициализатор объекта:
public Form1() {
 InitializeComponent();
 farmer = new Farmer() { NumberOfCows = 15, feedMultiplier = 30 };
Теперь программа не компилируется! Вот как выглядит сообщение об ошибке:

Дело в том, что инициализатор объекта работает только с открытыми полями и свойствами. Что же делать, если требуется инициализировать закрытые поля? 

Конструктор
Итак, вы уже убедились, что с закрытыми полями инциализатор объектов не работает. К счастью, существует особый метод, называемый конструктором
(constructor). Это самый первый метод, который выполняется при создании класса оператором new. Передавая конструктору параметры, вы указываете 
значения, которые требуется инициализировать. Но этот метод не имеет возвращаемого значения, так как напрямую не вызывается. Параметр 
передается оператору new. А как вы уже знаете, этот оператор возвращает объект, поэтому конструктору возвращать уже ничего не нужно.

Чтобы снабдить класс конструктором, добавьте метод, имеющий имя класса и не имеющий возвращаемого значения. 
Добавление конструктора к классу Farmer
Требуется добавить всего две строчки кода, но как много они значат. Как вы помните, в классе должны присутствовать данные о количестве коров 
и мешков корма на одну корову. Добавим эту информацию к конструктору в качестве параметров. Для переменной feedMultiplier требуется начальное 
значение, так как она более не является константой

public Farmer(int numberOfCows, int feedMultiplier) {
Перед вызовом метода записи NumberOfCows нужно задать параметр feedMultiplier.
 this.feedMultiplier = feedMultiplier;
 NumberOfCows = numberOfCows;
} 
Ключевое слово this в конструкции this.feedMultiplier указывает, что вы имеете в виду поле, а не одноименный параметр
Отсутствие после public ключевых слов void или int либо других объявлений типа связано с тем, что конструктор не возвращает значения.

Настройки формы, необходимые для работы с конструктором
Теперь нужно сделать так, чтобы оператор new, создающий объект Farmer, использовал конструктор вместо инициализатора объекта. После 
редактирования оператора new сообщения об ошибках исчезнут и код начнет компилироваться!
public Form1() { Так как форма — это тоже объект, для нее определен конструктор с именем Form1. Обратите внимание, что он не возвращает значение.
 InitializeComponent();
 farmer = new Farmer(15, 30); Метод new, вызывающий конструктор, отличается наличием передаваемых конструктору параметров.
}

Конструкторы под микроскопом
Внимательно рассмотрим конструктор Farmer, чтобы составить представление о том, как он работает.

  Конструкторы     Данный конструктор имеет два 
  не возвращают    параметра: количество коров
  значения.        и количество корма на одну корову.
public Farmer(int numberOfCows, int feedMultiplier) {
 this.feedMultiplier = feedMultiplier; Так как второй оператор вызывает метод записи NumberOfCows, для вычисления параметра BagsOfFeed вам
 NumberOfCows = numberOfCows;           нужно значение feedMultiplier.
}
Чтобы отличить поле feedMultiplier от одноименного параметра, мы воспользовались словом this.
Так как this означает ссылку на текущий объект, запись this.feedMultiplier является ссылкой на поле. Так что сначала мы присваиваем закрытому полю
feedMultiplier второй параметр конструктора.

Часто Задаваемые вопросы
В: Бывают ли конструкторы без параметров? О: Да. Классы часто снабжены конструктором, не имеющим параметров. И вы уже видели пример — конструктор 
вашей формы. Посмотрите на его объявление:
public Form1() {
 InitializeComponent();
}
Как видите, конструктор формы действительно не имеет параметров. Откройте файл Form1.Designer.cs и найдите метод InitializeComponent(), 
щелкнув на значке + рядом со строчкой «Windows Form Designer generated code». Этот метод задает не только начальные значения всех элементов 
управления формы, но и их свойства. Перетащите на форму новый элемент управления, отредактируйте его свойства в окне Properties и обратите 
внимание на изменения, которые произойдут с методом InitializeComponent(). Метод InitializeComponent() вызывается внутри
конструктора формы, поэтому инициализация всех элементов управления происходит в момент создания формы. (Помните, что все формы не более чем 
объекты, использующие методы .NETFramework из пространства имен System.Windows.Forms для отображения окон, кнопок и других элементов управления.)

В: Как различать одноименные параметры и поля? О: Вы заметили, что параметр конструктора feedMultiplier называется так же, как вспомогательное
поле свойства FeedMultiplier? Чтобы использовать в конструкторе последнее, не забудьте про ключевое слово this: имя feedMultiplier указывает на 
параметр, а запись this.feedMultiplier на доступ к закрытому полю.

В: Зачем нужна процедура создания методов чтения и записи? Почему нельзя просто создать поле? О: Поля нужны для вычислений или иных
действий. Вспомните о проблеме Кэтлин — после указания количества гостей в классе DinnerParty форма не запускала метод, пересчитывающий стоимость 
оформления. Заменив поле на метод записи, мы гарантируем, что этот пересчет будет сделан. (Через пару страниц вы убедитесь в этом!)

В: Чем же отличаются просто методы от методов чтения и записи? О: Ничем! Это особые виды методов — для других объектов они выглядят как поля
и вызываются при записи в поле. Метод чтения в качестве значения возвращает тип поля. А метод записи имеет только один параметр с именем value, 
тип которого совпадает с типом поля. Вместо громоздких «метод чтения» и «метод записи» можно говорить просто — «свойства». 

В: Получается, что в свойство можно превратить ЛЮБОЙ оператор? О: Вы абсолютно правы. Все, что можно реализовать при помощи метода, можно превратить 
в свойство. Свойства могут вызывать методы, получать доступ к полям и даже создавать объекты и экземпляры. Но все эти функции  реализуются только 
в момент доступа к свойству, поэтому не стоит превращать в свойства операторы, не имеющие отношения к процедурам чтения или записи.

В: Если метод записи имеет параметр value, почему этот параметр не указан в скобках как int value, как это происходит с другими методами? О: C# 
позволяет не писать информацию, которая не потребуется компилятору. Параметр объявляется без ваших явных указаний. Это не имеет особого значения,
когда вы вводите один или два оператора, но если требуется ввести сотню, подобный подход реально экономит время и уменьшает количество возможных 
ошибок. Метод записи всегда имеет единственный параметр value, тип которого всегда совпадает с типом свойства. C# получает всю необходимую 
информацию о типе и параметре в момент, когда вы набрали "set {". Больше ничего набирать не нужно.

В: То есть я могу не добавлять в конструктор возвращаемое значение? О: Именно так! Конструктор не имеет возвращаемого значения, так как 
принадлежит к типу void. Было бы излишне заставлять вас набирать void в начале каждого конструктора.

В: Могу ли я использовать только метод чтения или только метод записи? О: Конечно! Воспользовавшись свойством get без свойства set, вы получите
свойство только для чтения. Например, класс SecretAgent может иметь поле ReadOnly (только для чтения) для имени (name):
string name = "Dash Martin";
public string Name {
 get { return name; }
}
А если воспользоваться свойством set без свойства get, вспомогательное поле будет доступно только для записи. Класс SecretAgent создает свойство
Password, в которое другие шпионы могут только записывать информацию, но не читать ее:
public string Password {
 set {
 if (value == secretCode) {
 name = "Herb Jones";
 }
}

В: А как же с объектами, которые мы создавали, не создав для них конструктор? Получается, что он нужен далеко не всегда? О: Нет, это означает, 
что C# автоматически создает конструктор с нулевым параметром, если вы не делаете этого. Вы можете заставить пользователя создать экземпляр вашего 
класса, чтобы воспользоваться конструктором.

Свойства (методы чтения и записи) — это особый вид методов, запускаемых при попытке прочитать свойство или сделать запись в него. 
Полезная информация: первая строка метода, содержащая модификатор доступа, возвращаемое значение, имя и параметры, называется
сигнатурой метода. Свойства также обладают сигнатурами.

Часто Задаваемые Вопросы

В: Почему имена одних полей начинаются с прописной буквы, а других — со строчной? Это что-то означает? О: Да, означает. Для вас. Но не для 
компилятора. C# все равно, какие имена вы выбираете для переменных. Выбор странных имен затруднит чтение кода в будущем. Вы можете запутаться 
в одноименных переменных, все отличие имен которых заключается в регистре первой буквы. В C# регистр имеет значение. Внутри одного метода 
можно иметь две переменные с именами Party и party. Это не помешает компиляции кода. Вот несколько советов по выбору имен для переменных,
которые упростят чтение программы в будущем:
1. Имена полей закрытого доступа должны начинаться со строчной буквы.
2. Имена свойств и полей общего доступа должны начинаться с прописной буквы.
3. Имена параметров методов должны начинаться со строчной буквы.
4. В некоторых методах, особенно это касается конструкторов, имена параметров совпадают с именами полей. В итоге параметр маскирует поле, 
то есть операторы методов, которые используют это имя, ссылаются на параметр, а не на поле. Эта проблема решается при помощи 
ключевого слова this: достаточно добавить его к имени, и компилятор поймет, что вы имеет в виду поле, а не параметр. 

Упражнение
Обратили внимание, как мало функций у новой формы? Она всего лишь задает свойства объектов на основе введенных пользователем данных и в 
зависимости от этих свойств корректирует конечный результат. Подумайте, как код пользовательского ввода и вывода отделен от кода,
выполняющего вычисления. 
Этот принцип называется “ разделением ответственности” и часто используется в программах. Форма имеет отношение к пользовательскому интерфейсу,
в то время как объект DinnerParty связан с вычислением стоимости.

class DinnerParty {
 public const int CostOfFoodPerPerson = 25;
 Эти свойства задаются в конструкторе, обновляются формой и применяются при расчете конечной стоимости.
 public int NumberOfPeople { get; set; }
 public bool FancyDecorations { get; set; }
 public bool HealthyOption { get; set; }
 Это конструктор DinnerParty. Он задает три свойства, базируясь на переданных ему значениях.
 public DinnerParty(int numberOfPeople, bool healthyOption, bool fancyDecorations) {
 NumberOfPeople = numberOfPeople;
 FancyDecorations = fancyDecorations;
 HealthyOption = healthyOption;
 }
 Сделав этот метод закрытым, вы гарантировали отсутствие доступа к нему извне, тем самым исключив вероятность его некорректного применения.
 private decimal CalculateCostOfDecorations() {
 decimal costOfDecorations;
 if (FancyDecorations) {
 costOfDecorations = (NumberOfPeople * 15.00M) + 50M;
 }
 else {
 costOfDecorations = (NumberOfPeople * 7.50M) + 30M;
 }
 return costOfDecorations;
 }
 private decimal CalculateCostOfBeveragesPerPerson() {
 decimal costOfBeveragesPerPerson;
 if (HealthyOption) {
 costOfBeveragesPerPerson = 5.00M;
 }
 else {
 costOfBeveragesPerPerson = 20.00M;
 }
 return costOfBeveragesPerPerson;
 }
 public decimal Cost {
 get {
 decimal totalCost = CalculateCostOfDecorations();
 totalCost += ((CalculateCostOfBeveragesPerPerson() + CostOfFoodPerPerson) * NumberOfPeople);
 Закрытые методы, участвующие в расчете стоимости, обращаются к свойствам, получая при этом самую свежую информацию из формы.
 if (HealthyOption) {
 totalCost *= .95M;
 }
 return totalCost;
 } }}
Теперь, когда вычисления стали закрытыми и инкапсулировались в свойстве Cost, форма потеряла возможность пересчитывать стоимость оформления 
без учета текущих параметров. Мы исправили ошибку, из-за которой Кэтлин чуть не лишилась одного из клиентов!

Если у вас есть метод, начинающийся с «Set», который задает поле, а затем обновляет состояние объекта, превращение его в свойство
сделает его предназначение более очевидным. Это один из способов, которыми инкапсуляция упрощает понимание и повторное применение классов.

page 258 - 312  Chapter 6

Часто Задаваемые Вопросы

В: Почему нельзя просто создать экземпляр DinnerParty, как это делал Майк, когда ему потребовалось сравнить три маршрута? О: Потому что новый 
экземпляр класса DinnerParty годится только для расчета стоимости званых обедов. Два экземпляра одного класса полезны, когда требуется работать 
с данными одного типа. Но для хранения других данных вам потребуется другой класс.

В: И что же мне поместить в этот новый класс? О: Перед тем как приступить к созданию класса, нужно понять, какую проблему он будет решать. В данном 
случае вы должны поговорить с Кэтлин, ведь это она будет пользоваться программой. Впрочем, у вас есть ее заметки! Определить поля, методы и 
свойства класса можно, продумав его поведение (что он должен делать) и его состояние (что он должен знать).

Для блоков, состоящих из одной строки, фигурные скобкинеобязательны
После оператора if или внутри цикла while часто находится всего один оператор. Только представьте себе, сколько скобок появилось бы при наличии 
многочисленных проверок условия и циклов в программе, если этот единственный оператор обязательно требовалось бы заключать в скобки.
Поэтому в C# вполне допустима запись:
for (int i = 0; i < 10; i++)
 DoTheJob(i); 

if (myValue == 36)
 DoTheJob(i); 
 
Наследование
На-сле-до-вать, гл. иметь признаки родителя или предка. Она хочет, чтобы ребенок унаследовал ее большие карие глаза. 
При написании программ C# часто создаются классы, соответствующие процессам из реального мира, и эти процессы, как правило, связаны друг с другом. 
Ваши классы имеют одинаковый код, так как процессы, взятые за их основу (дни рождения и званые обеды), имеют одинаковые признаки.  
Если существует несколько классов, являющихся частными случаями другого, более общего класса, можно заставить их наследовать от этого класса. 
При этом они становятся классами, производными (subclass) от базового (base class).

Модель классов от общего к частному
Наследование в C# является копией процессов, происходящих в реальном мире. Иерархия присутствует в виде перехода от общих вещей к частностям. 
В модели классов классы, расположенные ниже в иерархии, наследуют от вышестоящих.

Наследование позволяет избежать дублирования кода в производных классах

Иерархия классов
Конструкция, в которой под базовым классом располагаются производные классы, в свою очередь являющиеся базовыми для других классов, называется 
иерархией (class hierarchy). Подобный подход не только позволяет избежать многократного дублирования кода, но и делает код намного более читабельным.
Иерархия становится картой, позволяющей отследить происходящее в программе.

Производные классы расширяют базовый 
При наследовании класс просто расширяется за счет добавления к базовому классу полей, свойств и методов. 

Синтаксис наследования
При наследовании имена производного и базового классов разделяются двоеточием (:). Производный класс получает все поля, свойства и методы 
базового класса.

class Vertebrate
{
 public int NumberOfLegs;
 public void Eat() {
 // код, заставляющий есть
 }}
Класс Bird (Птица) наследует от класса Vertebrate (Позвоночное).
class Bird : Vertebrate Вы расширяете класс, добавив в конец его объявления двоеточие и имя базового класса. 
{
 public double Wingspan;
 public void Fly() {
 // код, заставляющий летать
 }}

public button1_Click(object sender, EventArgs e) {
 Bird tweety = new Bird();
 tweety.Wingspan = 7.5;
 tweety.Fly();
 tweety.NumberOfLegs = 2;
 tweety.Eat();
}

При наследовании поля, свойства и методы базового класса добавляются к прозводному
Наследование является простым, если производному классу нужны все методы, свойства и поля базового класса.

class Bird {
 public void Fly() {
 // код, заставляющий птицу летать
 }
 public void LayEggs() { ... };
 public void PreenFeathers() { ... };
}
class Pigeon : Bird {
 public void Coo() { ... }
}
class Penguin : Bird {
 public void Swim() { ... }
}
Здесь Pigeon (голубь) — производный класс от Bird, поэтому ему принадлежат все методы этого класса — Fly() (летать), LayEggs() (откладывать яйца),
PreenFeathers (чистить перья), а также его собственный метод Coo() (ворковать).

Не все птицы летают
Что делать, если базовый класс имеет метод, который в производном классе требуется отредактировать?

public void BirdSimulator() {
 Pigeon Harriet = new Pigeon();
 Penguin Izzy = new Penguin();
 Harriet.Fly();
 Harriet.Coo();
 Izzy.Fly(); Izzy — экземпляр объекта Penguin (пингвин). Он унаследовал метод Fly(), и теперь ничто не удерживает его от полета!
}
Как класс Pigeon, так и класс Penguin наследует у класса Bird, так что оба они получают методы Fly(), LayEggs() и PreenFeathers()
Голуби летают, откладывают яйца и чистят перья, поэтому проблем с наследованием от класса Bird не возникает.
Пингвины не должны летать! Но так как класс Penguin наследует от класса Bird, у бедняг просто нет выбора!

Перекрытие методов
Иногда нужно, чтобы производный класс унаследовал не все поведения базового, а только часть их. Чтобы изменить унаследованное ненужное поведение,
достаточно перекрыть (override) метод.
Ключевое слово virtual
Чтобы производный класс получил возможность перекрывать методы, используйте ключевое слово virtual.

class Bird {
 public virtual void Fly() { Это ключевое слово показывает, что производный класс может перекрыть метод Fly().
 // код, заставляющий птицу летать
 }}
Добавление одноименного метода в производный класс
Переопределенный метод должен иметь такую же сигнатуру, то есть то же самое возвращаемое значение и параметры. В его объявлении используется 
ключевое слово override.

class Penguin : Bird {
 public override void Fly() { Чтобы перекрыть метод Fly(), добавьте в производный класс идентичный метод и воспользуйтесь ключевым словом override. 
 MessageBox.Show("Пингвины не летают!")
 }}
При перекрытии сигнатура нового метода должна совпадать с сигнатурой исходного метода из базового класса. В случае с методом Fly это означает 
отсутствие возвращаемого значения и параметров. 

Используйте ключевое слово override для добавления в производный класс методов, замещающих методы унаследованные. Перекрывать можно методы, 
помеченные в базовом классе словом virtual.

Вместо базового класса можно взять один из производных
Допустим, у нас имеется метод, анализирующий объекты Sandwich:
public void SandwichAnalyzer(Sandwich specimen) {
 int calories = specimen.CountCalories();
 UpdateDietPlan(calories);
 PerformBreadCalculations(specimen.SlicesOfBread, specimen.Toasted);
}
Методу можно передать объект сэндвич, а можно сэндвич с беконом, салатом и помидорами BLT (cэндвич). Эти свойства мы наследуем от класса Sandwich:
public button1_Click(object sender, EventArgs e) {
 BLT myBLT = new BLT();
 SandwichAnalyzer(myBLT);
}
По диаграмме классов всегда можно спуститься вниз — ссылочной переменной можно присвоить экземпляр одного из производных классов. Но движение 
вверх по диаграмме классов запрещено.
public button2_Click(object sender, EventArgs e) {
 Sandwich mySandwich = new Sandwich();
 BLT myBLT = new BLT();
 Sandwich someRandomSandwich = myBLT; Значение myBLT можно присвоить любой переменной класса Sandwich, так как BLT — это подвид сэндвича.
 BLT anotherBLT = mySandwich; // <--- ЭТО НЕ КОМПИЛИРУЕТСЯ!!!
 Но нельзя присвоить значение mySandwich переменной BLT, так как далеко не каждый сэндвич содержит бекон, лук, помидоры. Поэтому последняя 
 строка компилироваться не будет.
}

Часто Задаваемые Вопросы
В: В ребусе в бассейне точка входа указывала наружу, означает ли это, что в программе отсутствует форма Form1? О: Для нового проекта Windows
Application IDE создает все необходимые файлы, включая файл Program.cs (содержащий статический класс с точкой входа) и файл Form1.cs, 
содержащий пустую форму Form1.

В: Можно ли наследовать от класса, содержащего точку входа? О: Да. Точка входа должна быть статическим методом, но этот метод может и не 
принадлежать к статическому классу. (Ключевое слово static означает невозможность создания экземпляров класса, но его методы доступны с момента 
запуска программы. В ребусе в бассейне метод TestBoats.Main() можно вызвать из любого другого метода без объявления ссылочной переменной
или создания экземпляров при помощи оператора new.)

В: Я не понимаю, почему эти методы называют «виртуальными», они вполне реальные! О: Ключевое слово virtual относится к способам обработки методов 
в .NET. Используется так называемая таблица виртуальных методов, которая отслеживает, какие методы были унаследованы, а какие перекрыты.
Для просмотра членов класса раскройте его в окне Class View .

В: Почему я могу двигаться по диаграмме классов только вверх? О: Классы, расположенные в диаграмме сверху, являются более общими. Именно от них 
наследуют более детализированные классы (скажем, Рубашка или Автомобиль могут наследовать от классов Одежда или Транспорт). Если вам нужен 
транспорт, вам подойдет как автомобиль, так и мотоцикл или даже поезд. Но если вам требуется именно автомобиль, вы не сможете выбирать все 
транспортные средства. Именно так работает наследование. При наличии метода с параметром Транспорт и при условии, что класс Мотоцикл наследует 
от класса Транспорт, вы можете передать методу экземпляр Мотоцикл. Если же параметром метода является Мотоцикл, вы не сможете передать объект 
Транспорт, так как это может оказаться Поезд, и C# не будет знать, что делать, при попытках метода получить доступ к свойству Руль.

Методам, параметры которых работают с базовым классом, можно передавать экземпляры производ ного класса.

Попробуйте при создании нового проекта выбрать вариант Empty Project вместо Windows Application. Добавьте файл с классами через окно 
Solution Explorer и введите код из решения ребуса в бассейне. Так как в программе должно появляться окно диалога, необходимо добавить ссылку на
форму. Щелкните правой кнопкой мыши на строчке References в окне Solution Explorer, выберите команду Add Reference, в открывшемся окне перейдите 
на вкладку .NET и выберите строчку System.Windows.Forms. (Это IDE делает автоматически при создании проекта Windows Application.) Затем выберите 
команду Properties в меню Project и укажите в списке output type вариант Windows Application. Запустите программу и посмотрите на результат! 
Поздравляем, вы только что создали программу с нуля!

В: А я не понимаю, зачем нужны ключевые слова virtual и override. Если они отсутствуют, IDE показывает предупреждение. Но программа все равно 
запускается! Так какая разница? Нет, я, конечно, могу писать эти слова, если так делать «правильно», но кажется, меня просто заставляют выполнять
лишнюю работу О: Есть важная причина! Ключевые слова virtual и override не являются формальностью. Они меняют способ работы вашей программы. 

Производный класс умеет скрывать методы
Сравнение скрытия и перекрытия метода
Причиной, по которой объект JewelThief при вызове метода ReturnContents() ведет себя как объект Locksmith, является способ, которым класс 
JewelThief объявил этот метод. Подсказка находится в предупреждениях, которые посылает приложение:

Скрывая методы пользуйтесь ключевым словом new
Чтобы осуществить текущую реализацию, добавьте ключевое слово override. Если предполагается сокрытие, используйте ключевое слово new.
Вернемся в программу и добавим ключевое слово new. 
 new public void ReturnContents(Jewels safeContents, Owner owner) {
Сразу же после этого сообщение об ошибке исчезнет. Хотя программа все равно не станет работать так, как нужно! По-прежнему вызывается метод 
ReturnContents(), определенный для объекта Locksmith. Почему так происходит? Дело в том, что вызов этого метода осуществляется через метод, 
определенный в классе Locksmith, а именно через Locksmith.OpenSafe(), несмотря на то что его начальные значения были заданы в классе JewelThief. 
Если бы JewelThief просто скрывал метод ReturnContents() из базового класса, его собственный метод ReturnContents() никогда бы не был вызван.

В: Обычно мне требуется перекрывать, а не скрывать методы. Но если я все-таки скрываю их, я всегда должен использовать ключевое слово new, 
не так ли? О: Именно так. В большинстве случаев методы требуется перекрывать, но имеется и возможность скрыть их. Работая с производным классом, 
который является расширением базового, вы, скорее всего, будете использовать перекрытие методов. Поэтому если вы заметили, что компилятор 
предупреждает о скрытии методов, не оставляйте это без внимания! Подумайте, действительно ли вы хотите скрыть метод, или, может быть, вы просто 
забыли написать ключевые слова virtual и override. Корректное использование ключевых слов virtual, override и new позволяет избежать проблем, с 
которыми вы столкнулись в последней программе!

Чтобы перекрыть метод базового класса, всегда помечайте его ключевым словом virtual. И всегда используйте ключевое слово override, когда хотите 
перекрыть метод в производном классе. Если этого не сделать, некоторые методы внезапно могут оказаться скрытыми.

Ключевое слово base
Иногда возникает необходимость доступа к перекрытым методам или свойствам базового класса. К счастью, существует ключевое слово base, дающее 
доступ к любым методам базового класса.

Все животные едят, поэтом класс Vertebrate (Позвоночные) должен иметь метод Eat(), в качестве параметра которого используется объект Food (Еда).
class Vertebrate {
 public virtual void Eat(Food morsel) {
 Swallow(morsel);
 Digest();
 }}
Хамелеоны ловят пищу языком. Поэтому класс Chameleon наследует от класса Vertebrate, переписывая при этом метод Eat().
class Chameleon : Vertebrate {
 public override void Eat(Food morsel) {
 CatchWithTongue(morsel);
 Swallow(morsel);
 Digest();
 }}
Воспользуйтесь ключевым словом base для вызова перекрытого метода, и вы получите доступ как к новой, так и к старой версии метода Eat().
class Chameleon : Vertebrate {
 public override void Eat(Food morsel) {
 CatchWithTongue(morsel);
 base.Eat(morsel); Эта строчка вызывает метод Eat () из базового класса, от которого наследует объект Chameleon. 
 }}

Если в базовом классе присутствует конструктор, то он должен остаться и в прозвольном классе
Если в классе присутствуют конструкторы, то все классы, которые от него наследуют, должны вызывать хотя бы один из этих конструкторов. 
При этом конструктор производного класса может иметь свои собственные параметры.

class Subclass : BaseClass {
 public Subclass(список параметров) Это конструктор производного класса.
 : base(список параметров базового класса) { Добавьте эту строку в конец объявления конструктора производного класса, и при любой его инициализации
будет вызываться конструктор из базового класса
 // сначала выполняется конструктор базового класса,
 // а потом все остальные операторы
 }}
 
Конструктор базового класса вызывается первым

Наследование
Сначала форма создает массив, затем — каждого рабочего, а затем добавляет его к массиву.
Worker[] workers = new Worker[4];
workers[0] = new Worker(new string[] { "Nectar collector", "Honey manufacturing" });
workers[1] = new Worker(new string[] { "Egg care", "Baby bee tutoring" });
workers[2] = new Worker(new string[] { "Hive maintenance", "Sting patrol" });
workers[3] = new Worker(new string[] { "Nectar collector", "Honey manufacturing",  "Egg care", "Baby bee tutoring", "Hive maintenance", "Sting patrol" });
queen = new Queen(workers); Форма имеет поле, указывающее на объект Queen. Она инициализирует поле, передавая созданный массив
объектов Worker конструктору объекта Queen.

Свойство CurrentJob дает понять объекту Queen, какую работу выполняет каждый рабочий. Если рабочий на момент проверки не занят, возвращается пустая 
строка.
Занятие каждой пчелы в текущий момент времени хранится в виде строки. Рабочий узнает, что ему делать, проверяя свойство CurrentJob. Если в ответ он 
получает пустую строку, значит, в настоящий момент он ничем не занят. В C# это легко реализуется: метод String.IsNullOrEmpty(CurrentJob) возвращает 
значение true для пустой строки CurrentJob и значение false в противном случае.

Элемент ComboBox называется workerBeeJob. Используйте свойство Items для формирования списка. DropDownStyle присвойте значение DropDownList,
чтобы пользователь мог выбирать значения из раскрывающегося списка. Щелкайте на поле Items в окне Properties, чтобы добавить в список шесть 
вариантов заданий.

workerBeeJob.SelectedIndex = 0; Дополнительная строка заставляет ComboBox отображать первый элемент (чтобы список не был пустым при загрузке формы).

1) Создадим класс Bee.
В классе Bee присутствует метод HoneyConsumptionRate(), вычисляющий потребление меда конкретной пчелой за одну смену. Превратим классы Worker и 
Queen в его расширения.

class Bee {
 public const double HoneyUnitsConsumedPerMg = .25;
 public double WeightMg { get; private set; }
 public Bee(double weightMg) {
 WeightMg = weightMg; Конструктор Bee в качестве параметра принимает вес пчелы в миллиграммах и на его основе вычисляет базовое потребление меда.
 }
 virtual public double HoneyConsumptionRate() {
 return WeightMg * HoneyUnitsConsumedPerMg;
 }}
 
2) Превратим классы Queen и Worker в расширения класса Bee.
Классы Queen и Worker будут наследовать базовое потребление меда от их нового предка, суперкласса Bee. Нужно, чтобы их конструкторы вызывали 
конструктор базового класса.
        Превратим класс Queen в потомка класса Bee. К конструктору добавим параметр weightMg типа double, который будет передан обратно в 
базовый конструктор.
        Превратим класс Worker в потомка класса Bee, с его конструктором следует осуществить такую же манипуляцию.
Подсказка: вы можете использовать в своих интересах сообщение об ошибке «does not contain a constructor», которое уже видели в этой главе! 
Заставьте класс Worker наследовать от класса Bee и выполните построение проекта. Когда IDE отобразит ошибку, двойной щелчок на ней автоматически 
перебросит вас на код конструктора Worker. Очень удобно!
3) Заствим форму присваивать вес матке и рабочим.
4) Перекройте метод HONEYCONSUMPTIONRATE() объекта Worker
Класс Queen потребляет мед подобно базовому классу Bee. Рабочие потребляют одно и то же количество меда... пока они ничего не делают. В процессе 
работы потребуется 0.65 дополнительной единицы меда за каждую смену. Это означает, что объект Queen может использовать базовый метод 
HoneyConsumptionRate(), унаследованный от суперкласса Bee, а объект Worker должен перекрыть этот метод, добавив  0.65 единицы меда на отработанную 
смену. Для наглядности можно поместить этот параметр в константу honeyUnitsPerShiftWorked.
IDE поможет нам начать. Введите для класса Worker «public override», и как только вы нажмете пробел, IDE покажет список всех доступных для 
перекрытия методов: Выберите HoneyConsumptionRate() в окне IntelliSense. После этого IDE сгенерирует заглушку метода, которая вызывает 
базовый метод. Введите туда код, который первым делом выводит результат работы метода base.HoneyConsumptionRate(), а затем добавьте 
дополнительные 0.65 единицы, съеденные за отработанную смену
5) Добавим потребление меда в отчет
Total honey consumed for the shift: XXX units

Благодаря наследованию вы легко смогли добавить в классы Queen и Worker поведение, учитывающее потребление меда. Только представьте, что
вместо этого вам пришлось бы вводить повторяющийся код вручную!

 page 312 -   Chapter 7
Интерфейсы и абстрактные классы

Действия значат больше, чем слова.
Иногда возникает необходимость сгруппировать объекты по выполняемым функциям, а не по классам, от которых они наследуют. Здесь вам на помощь
приходят интерфейсы — они позволяют работать с любым классом, отвечающим вашим потребностям. Но чем больше возможностей, тем выше ответственность, 
и если классы, реализующие интерфейс, не выполнят обязательств… программа компилироваться не будет.

Классы для различных типов пчел
Вот иерархия с классами Worker и Queen, наследующими от класса Bee. При этом класс Worker имеет производные классы NectarCollector
(Сборщик меда) и StingPatrol (Охранник).

Так будут выглядеть новые производные классы.
StingPatrol и NectarCollector наследуют от класса Worker. Эти классы хранят информацию, относящуюся к отдельным заданиям.
class StingPatrol : Worker
{ public int AlertLevel { get; private set; }
 public int StingerLength { get; set; }
 public bool SharpenStinger (int Length)
 {...}
 public bool LookForEnemies(){...}
 public void Sting(string Enemy){...}
}
class NectarCollector : Worker
{
 public int Nectar { get; set; }
 public void FindFlowers (){...}
 public void GatherNectar(){...}
 public void ReturnToHive(){...}
}

Интерфейсы
Наследовать класс может только от одного класса. Поэтому создание двух производных классов StingPatrol и NectarCollector не поможет нам
описать пчелу, которая в состоянии выполнять задания разных типов. 
Класс, реализующий интерфейс, должен включать в себя все методы и свойства, указанные в определении интерфейса. 

class Queen {
 private void DefendTheHive(StingPatrol patroller) { ... }
}
Объект NectarCollector умеет собирать нектар, а экземпляры StingPatrol борются с врагами. Но даже если матка научит сборщиков нектара 
защищать улей, добавив методы SharpenStinger() и LookForEnemies() в определение их класса, она все равно не сможет передать их своему методу
DefendTheHive(). Впрочем, можно воспользоваться двумя методами: 
private void DefendTheHive(StingPatrol patroller);
private void AlternateDefendTheHive(NectarCollector patroller); 

Даже если матка добавит методы защиты объекту NectarCollector, она не сможет передать их своему методу DefendTheHive(), так как он ожидает 
ссылки StingPatrol. Приравнять же ссылку StingPatrol объекту NectarCollector невозможно. Можно добавить аналогичный метод с названием 
AlternateDefendTheHive(), который будет ссылаться на объект NectarCollector, но код получится слишком громоздким и неудобным.
Методы DefendTheHive() и AlternateDefendTheHive() будут отличаться только типом параметра. А чтобы заставить защищать улей объекты
BabyBeeCare или Maintenance, вам потребуются дополнительные, «альтернативные» методы.

Но это плохое решение. Вы получаете два фрагмента кода, единственным различием которых является то, что один метод имеет 
параметр StingPatrol, а второй — NectarCollector. К счастью, решить подобные проблемы позволяют интерфейсы (interfaces). Они определяют, 
какие методы должны присутствовать в классе. Методы, указанные в определении интерфейса, должны быть реализованы. В противном случае 
компилятор выдаст сообщение об ошибке. Код методов может быть написан непосредственно в рассматриваемом классе или же унаследован от 
базового класса. Интерфейс не интересует происхождение методов и свойств, главное — чтобы при компиляции кода они были на своем месте.

Ключевое слово Interface
Чтобы добавить интерфейс к программе, писать методы не нужно. Достаточно указать их параметры и тип возвращаемого ими значения. И поставить 
в конце строки точку с запятой. Интерфейсы не хранят данные, поэтому вы не сможете добавить к ним поля. Но можно добавить определения свойств.
Дело в том, что интерфейс определяет список методов класса с определенными именами, типами и параметрами. Если вам кажется, что проблема может 
быть решена добавлением поля к интерфейсу, попробуйте вместо этого добавить свойство — вполне вероятно, это именно то, что вам было нужно.
Интерфейсам стоит давать имена, начинающиеся с прописной буквы I. Нет правила, обязывающего вас так поступать, но это делает код более простым. 
Чтобы убедиться, насколько это облегчает жизнь, установите курсор на пустую строчку внутри любого метода и наберите I, — IntelliSense
сразу же покажет вам список доступных интерфейсов .NET.

interface IStingPatrol //Интерфейс объявляется
{ Любой класс, реализующий этот метод, должен иметь эти методы и свойства,иначе программа не будет компилироваться.
 int AlertLevel { get;} Интерфейсы не хранят данные, они не имеют полей… но они могут иметь свойства.
 int StingerLength { get; set;}
 bool LookForEnemies();
 int SharpenStinger(int length); Любому классу, реализующему интерфейс, понадобится метод SharpenStinger() с параметром типа int.
}
interface INectarCollector
{
 void FindFlowers();
 void GatherNectar();
 void ReturnToHive();
}
В интерфейсе достаточно упомянуть имена методов, их код писать не требуется. Код написан в классе, реализующем данный метод.

Так как же помочь матке? Теперь она может создать метод, берущий в качестве параметра любой объект, который знает, как защитить улей:
private void DefendTheHive(IStingPatrol patroller) 
Ссылку IStingPatrol можно передать ЛЮБОМУ объекту, реализующему данный интерфейс.

Этот метод может использовать объект StingPatrol, NectarStinger или любую другую пчелу, знающую, как защитить улей. При реализации
IStingPatrol метод DefendTheHive() гарантирует наличие у объекта свойств и методов, необходимых для защиты улья. 

Все элементы открытого интерфейса по умолчанию являются открытыми. То есть с помощью интерфейса вы определяете открытые методы и свойства
любого реализующего его класса.

Экземпляр NectarStinger
Используйте двоеточие, чтобы реализовать интерфейс. После двоеточия сначала указывается класс, от которого происходит наследование, затем 
список интерфейсов. Если наследования не происходит, то интерфейсы перечисляются в произвольном порядке.

Как и в случае наследования, для реализации интерфейса используется двоеточие. Интерфейсы перечисляются через запятую.
class NectarStinger : Worker, INectarCollector, // Этот класс наследует от класса Worker и реализует интерфейсы INectarCollector и IStingPatrol.
IStingPatrol { 
 public int AlertLevel Экземпляр NectarStinger реализует оба интерфейса, ему требуются все их методы и свойства.
 { get; private set; }
 public int StingerLength
 { get; set; }
 public int Nectar { get; set; }
 public bool LookForEnemies() {...}
 public int SharpenStinger(int length)
 {...}
 Каждому методу в интерфейсе соответствует метод в классе. Иначе программа не будет компилироваться.
 Созданный вами объект NectarStinger сможет выполнять работу пчел как из класса NectarCollector, так и из класса StingPatrol.
 public void FindFlowers() {...}
 public void GatherNectar() {...}
 public void ReturnToHive() {...}
}
Класс, реализующий интерфейс так же, как и обычный, создает экземпляры при помощи оператора new и использует методы:
NectarStinger bobTheBee = new NectarStinger();
 bobTheBee.LookForEnemies();
 bobTheBee.FindFlowers();
 
Часто Задаваемые Вопросы
В: Зачем симулятору улья интерфейсы? Ведь мы добавляем еще один класс NectarStinger и все равно получаем дублирующийся код? О: Интерфейсы и не 
предназначены для борьбы с дублирующимся кодом. Они просто позволяют использовать один и тот же класс в разных ситуациях. Вам требовалось 
создать класс рабочих пчел, которые могут выполнять два задания. Интерфейсы дают возможность получить класс, выполняющий произвольное 
количество заданий. Скажем, у вас есть метод PatrolTheHive(), работающий с объектом StingPatrol, и метод CollectNectar() для объекта
NectarCollector. При этом хочется, чтобы класс StingPatrol мог наследовать от класса NectarCollector или наоборот, ведь в каждом
классе есть открытые методы и свойства, отсутствующие у другого. А теперь подумайте, как можно создать класс, экземпляры которого могут быть
переданы обоим методам. Есть какие-нибудь идеи? Проблему решают интерфейсы. Создав ссылку IStingPatrol, вы можете указать на любой объект, 
реализующий IStingPatrol, какому бы классу этот объект ни принадлежал. Можно указать как на объект StingPatrol, так и на объект NectarStinger 
или еще на что-нибудь. При этом вы можете использовать все методы и свойства, которые являются частью интерфейса IStingPatrol, независимо 
от типа объекта. Разумеется, вам придется создать новый класс, который и будет реализовывать интерфейс. Так что этот инструмент не позволит 
избежать создания дополнительных классов или сократить количество дублирующегося кода. Он всего лишь дает возможность получить класс для 
выполнения нескольких работ без привлечения наследования. Ведь наследуются все методы, свойства и поля другого класса. Как при работе с 
интерфейсами избежать дублирующегося кода? Можно создать отдельный класс с именем Stinger и кодом, относящимся к укусам или сбору нектара. 
После чего объекты NectarStinger и NectarCollector смогут создать закрытый экземпляр Stinger и для сбора нектара будут использовать его методы
и задавать его свойства.

Классы, реализующие интерфейсы, должны включать все методы интерфейсов
Реализация интерфейсов означает, что в классе должны присутствовать все объявленные в интерфейсе методы и свойства. Если это не так,
программа не компилируется. Если класс реализует несколько интерфейсов, он должен включать в себя все свойства и методы каждого из них.

1)Создайте новое приложение и добавьте в него класс IStingPatrol.cs
IDE, как обычно, добавит файл со строкой class IStingPatrol. Замените ее на interface IStingPatrol и введите код интерфейса, приведенный пару 
страниц назад. Вы только что добавили к проекту интерфейс! Теперь программа будет компилироваться.
2)Добавьте к проекту класс Bee
Но пока не добавляйте ни свойства, ни методы. Заставьте этот класс реализовывать интерфейс IStingPatrol:
class Bee : IStingPatrol
{
}
3)Попытайтесь скомпилировать программу Выберите команду Rebuild в меню Build. Компилятор не запустится:
Пометка does not implement (не реализует) будет выведена для каждого члена класса IStingPatrol. Компилятор на самом деле хочет, чтобы вы 
реализовали каждый метод интерфейса.
4)Добавьте в класс Bee методы и свойства
Добавьте методы LookForEnemies() и SharpenStinger(). Убедитесь, что их сигнатуры совпадают с представленными в интерфейсе. Метод LookForEnemies() 
должен возвращать логическое значение, а метод SharpenStinger() — принимать параметр типа int и возвращать такое же значение (сейчас они могут 
возвращать значения-заполнители). Добавьте свойство AlertLevel типа int с методом чтения (путь возвращает произвольное значение) и автоматическое 
свойство StingerLength типа int с методами чтения и записи. Убедитесь, что все члены класса Bee помечены как public. Теперь программа компилируется!


Учимся работать с интерфейсами
Поэтому создайте новый проект Console Application — и начнем!
Вот класс TallGuy (Высокий парень) и код метода Main() в файле Program.cs, который создает экземпляр класса при помощи инициализатора объекта 
и вызывает его метод TalkAboutYourself() (Рассказ о себе). Пока ничего нового:
class TallGuy {
 public string Name;
 public int Height;
 public void TalkAboutYourself() {
 Console.WriteLine("My name is " + Name + " and I'm "
 + Height + " inches tall.");
 }}
static void Main(string[] args) {
 TallGuy tallGuy = new TallGuy() { Height = 74, Name = "Jimmy" };
 tallGuy.TalkAboutYourself();}

Вы уже знаете, что элементы интерфейса должны быть открытыми. Проверим это. Добавьте к проекту интерфейс IClown (как вы добавляли классы): 
щелкните правой кнопкой мыши на имени проекта в окне Solution Explorer, выберите Add?New Item... и. Убедитесь, что он называется IClown.cs. 
IDE создаст интерфейс с объявлением:
interface IClown
{
Теперь попробуйте объявить внутри интерфейса закрытый метод:
private void Honk();
Выберите команду Build?Build Solution. Появится сообщение: Удалите модификатор private, сообщение об ошибке исчезнет
Модификатор public внутри интерфейса писать не нужно, доступ ко всем его методам и свойствам имеется по умолчанию.

Перед переходом к следующей странице попробуйте написать остальной код интерфейса IClown и заставить класс TallGuy реализовать этот интерфейс. 
Интерфейс IClown должен обладать не возвращающим значений и не имеющим параметров методом Honk (Гудок) и предназначенным только для чтения 
строковым свойством FunnyThingIHave (Смотри, что у меня есть), обладающим методом чтения, которое не имеет метода записи.

Вы записали интерфейс вот так?
interface IClown
{
 string FunnyThingIHave { get; } Это пример интерфейса, имеющего метод чтения, но не имеющего метода записи. Помните, что интерфейсы не могут 
 void Honk();        иметь полей, но когда вы реализуете свойство, предназначенное только для чтения, для остальных объектов оно выглядит как поле.       
}                                

Заставим класс TallGuy реализовывать IClown. Помните, что после двоеточия сначала ставится имя базового класса (если таковой имеется), а затем 
список интерфейсов через запятую. В данном случае базовый класс отсутствует, поэтому напишем: class TallGuy : IClown
Как только вы добавите все свойства и методы, упомянутые в интерфейсе, сообщение об ошибке пропадет. Поэтому добавьте предназначенное только для 
чтения свойство FunnyThingIHave с методом чтения, возвращающим строку большие ботинки. И добавьте метод Honk(), который пишет «Honk honk!» в консоль.
Вот как это выглядит:
public string FunnyThingIHave {
 get { return ?большие ботинки?; }
}
public void Honk() {
 Console.WriteLine("Honk honk!")
}

Ссылки на интерфейс
Это не работает...: IStingPatrol dennis = new IStingPatrol(); Попытка создать экземпляр интерфейса приведет к ощибкам компиляции

Можно создать массив ссылок IWorker, но получить новые объекты из интерфейса вы не сможете. Впрочем, вам достаточно будет сослаться на
новые экземпляры классов, реализующих интерфейс IWorker. Результатом будет массив, хранящий набор различных объектов!

Для интерфейсов ключевое слово new не работает, и это имеет смысл, ведь методы и свойства не имеют реализации. Объектам просто неоткуда было бы
узнать, как себя вести.
…зато работает это:
NectarStinger fred = new NectarStinger();
IStingPatrol george = fred; Объект может выполнять много функций, но используя интерфейсную ссылку, вы получаете доступ только к методам,упомянутым
                                в интерфейсе.
В первой строчке при помощи оператора new создается ссылка с именем Fred, указывающая на объект NectarStinger. Со второй строчкой все намного 
интереснее, так как здесь припомощи интерфейса IStingPatrol создается новая ссылочная переменная. На первый взгляд код выглядит несколько странно.
Но взгляните:
 NectarStinger ginger = fred;
Третий оператор создает новую ссылку на объект NectarStinger. Имя этой ссылки ginger, и она указывает на тот же самый объект, что и ссылка fred. 
Оператор george использует интерфейс IStingPatrol аналогичным способом.
Что же случилось?
Тут только один оператор new, так что появляется только один новый объект. Второй оператор создает ссылочную переменную george, которая может 
указывать на экземпляр любого класса, реализующий интерфейс IStingPatrol. 

Ссылка на интерфейс аналогична ссылки на объект

Вы уже знаете, как выглядят объекты в куче. Интерфейсная ссылка является всего лишь еще одним способом обратиться к уже знакомым объектам. 

Вы уже знаете, как выглядят объекты в куче. Интерфейсная ссылка является всего лишь еще одним способом обратиться к уже знакомым объектам. Это очень просто!

1) Объекты создаются как всегда.
Вы уже не раз это делали. Оба этих класса реализованы в IStingPatrol
StingPatrol biff = new StingPatrol();
NectarCollector bertha = new NectarCollector();
2) Добавьте ссылки на IStingPatrol и INectarCollector.
Интерфейсные ссылки ничем не отличаются от ссылок любого другого типа.
IStingPatrol defender = biff;
INectarCollector cutiePie = bertha;
3) Интерфейсная ссылка позволяет сохранить объект
Объект исчезает, как только на него не остается ссылок. Но никто не говорит, что все ссылки должны принадлежать одному типу! Интерфейсные ссылки 
позволяют спасти объект от удаления.
biff = null;
4)Назначьте интерфейсной ссылке новый экземпляр
На самом деле вам не нужны ссылки на объекты, можно создать новый объект и сопоставить его с ссылочной интерфейсной переменной.
INectarCollector gatherer = new NectarStinger();

Опператор is

Иногда требуется понять, реализуется ли интерфейс определенным классом. Предположим, что все рабочие пчелы представлены в виде массива Bees. 
В массиве можно хранить переменные типа Worker, так как все рабочие пчелы принадлежат классу Worker или производным от него классам. Но какая из 
рабочих пчел может собирать нектар? Для ответа на этот вопрос нужно узнать, реализует ли класс интерфейс INectarCollector. 
Это можно сделать при помощи оператора is.

Worker[] bees = new Worker[3]; //Рабочие представлены в виде массива Workers. Оператор is позволяет определить тип пчелы.
bees[0] = new NectarCollector();
bees[1] = new StingPatrol();
bees[2] = new NectarStinger();
for (int i = 0; i < bees.Length; i++) //Массив рабочих пчел просматривается в цикле, и оператор is определяет наличие методов и свойств, нужных для выполнения
 указанной работы.
{
 if (bees[i] is INectarCollector) // is сравнивает интерфейсы и другие типы данных
 {

 bees[i].DoThisJob("Nectar Collector", 3);
 }
}

Часто Задаваемые вопросы
В: Свойства, добавляемые в интерфейс, выглядят как автоматически реализуемые. Неужели при реализации интерфейса я могу использовать только такие свойства?
О: Вовсе нет. Свойства внутри интерфейсов действительно напоминают своим видом автоматически реализуемые — посмотрите на свойства Job и ShiftsLeft
в IWorker на следующей странице. Реализовать свойство Job
можно так:
public Job { get; private set; }
Модификатор private set ставится, так как автоматические свойства требуют наличия как метода чтения, так и метода записи (пусть даже и закрытого). Но вы
можете написать и другой код:
public job { get { return ″Бухгалтер″; } }
и программа все равно будет компилироваться. По желанию можно добавить и метод записи. (При реализации же через автоматическое свойство вы всего лишь 
решаете, будет метод записи открытым или закрытым.)

Интерфейсы и наследования

Когда один класс наследует от другого, он получает все его методы и свойства. Наследование интерфейсов происходит еще проще. Так как в интерфейсах отсутствуют
тела методов, вам уже не придется заботиться о вызове конструкторов и методов базового класса. Наследующие интерфейсы просто накапливают в себе
методы и свойства своих родителей.

interface IWorker От созданного нами интерфейса IWorker могут наследовать все остальные интерфейсы.
{
 string Job { get; }
 int ShiftsLeft { get; }
 void DoThisJob(string job, int shifts)
 void WorkOneShift()
}

Класс реализует все методы и свойства 
Класс, реализующий интерфейс, должен включать в себя все свойства и методы этого интерфейса. В ситуации, когда один интерфейс наследует от другого, 
все их свойства и методы также должны быть реализованы.

interface IStingPatrol : IWorker
{
 int AlertLevel { get;}
 int StingerLength { get; set;}
 bool LookForEnemies();
 int SharpenStinger(int length);
}Класс, реализующий интерфейс IStingPatrol, должен реализовывать не только эти методы но и методы интерфейса IWorker, от которого происходит наследование.

RoboBee 4000 функционирует без меда

Создадим пчелу новой формации, RoboBee 4000, работающую на топливе. «Привив» ее интерфейсу интерфейс  IWorker, вы даете ей возможность делать все то, 
что делает обычная пчела.

class Robot // Базовый класс Robot, дающий новой пчеле возможность «питаться» бензином. 
 {
 public void ConsumeGas() {...}
 }

class RoboBee : Robot, IWorker // Класс RoboBee наследует от класса Robot и реализует интерфейс IWorker. В итоге мы получили робота, который может 
выполнять работу обычной пчелы.
 { // Класс RoboBee реализует все методы интерфейса IWorker.
 private int shiftsToWork;
 private int shiftsWorked;
 public int ShiftsLeft
 {get {return shiftsToWork - shiftsWorked;}}
 public string Job { get; private set; }
 public bool DoThisJob(string job, int shiftsToWork){...}
 public void WorkOneShift() {...}
 }

Остальные классы нашего приложения не «увидят» функциональной разницы между пчелой-роботом и обычной пчелой. Оба этих класса реализуют 
интерфейс IWorker и с точки зрения программы действуют как рабочие пчелы. Отличить объекты друг от друга позволит оператор is:

if (workerBee is Robot) { // Оператор is показывает, какой класс или интерфейс реализует workerBee и каково его положение в иерархии наследования.
 // мы узнали, что workerBee
 // это объект Robot
}
Любой класс может реализовывать ЛЮБОЙ интерфейс, если он реализует все методы и свойства этого интерфейса. 

is показывает вам, что именно объект реализует
as показывает компилятору, как обработать этот объект

Иногда требуется вызвать метод, полученный объектом в процессе реализации интерфейса. Но что делать, если вы не знаете, нужному ли типу 
принадлежит объект? На помощь вам придет оператор is. А оператор as позволит преобразовать один совместимый ссылочный тип в другой.

IWorker[] bees = new IWorker[3];//Все эти пчелы реализуют интерфейс IWorker, но мы не знаем, какие из них реализуют другие интерфейсы, например INectarCollector.
 bees[0] = new NectarStinger();
 bees[1] = new RoboBee();
 bees[2] = new Worker();
for (int i = 0; i < bees.Length; i++) { // Мы не можем вызывать для пчел методы интерфейса INectarCollector. Ведь пчелы принадлежат типу IWorker и ничего
не знают о методах INectarCollector
 if (bees[i] is INectarCollector) { // …и проверяем, реализует ли пчела интерфейс INectarCollector.
 INectarCollector thisCollector;
 thisCollector = bees[i] as INectarCollector; // Оператор as заставляет использовать указанный объект как реализацию интерфейса INectarColle
 thisCollector.GatherNectar(); // Теперь можно вызывать методы интерфейса INectarCollector.
 
 
 Кофеварка относится к приборам
Для задачи экономии электроэнергии функции отдельных приборов не имеют значения. Вас заботит только то, что все они потребляют электричество. 
Поэтому при написании программы учета электроэнергии можно ограничиться классом Appliance (Прибор). Но чтобы отличить кофеварку от духовки, 
потребуется иерархия классов. Методы и свойства, описывающие поведение кофеварки и духовки, будут помещены в классы CoffeeMaker и Oven. Эти классы 
будут производными от класса Appliance, содержащего общие для них методы и свойства.
 
public void MonitorPower(Appliance appliance) {
 // код добавления данных в домашнюю
 // базу потребления энергии
}
 CoffeeMaker misterCoffee = new CoffeeMaker();
 MonitorPower(misterCoffee); // Метод MonitorPower() требует ссылки на объект Appliance, но ему можно передать ссылку misterCoffee, так как класс
CoffeeMaker является производным от класса Appliance.

Восходящее приведение

Когда вы используете производный класс вместо базового, например, ссылаясь на кофеварку вместо прибора, — это называется восходящим приведением (upcasting). 
Это очень мощный инструмент, который вы получаете, построив иерархию классов. К сожалению, он работает только с методами и свойствами базового класса. 
Другими словами, рассматривая кофеварку как прибор, вы не можете заставить ее сварить кофе MakeCoffee() или налить воду FillWithWater(). Зато вы можете 
определить, включена ли она в розетку, так как это состояние относится ко всем приборам (и именно поэтому свойство PluggedIn помещено в класс Appliance).

1)Создадим объекты
Классы CoffeeMaker и Oven создаются обычным способом:
 CoffeeMaker misterCoffee = new CoffeeMaker();
 Oven oldToasty = new Oven();

2)А вдруг нам потребуется массив приборов?
Объект CoffeeMaker нельзя поместить в массив Oven[ ], а объекту Oven не место в массиве CoffeeMaker[ ]. Но они прекрасно уживутся в массиве Appliance[ ]:
 Appliance[] kitchenWare = new Appliance[2];
 kitchenWare[0] = misterCoffee;
 kitchenWare[1] = oldToasty;

3)Не любой прибор является духовкой
Ссылаясь на объект Appliance, вы получаете доступ только к методам и свойствам приборов. Вы не можете при этом воспользоваться методами и свойствами
объекта CoffeeMaker,даже если вы знаете, что речь и в самом деле идет о кофеварке. Поэтому корректны следующие операторы:
 Appliance powerConsumer = new CoffeeMaker();
 powerConsumer.ConsumePower();
Но написав вот такую строчку:
 powerConsumer.MakeCoffee();
вы получите сообщение об ошибке: ‘Appliance’ does not contain a definition for ‘MakeCoffee’
так как после восходящего приведения можно пользоваться только методами и свойствами одного уровня с ссылкой, которую вы используете для доступа к объекту.

Нисходящее приведение

Теперь вы знаете, что, рассматривая кофеварку и духовку как приборы, вы лишаетесь доступа к их собственным методам и свойствам. К счастью, существует 
процедура нисходящего приведения (downcasting). Узнать, относится ли рассматриваемый объект Appliance к классу CoffeeMaker, можно при помощи оператора is. 
Теперь ничто не мешает вам вернуться от класса Appliance к классу CoffeeMaker при помощи оператора as.

1)Начнем с объекта CoffeeMaker
Вот код, который мы использовали для восходящего приведения:
 Appliance powerConsumer = new CoffeeMaker();
 powerConsumer.ConsumePower();
2)Но как превратить Appliance обратно в класс CoffeeMaker?
Для начала воспользуйтесь оператором is для проверки совместимости.
 if (powerConsumer is CoffeeMaker)
 // мы можем осуществить нисходящее приведение!

3)Теперь, когда вы точно знаете, что ваш прибор — кофеварка.  вы можете воспользоваться оператором as для нисходящего приведения, чтобы снова получить 
доступ к методам и свойствам класса CoffeeMaker. Так как класс CoffeeMaker наследует от класса Appliance, доступ к методам и свойствам базового класса у него 
тоже сохранится.
 if (powerConsumer is CoffeeMaker) {
 CoffeeMaker javaJoe = powerConsumer as CoffeeMaker;
 javaJoe.MakeCoffee();
 }

Неудачное нисходящее приведениевозвращает null
А что произойдет, если при помощи оператора as попытаться преобразоватьобъект Oven в объект CoffeeMaker? Вы получите нулевой результат, и программа 
прекратит работу.
 if (powerConsumer is CoffeeMaker) {
 Oven foodWarmer = powerConsumer as Oven;
 foodWarmer.Preheat();
 }// Объект powerConsumer не относится к классу Oven. Поэтому при попытке осуществить нисходящее приведение ссылка foodWarmer
даст null. Вот что произойдет при попытке использовать пустую ссылку...

Нисходящее и восходящее приведение интерфейсов
Вы уже видели, что операторы is и as работают с интерфейсами. Значит, для них возможны операции восходящего и нисходящего приведения. Добавим 
интерфейс ICooksFood к любому классу, который умеет подогревать еду. Добавим также класс Microwave (Микроволновка). Наряду с классом Oven он
будет реализовывать интерфейс ICooksFood. В результате вы получите три способа доступа к объекту Oven. А функция IntelliSense подскажет, какие операции 
вы можете производить в каждом из этих трех случаев
 
Часто Задаваемые Вопросы
В: Почему восходящее приведение можно осуществлять всегда, а нисходящее нет? 
О: Компилятор может предупредить вас о том, что восходящее приведение происходит неправильно. Более того, эта операция не работает, только когда вы
пытаетесь сопоставить объект классу, от которого не происходит наследования, или интерфейсу, который этим объектом не реализуется. Компилятор распознает
невозможность подобной операции и выводит сообщение об ошибке. При этом компилятор не может проверить, допустимо ли нисходящее присваивание, 
которое вы пытаетесь осуществить. Справа от оператора as может располагаться любое имя класса или интерфейса. В случае, когда нисходящее присваивание
невозможно, оператор as возвращает значение null. Компилятор допускает такое поведение, потому что бывают случаи, когда именно оно и требуется.
В: Кто-то говорил мне, что интерфейс подобен контракту, но я не понимаю почему.
О: Да, в определенной степени это действительно так. Заставляя класс реализовывать интерфейс, вы как бы обещаете компилятору поместить в него 
определенные методы. И компилятор следит, чтобы вы это обещание выполнили. Хотя намного нагляднее представить интерфейс в виде списка. По этому
списку компилятор проверяет присутствие в классе всех методов, упомянутых в интерфейсе.
В: Могу ли я поместить тело метода в интерфейс?
О: Нет, компилятор не позволит вам это сделать. Интерфейс не должен содержать операторы. Оператор в виде двоеточия, реализующий интерфейс, не имеет 
отношения к оператору, использующемуся при наследовании классов. Реализация интерфейса ничего не меняет в классе. Она всего лишь гарантирует присутствие 
в классе методов, перечисленных в интерфейсе.
В: Интерфейс выглядит как наложение ограничений, ничего не меняющих в самом классе. Зачем мне его использовать?
О: Если класс реализует интерфейс, интерфейсная ссылка может указывать на любой экземпляр этого класса. Это позволяет обойтись одним ссылочным типом,
который работает с набором объектов различного вида. Вот маленький пример. Лошадь, буйвол, мул и вол могут тащить телегу. Но в нашем симуляторе зоопарка 
Horse, Ox, Mule и Steer — разные классы. Для катания в парке аттракционов вы хотите создать массив животных, которые могут тащить тележку. Но поместить 
в один массив животных из разных классов можно только в случае, когда все они наследуют от общего базового класса. В нашем случае это условие не соблюдается. Что
же делать? Вам потребуется интерфейс IPuller с методами, отвечающими за перемещение тележки. Теперь вы можете объявить массив:
IPuller[] pullerArray;
В этот массив можно поместить ссылку на любое животное, реализующее интерфейс IPuller.
В: Можно ли реализовать интерфейс, не вводя много кода?
О: Конечно! Средства IDE позволяют реализовать интерфейс автоматически.
Начните вводить код класса:
class
 Microwave : ICooksFood
 { }
Щелкните на ICooksFood — под буквой I появится маленькая полоска. Если задержать на ней курсор, появится значок:
Щелкните на значке и выберите команду Implement Interface ‘ICooksFood’. Это автоматически добавит все члены, которые еще не реализуют интерфейс. 
Каждый из них снабжен оператором throws, о котором мы подробно поговорим в главе 10. 

Интерфейс напоминает список, с которым сверяется компилятор, проверяя, реализует ли ваш класс определенный набор методов.
 
 
 




 