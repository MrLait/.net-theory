		CLR
	Common Language Runtime, CLR — общеязыковая среда выполнения — это среда выполнения, которая подходит для разных языков 
программирования. 
	Исходный код программы может быть написан на любом языке, поддерживающем среду выполнения CLR. Затем соответствующий
компилятор проверяет синтаксис и анализирует исходный код программы. Результатом компиляции будет являться managed module. 
Помимо управляемого модуля компилятор генерирует IL-код и метаданные. 

		managed module
	Управляемый модуль (portable executable, PE) — стандартный переносимый исполняемый файл 32-разрядной или 64-разрядной Windows,
требует для своего выполнения CLR и является результатом компиляции исходного кода. 
	Управляемый модуль состоит: 
	- Заголовок PE32/PE32+  - содержит версию разрядности Windows в которой может исполнятся этот модуль, а также, тип файла,
временную метку, когда файл был собран. 
	- Заголовок CLR - заголовок включает нужную версию CLR, флаги, метку метаданных MethodDef - точки входа в управляемый модуль,
а также месторасположение, размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр;
	- Метаданные - это таблицы, описывающие типы данных и их члены, определенные в исходном коде и на которые имеются ссылки 
в исходном коде. Существуют три категории таблиц: определений, ссылок и манифестов.
	- Код Intermediate Language (IL) - код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует 
IL в машинные команды.
		
		IL-код
	IL-код - это код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды.
IL — язык более высокого уровня по сравнению с большинством других машинных языков. Он позволяет работать с объектами и имеет 
команды для создания и инициализации объектов, вызова виртуальных методов и непосредственного манипулирования элементами 
массивов, а так же нем есть команды инициирования и перехвата исключений для обработки ошибок.

		Метаданные
	Метаданные — это набор таблиц данных, описывающих то, что определено в управляемом модуле, например типы и их члены. 
В метаданных также есть таблицы, указывающие, на что ссылается управляемый модуль, например на импортируемые типы и их члены, 
которые всегда связаны с файлом, содержащим IL-код. Благодаря тому что компилятор генерирует метаданные и код одновременно и 
привязывает их к конечному управляемому модулю, возможность рассинхронизации метаданных и описываемого ими IL-кода исключена.
	 Например функция среды Visual Studio IntelliSense анализирует метаданные и сообщает, какие методы, свойства, события и поля 
предпочтительны в данном случае и какие именно параметры требуются конкретным методам.
	Метаданные позволяют сериализовать поля объекта, а затем провести процесс десериализации, восстановив объект и его 
состояние на удаленном компьютере.
	Метаданные позволяют сборщику мусора отслеживать жизненный цикл объектов. При помощи метаданных сборщик мусора может 
определить тип объектов и узнать, какие именно поля в них ссылаются на другие объекты
	Существуют три категории таблиц: определений, ссылок и манифестов. 

		manifest
	Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном содержат имена файлов, которые входят в сборку,
Кроме того, эти таблицы описывают версию и региональные стандарты сборки, ее издателя, общедоступные экспортируемые типы, 
а также все составляющие сборку файлы.

		assembly
	Сборка (assembly)- это совокупность одного или нескольких файлов, которые представляет собой исполняемое приложение, либо 
библиотеку DLL, содержащую набор типов, а один из файлов сборки выбирается для хранения ее манифеста, который представляет 
собой набор таблиц метаданных, содержащих в основном имена файлов, составляющих сборку. 
	Сборка обеспечивает логическую группировку одного или нескольких управляемых модулей или файлов ресурсов, поддерживающего 
многократное использование, безопасность и управление версиями. Например, редко используемые типы и ресурсы можно вынести в 
отдельные файлы сборки, которые могут загружаться по запросу из Интернета по мере необходимости в процессе выполнения программы.
	Модули сборки также содержат сведения о других сборках, на которые они ссылаются. Это позволяет среда CLR определить все 
прямые зависимости данной сборки, необходимые для ее выполнения.
	
		unsafe
	По умолчанию компилятор C# компании Microsoft генерирует безопасный код - это код безопасность которого подтверждается в 
процессе верификации. Небезопасный код - это код, способный напрямую работать с адресами памяти и манипулировать с байтами по 
этим адресам. Соответственно использование небезопасного кода создает значительный риск: он может повредить структуры данных и 
использовать или создавать уязвимости в системе безопасности. По этой причине компилятор C# требует, чтобы все методы, содержащие
небезопасный код, помечались ключевым словом unsafe, а при компиляции исходного кода использовался параметр компилятора /unsafe.

		Библиотека FCL
	FCL (Framework Class Library) - является одним из компонентов .NET Framework, который содержит набор сборок в формате DLL, 
содержащих несколько тысяч определений типов. Так как FCL содержит буквально тысячи типов, взаимосвязанные типы объединяются в 
одно пространство имен.
		
		CTS
	CTS (Common Type System) спецификация, которая описывает способ определения и поведение типов, например, тип может содержать 
ноль и более членов. Иметь, поля, методы, модификаторы доступа, а также определяет правила, управляющие наследованием, работой
виртуальных методов, сроком жизни объектов и т.д. Компания Microsoft предоставляет CTS вместе с другими частями .NET Framework в 
оргкомитете ECMA с целью стандартизации. Стандарт называется CLI (Common Language Infrastructure) и определяется 
спецификацией ECMA-335.

		CLI
	CLI (Common Language Infrastructure) - общеязыковая инфраструктура, а в документ ECMA-335 содержится спецификация общеязыковой
инфраструктуры (CLI)
	
		CLS
	CLS (Common Language Specification) в ней перечислен минимальный набор возможностей, которые должны поддерживаться компилятором
для генерирования типов, совместимых с другими компонентами, написанными на других CLS-совместимых языках на базе CLR.
	CLS определяет правила, которым должны соответствовать типы и методы с внешней видимостью, для того чтобы они могли 
использоваться в любом CLS-совместимом языке программирования

		Глобальный кэш сборок
	Место, где располагаются совместно используемые сборки, называют глобальным кэшем сборок (global assembly cache, GAC).
	Зачем «регистрировать» сборку в каталоге GAC? Например две компании сделали свою сборку OurLibrary, состоящую из файла с 
одинаковыи именем и поскольку файл, копируемый последним, перезапишет первый и тем самым нарушит работу какого-нибудь приложения,
чтобы не допустить этого для установки в GAC можно использовать специальный инструмент, который создаст отдельные папки для каждой
из этих сборок и скопирует каждую сборку в свою папку.

		System.Object
В CLR каждый объект прямо или косвенно является производным от System.Object. Благодаря тому, что все типы, в конечном счете, 
являются производными от System.Object, любой объект любого типа гарантированно имеет минимальный набор методов.
 - Equals - возвращает true, если два объекта имеют одинаковые значения. 
 - GetHashCode - возвращает хеш-код для значения данного объекта. 
 - ToString - по умолчанию возвращает полное имя типа, но можно переопределить, чтобы он возвращал объект String, содержащий 
состояние объекта в виде строки. 
 - GetType - позволяет получить тип данного объекта. Может использоваться с классами, реализующими отражение для получения 
информации о типе в виде метаданных. Является невиртуальным, его нельзя переопределить.
 - MemberwiseClone этот невиртуальный метод выполняет неглубокое клонирование Object. Возвращается ссылка на созданный
экземпляр, у которого значимые типы будут своими, а ссылочные общие.
 - Finalize - этот виртуальный метод вызывается автоматически уборщиком мусора. В типах работающих с неуправляемыми ресурсами, 
следует переопределить этот метод. 
 - ReferenceEquals - Определяет, совпадают ли указанные экземпляры Object. В отличие от Equals, сравнивает объекты по ссылке, 
а не значению. И являются статическими, принимая два объекта для сравнения.
	Что такое объект и класс?
	Объект - это экземпляр класса имеющий поведение и состояние определенное классом. 
	
		Что делает оператор new?
	Все объекты создаются при помощи оператора new, который вычисляет количества байт, необходимых для хранения всех 
экземплярных полей типа и всех его базовых типов.
	Для каждого объекта в куче добавляет дополнительные члены: указатель на объект (type object pointer) и индекс блока 
синхронизации (sync block index). Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого объекта
	Выделяет и резервирует необходимое количество памяти в управляемой куче. Выделенные байты инициализируются нулями (0).
	Инициализация указателя на объект-тип и индекса блока синхронизации.
	Вызов конструктора экземпляра типа с параметрами, указанными при вызове new, а так же вызывается конструктор System.Object, 
который ничего не делает, а просто возвращает управление.
	В итоге new возвращает ссылку на вновь созданный объект.

		Приведение типов
	Приведение типов - это механизм, при помощи которого мы можем преобразовать один тип в другой. C# поддерживает несколько 
видов приведения типов такие как:
	Неявные преобразования - в этом случае специального синтаксиса не требуется, например, преобразования из меньших в большие 
целочисленные типы, или	Upcasting - преобразования из производных классов в базовые классы.
	Явные привидение - если в ходе привидения данные могут быть утрачены или завершиться сбоем. Downcasting - для приведения типа к
производному от него типу. Для явных преобразований требуется выражение приведения такие как is, as, typeof или (T).
	Object o = new Employee();
	Employee e = (Employee) o;
	Пользовательские преобразования такие как методы операторов преобразования для этого используются ключевые слова operator и
implicit или explicit. 
	Преобразования с использованием вспомогательных классов, таких как BitConverter, Convert, Parse, TryParse.
	
		Операторы is и as, typeof
	Оператор is проверяет совместимость объекта с данным типом и возвращает true или false и никогда не генерирует исключение. 
Для null-ссылок оператор is всегда возвращает false, так как объекта, тип которого нужно проверить, не существует.
		if (o is Employee) { Employee e = (Employee) o;	}
	Но C# предложен механизм, повышающий эффективность кода с помощью оператора as. 
		Employee e = o as Employee; 
		if (e != null) { // Используем e внутри инструкции if}
	as возвращает ненулевой указатель на этот объект, а если нет, то оператор as возвращает null. При этом верифицирует тип 
объекта только один раз, а if лишь сравнивает e с null — такая проверка намного эффективнее, чем определение типа объекта. 
	Оператор typeof получает экземпляр System.Type для указанного типа. Оператор typeof принимает в качестве аргумента: 
имя типа или параметр типа: typeof(T), typeof(List<string>), typeof(int). Type myType = typeof(Person); 
Аргумент может быть типом dynamic или string?

		Namespace
	Пространства имен используются для логической группировки родственных типов, чтобы разработчику было проще найти нужный тип, а
также средство, позволяющее удлинить имя типа и сделать его уникальным, добавив к началу имени групп символов, разделенных точками
	alias - В C# есть еще одна форма директивы using, позволяющая создать псевдоним для отдельного типа или пространства имен. 

		Примитивные типы
	Типы данных, которые поддерживаются компилятором напрямую, у которых существуют прямые аналоги в библиотеке классов FCL. 
Например, int - System.Int32.(s)byte, (u)short, (u)int, (u)long, float, double, decimal, bool, char, string, object, dynamic.
	Можно неявное делать приведение типа, если не будет потери данных, но если есть вероятность потери данных, то требуется 
явного приведения типа. Например из Int32 в Byte так как при больших величинах Int32 теряется точность.	

		checked и unchecked
	checked и unchecked - механизм управления проверки переполнения, при выполнение арифметических операции над примитивными типами
	checked - если требуется указать, что выражение будет проверяться на переполнение. Выдастся исключение OverflowException.
	unchecked - если требуется проигнорировать переполнение. В этом случае результат усекается, чтобы не выйти за пределы 
диапазона представления чисел для целевого типа выражения.

		Примитивный тип данных dynamic
	Тип данных dynamic позволяет опустить проверку типов во время компиляции. Кроме того, объекты, объявленные как dynamic, могут
в течение работы программы менять свой тип.	Компилятор конвертирует тип dynamic в Object и применяет DynamicAttribute к различным
частям метаданных, где это необходимо. 
	Компилятор не позволит неявно присвоить тип Object к другому типу, нужно использовать явное приведение типов, но типом 
dynamic можно неявно привести к другому типу, только в таком случае CLR на этапе выполнения проверит правильность приведения с 
целью обеспечения безопасности типов. Если тип объекта несовместим с приведением, CLR выдает исключение InvalidCastException.
	Любое выражение может быть явно приведено к типу dynamic.
	dynamic можно использовать для определения аргументов типов обобщенных классов, структур, интерфейсов, делегатов или методов. 

		Ссылочные типы
	Ссылочные типы это типы, которые в переменных хранят ссылки на их объекты, которые хранятся в управляемой куче, а оператор new
возвращает адрес в памяти, где размещается сам объект. 	
	Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому операции над одной переменной могут 
затрагивать другую переменную. 
	Дополнительные члены, подлежат инициализации, незанятые полезной информацией обнуляются.
	Со временем ссылочный тип инициирует сборку мусора.	
	Ссылочные типы:	class, interface, delegate, record, dynamic, object, string.
				
		Значимые типы. Жизненный цикл Value-type объекта
	Значимые типы могут относиться к структурам (structure) и перечислениями (enumeration). Тип структуры, инкапсулирует данные 
и связанные функции, тип перечисления, определяется набором именованных констант. Структуры являются потомками абстрактного типа 
ValueType=>Object, перечисления типа Enum => ValueType => Object.
	Экземпляры значимых типов обычно размещаются в стеке потока, но могут быть встроены и в объект ссылочного типа. 
	Поля экземпляра размещаются в самой переменной, соответственно нет указателя на экземпляр.
	Экземпляры значимых типов не обрабатываются уборщиком мусора, что ускоряет работу приложения.
	Значимый тип является изолированным - он не может наследоваться, соответственно его методы не могут быть абстрактными и неявно
являются запечатанными, то есть их нельзя переопределить. Нельзя создавать в значимом типе новые виртуальные методы, но можно 
вызывать унаследованные виртуальные методы такие, как Equals, GetHashCode или ToString.
	Значимый тип может реализовывать интерфейсы.
	При инициализации всем членам этого типа присваивается 0. 	
	При обращении к значимому типу не может возникнуть исключение NullReferenceException.
	При присвоении переменной значимого типа присваивается другая переменная значимого типа, выполняется копирование всех ее полей.
	Каждая переменная значимого типа имеет собственную копию данных «объекта», поэтому операции с одной переменной значимого типа
не влияют на другую переменную.
	Объекты значимого типа существуют в двух формах : неупакованной (unboxed) и упакованной (boxed) т.к. неупакованные значимые
типы не размещаются в куче, отведенная для них память освобождается сразу при возвращении управления методом, в котором описан 
экземпляр этого типа (в отличие от ожидания уборки мусора).
	Приведение неупакованного значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как
интерфейсные переменные являются ссылочными, а также упаковывается, при вызове реализаций методов из базового типа, таких как 
GetType или MemberwiseClone всегда требует упаковки значимого типа.

		Упаковка и распаковка значимых типов
	Упаковка (boxing) - служит для преобразования значимого типа в ссылочный. Для этого в управляемой куче выделяется память. Ее 
объем определяется длиной значимого типа и двумя дополнительными членами — указателем на объект и индексом блока синхронизации. 
	Поля значимого типа копируются в выделенную кучу и возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть
значимый тип превращается в ссылочный.

	Распаковка (unboxing) - копирование полей из упакованного объекта, который находится в куче в неупакованный объект, который 
находится в стеке потока. Для этого сначала извлекается адрес полей упакованного объекта, а далее копирование этих полей из кучи в
экземпляр значимого типа, находящегося в стеке. Распаковка менее ресурсозатратна, чем упаковка.
	Если переменная, содержащая ссылку на упакованный значимый тип, равна null, то генерируется исключение NullReferenceException.
	Если ссылка указывает на объект, не являющимся упакованным типом требуемого значимого типа, генерируется, то генерируется
исключение InvalidCastException.

		Константы
	Константа является неявно статическим членом типа, значение, которой никогда не меняется, и определяться во время компиляции,
а хранится в метаданных модуля.
	Используется для упрощения чтения и сопровождения кода.
	Можно определять только примитивных типов или если присвоить ей значение null.
Константу следует использовать, только когда точно известно, что ее значение никогда не изменится, а иначе лучше использовать поля

		Поля
	Поле (field) — это член типа, который хранит экземпляр значимого типа или ссылку на ссылочный тип.
	Поля могут быть для чтения и записи (изменяемые), или только для чтения (неизменяемые).
	Неизменность поля ссылочного типа означает неизменность ссылки, которую этот тип содержит, а вовсе не объекта, на которую 
указывает ссылка, например в массиве можно менять значения элементам.
									Модификаторы применимые к полям: 
	экземплярный Static readonly							volatile 
					   	запись в поле разрешается 			Код, обращающийся к полю, не должен оптимизироваться компилятором, 
					   	только из кода конструктора.		CLR или оборудованием с целью обеспечения безопасности потоков. 
	
		Конструкторы
	Конструктор — это метод, у которого не задан тип возвращаемого значения, а сигнатура совпадает с именем типа, и служит для 
инициализации экземпляра типа и его полей.
	Конструкторы бывают двух типов: конструктор по умолчанию(без параметров), и конструктор с параметрами.
	Конструкторы могут быть экземпляров, статические и структур.
	
	Конструктор по умолчанию (default constructor) в C# - это конструктор, который создается автоматически компилятором, если 
в классе не определен ни один конструктор.

	Конструкторы экземпляров:
	Любые поля, не инициализированные конструктором явно, будут содержат 0 или null.
	Можно перегружать конструкторы, но количество параметров или их тип должны отличаться.
	this - позволяет явно вызвать один конструктор через другой, а base - позволяет вызывать конструктор из базового типа.
	Нельзя наследовать соответственно нельзя применять модификаторы virtual, override, new, sealed и abstract, async, unsafe 
	Если определить класс без явно заданных конструкторов, то будет создан конструктор по умолчанию, реализация которого просто 
вызовет конструктор без параметров базового класса, но если в базовом классе нет конструктора без параметров, производный класс 
должен явно вызвать конструктор базового класса base(), иначе компилятор вернет ошибку. 
	При вызове конструктора класса сначала выполняются конструкторы базовых классов и только затем конструкторы производных.
	В конечном счете всегда вызывается открытый конструктор объекта System.Object без параметров, который просто возвращает 
управление т.е в System.Object не определено никаких экземплярных полей.
	
	Статические конструкторы, конструкторы классов, типов или инициализаторы типов. 
	Статический конструктор служат для инициализации состояния типа или действия, которое выполняется только один раз. Он
вызывается автоматически перед созданием первого экземпляра или ссылкой на какие-либо статические члены. 
	У статического типа конструктор по умолчанию не создается так же как у запечатанных или абстрактных.
	Конструкторы типов можно применять к ссылочным и значимым типам. 
	У типа не может быть более одного статического конструктора, которые по умолчанию являются закрытыми, к ним нельзя применять
модификаторы доступа, а также у них никогда не бывает параметров. Из статического конструктора можно обращаться только к
статическим членам типа.
		
	Конструкторы структур
	Конструкторы у значимого типа можно не определять, но тогда поля будут инициализированные значениями по умолчанию 0 или null.
	Конструктор экземпляра значимого типа выполняется только при явном вызове.
	В версиях С# после 10+ можно создавать конструктор без параметров и инициализировать поля по умолчанию, а так же 
с 11 можно инициализировать не все поля, но им будет присвоено значение по умолчанию.
	При помощи выражения with и синтаксиса инициализатора объектов, который используется для указания элементов, которые нужно 
изменить, можно копировать структуру или анонимный тип.

		Методы перегруженных операторов
	Методы перегруженных операторов представляют собой метод, который перегружает определенный оператор, но не все операторы можно
перегружать, например, sizeof, typeof или new и другие, а некоторые должны быть перегружены парами.
	Перегруженные операторные методы должны быть открытыми и статическими, но implicit или explicit не используется.
	Тип, хотя бы одного из параметров или возвращаемого значения должен совпадать с типом, в котором определен операторный метод.
	public sealed class Complex {
		public static Complex operator+(Complex c1, Complex c2) { ... }
	}
	
		Методы операторов преобразования
	Метод операторов преобразования — методы, преобразующий объект одного типа(класса или структуры) в объект другого типа.
	Методы преобразования должен быть открытыми и статическими, далее указать implicit или explicit, при явном приведении типов.
	operator - сообщает компилятору, что данный метод представляет собой оператор преобразования.
	После ключевого слова operator указывается целевой тип, в который преобразуется объект, а в скобках — исходный тип объекта.
	Тип, хотя бы одного из параметров или возвращаемого значения должен совпадать с типом, в котором определен операторный метод.
		public sealed class Rational {
			public static implicit operator Rational(Int32 num) { Неявно создает Rational из Int32 и возвращает полученный объект
			return new Rational(num); }

		Методы расширения
	Метод расширения - статический метод, который вызывается при помощи синтаксиса экземплярного метода и позволяет добавлять 
новые методы в уже существующие типы без создания нового производного класса, даже если эти типы были определены в сторонних 
библиотеках, которые мы не можем изменять.
	Метод расширения должен быть объявлен в статическом необобщенном классе. Он является статическим методом, который принимает 
в качестве первого параметра тип, который помечен ключевым словом this, которое указывает, что данный метод является методом 
расширения для указанного типа и только первый параметр может быть отмечен ключевым словом this.
	Методами расширениями можно расширять типы, интерфейсные типы, типов-делегатов(Action) и перечислимые типы.
	С# поддерживает только методы расширения, а не например свойства расширения. Для статических классов и структур создавать 
методы расширения нельзя.
	Во время поиска метода расширения компилятор просматривает все статические классы, определенные в области файла, и сканирует
их статические методы. Если существуют два и более методов расширения, должен применяться синтаксис статического метода с
указанием имени статического класса, чтобы точно сообщить компилятору, какой именно метод нужно вызвать.
	Существует потенциальная проблема с версиями. Если в будущем разработчики Microsoft добавят экземплярный метод к классу 
StringBuilder с тем же прототипом, который совпадает с прототипом метода расширения, то после компилляции программы, компилятор 
свяжет с программой экземплярный метод компании Microsoft вместо метода расширения 	
		public static class StringBuilderExtensions {
			public static Int32 IndexOf(this StringBuilder sb, Char value) {//код метода}}

		Частичные методы
	Частичные методы (partial methods) - это методы, которые могут быть определены частично в одном месте и реализованы 
частично в другом месте. Ключевое слово partial говорит компилятору C#, что исходный код класса, структуры или интерфейса 
может располагаться в нескольких файлах. Компилятор объединяет все частичные файлы класса во время компиляции.
	Они используются в основном для разделения автоматического кода и кода, который должен быть написан вручную.
	Методы объявляются только внутри частичного класса или структуры.
	Объявление частичного метода и его реализующее объявление должны иметь идентичные сигнатуры.
	В новых версиях C# могут возвращать тип и иметь модификаторы доступа, но нельзя указать явно ключевое слово private. 
	Не могут иметь параметров out, но может иметь параметры, помеченные ключевым словом ref, а также универсальные параметры,
экземплярные, статические или unsafe.
	Если не существует реализующего объявления частичного метода, то нельзя создать делегат, ссылающегося на частичный метод. 

		Необязательные и именованные параметры
	Необязательными параметрами являются параметры, которым присвоено значение по умолчанию, после необязательных параметров все
последующие параметры также должны быть необязательными. void M(string name, int age = 1, string company = "Undefined")
	Именованные параметры это параметры у которых указано имя параметра и через двоеточие его значение. ctor(company:"Microsoft")
	Значения по умолчанию указываются для параметров методов, конструкторов и индексаторов и делегатов. 
	Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами, кроме слова params, который должен
располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию.
	Либо если используются в правильном положении. Параметр находится в правильной позиции, но не имеет явно заданного имени.
		PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
	Ключевые слова default и new, можно использовать для параметров, чтобы проинициализировать их в первоначальное состояние.
	Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.

		Неявно типизированные локальные переменные
	Неявно типизированные локальная переменная - переменная помеченная ключевым словом var. 
	Чтобы определить ее тип, компилятор смотрит на тип выражения с правой стороны от оператора присваивания (=).
	var name = "Jeff";

		Передача параметров в метод по ссылке
	По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу
передается ссылка на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если
параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта,
а исходный экземпляр сохраняется неизменным
	Ключевые слова out, ref и in позволяет передавать параметры по ссылке, а не по значению. 
	Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод, но
вызванный метод должен записать в него значение, прежде чем вернуть управление. 
	Если параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод
может как читать, так и записывать значение параметра.
	Модификатор in указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение
параметра нельзя будет изменить.
	Использование ключевого слова out со значимыми типами повышает эффективность кода, так как предотвращает копирование
экземплярных полей значимого типа при вызовах методов.
	Со значимыми типами ключевые слова out и ref позволяют методу управлять единственным экземпляром значимого типа. 
	Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью. 
	В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, а вызванный код управляет этим
указателем. Т.е все изменения, выполняемые внутри метода, влияют на исходный объект, в отличии от случая передачи ссылочного типа
по значению можно менять только значения объект, но присвоение новой ссылки не повлияет на исходный объект.

		Передача переменного количества аргументов
	Примененное ключевое слова params позволяет методу принимает одномерный массив значений и может быть помечен только последний
параметр метода. 
	Что бы метод принимающий произвольное количество параметров любого типа, для этого достаточно назначить тип params Object[]. 
	Вызов метода, принимающего переменное число аргументов, снижает производительность. Чтобы уменьшить негативное влияние этих
операций на производительность, лучше определить несколько перегруженных методов, в которые не используется ключевое слово params.
	static Int32 Add(params Int32[] values) {

		Типы параметров и возвращаемых значений					
	Объявляя тип параметров метода, нужно указывать «минимальные» типы, предпочитая интерфейсы базовым классам используя интерфейс
IEnumerable<T> вместо сильного типа, List<T>. 
	В то же время, объявляя тип возвращаемого методом объекта, желательно выбирать самый сильный из доступных вариантов. 
	
		Свойства
	Свойства - это тип членов класса, который позволяет получить или установить состояние поле объекта класса.
	Свойства могут быть статические, экземплярные, абстрактные и виртуальные. 
	Свойства могут помечаться модификатором доступа и определяться в интерфейсах.
	Свойства должны иметь имя и тип, но не void.
	Не могут быть обобщенными.
	Нельзя перегружать, то есть определять несколько свойств с одинаковыми именами, но разным типом. 
	Свойства нельзя передавать в метод в качестве параметров с ключевым словом out или ref.
	set, определяет, что свойство, доступное только для записи.
	get, определяет, что свойство, доступное только для чтения.
	Свойства могут быть доступны только для чтения/записи, в то время как поля всегда доступны и для чтения, и для записи. 
	Свойство, являясь по сути методом, может выдавать исключения, а при обращениям к полям исключений не бывает.

		Свойства с параметрами
	Индексаторы аналогичны свойствам, но позволяют обращаться к объекту как к массиву, передавая индексы в квадратных скобках, 
где индекс - это некоторое значение, используемое для доступа к элементу. Индексаторы позволяют удобно обращаться к элементам 
коллекций, массивов и других структур данных.
	Для объявления индексаторов вместо имени используется ключевое слово this, за которым следуют параметры в квадратных скобках.
		private string[] strings = new string[10];
			public string this[int index]
			{
				get { return strings[index]; }
				set { strings[index] = value; }
			}
	Для обращения к индексатору используется имя переменной и квадратные скобки, как с массивом. Аргументы индексатора необходимо
поместить в квадратные скобки: var item = someObject["key"]; someObject["SecondKey"] = item;
	У индексатора должен быть хотя бы один или более параметров. Соответственно методы доступа get получают один или несколько 
параметров,	типы параметров и тип возвращаемого значения может быть любым, но не void.
	В типе можно определять несколько индексаторов при условии, что они получают разные наборы параметров.
	Тип может поддерживать множество перегруженных индексаторов при условии, что их сигнатуры различны включая методов доступа.
		
		Инициализаторы объектов и коллекций
	Инициализаторы объектов позволяют присваивать значения всем доступным полям и свойствам объекта во время создания без вызова
конструктора, за которым следуют строки операторов присваивания. 
		Employee e = new Employee() { Name = "Jeff", Age = 45 };			
	Реальная выгода от синтаксиса инициализатора объекта состоит в том, что он позволяет программировать в контексте выражения,
строя функции, которые улучшают читабельность кода.
		String s = new Employee() { Name = "Jeff", Age = 45 }.ToString().ToUpper();
	При инициализации коллекции можно передать несколько аргументов, для чего используется синтаксис с фигурными скобками:
		var table = new Dictionary<String, Int32> { { "Jeffrey", 1 }, { "Kristin", 2 }, { "Aida", 3 }, { "Grant", 4 }};

		Анонимные типы
	Анонимные тип - это тип который позволяют инкапсулировать свойства только для чтения в один объект без необходимости
определения нового типа.
	Анонимный тип определяется с помощью ключевого слова var, оператора new и инициализатором объектов.
	Свойства анонимного объекта доступны только для чтения, поскольку они не имеют сеттеров. А так же не могут быть переданы в 
качестве аргументов в обобщенных методах.
	Анонимные типы обычно используются в select предложении выражения запроса, для возврата наборов значений из методов или 
для передачи данных между методами в качестве аргументов.
		var o1 = new { Name = "Jeff", Year = 1964 };
	
		Тип System.Tuple и ValueTuple
	Tuple - это обобщенный кортежный тип который наследуется от класса Object, который позволяет объединять набор значений 
разных типов в единый объект без создания явно определенной структуры или класса.
	Позволяют возвращать несколько значений из методов и передавать как параметр метода или просто для объединения нескольких 
значений в один объект, а так же удобно использовать в конструкторе для инициализации полей типа
	ValueTuple это значимый тип, а Tuple это ссылочный тип. Это означает, что при создании экземпляра Tuple происходит
выделение памяти на стеке, а не на куче и соответственно вызывается уборщик мусора. 
 	У ValueTuple его элементы могут иметь имена: 	var person = (Name: "John", Age: 30, City: "New York");
													var tuple = Tuple.Create(1, "Hello", true)
	ValueTuple использует поля, а не свойства.
	ValueTuple являются изменяемыми типами, а тип Tuple - неизменяемые.
	Кроме того, Tuple может содержать до 8 элементов
 	Tuple можно создавать с помощью указания явных типов, var, именованные кортежи или конструктор кортежей, а для обращения, 
к полям используем порядковый номер или имя, если оно было указано через двоеточие, а так же с помощью деконструкции:	
						var myTuple = (1, "Hello", true);
						int firstItem = myTuple.Item1; // получаем первый элемент (1)
						var (firstItem, secondItem, thirdItem) = myTuple; //деконструкция

		События	
	События — это члены типа, который позволяет типу регистрировать и отменять регистрацию на событие, и поле-делегат для 
управления набором зарегистрированных методов и получения уведомлений на которые он подписался. Для объявления событие указываем
модификатор доступа, ключевое слово event, тип делегата, указывающий на прототип вызываемого метода, и имя.
	Событие не может возвращать значения и вызывается только из типа, можно объявить в интерфейсе, а так же всегда public. 
События позволяет типу отправлять уведомления статическим или экземплярным методам.
	Определение события состоит из двух частей: объявления делегата и создания события на основе этого делегата.
			public delegate void ClickEventHandler(object sender, EventArgs e); 		// Определяем делегат для события Click
			public event ClickEventHandler Click;    									// Определяем само событие Click
			protected virtual void OnClick() => Click?.Invoke(this, EventArgs.Empty);	// Метод, вызывающий событие Click
	События являются механизмом, где одни объекты создают события, а подписчики или обработчики событий подписываются на них и
выполняют соответствующие действия в ответ на возникновение событий. 
	Чтобы подписаться на событие, необходимо создать метод, который будет обрабатывать это событие, и затем добавить этот метод
в список обработчиков события. Для того, чтобы при возникновении события передать обработчику события дополнительную информацию
подписчикам, нужно в новом классе инкапсулировать набор данных, а в соответствии с соглашением этот тип должен наследоваться от
типа EventArgs, а имя типа должно заканчиваться словом EventArgs.
	Делегат в отличии от события - делегирует свою работу внешнему коду, вызывая методы других объектов, и может быть параметром
в методе или возвращаемым значением, а событие используются для уведомления об изменениях в объекте.
	
		Обобщения
	Обобщения — механизм, для многократного использования кода, а именно многократного использования алгоритмов. Разработчик
описывает алгоритм, но не указывает типы данных, с которыми тот работает, что позволяет применять алгоритм к объектам разных типов.
	Поддерживаются обобщенные: ссылочные и значимые типы, обобщенные интерфейсы, делегаты и методы определенные в ссылочном, 
значимом типе или в интерфейсе, а так же при наследовании.
	Не поддерживается обобщенные: перечислимые типы, свойства, индексаторы, события, конструкторы, деструкторы и операторные
методы, все кроме первого могут использоваться в обобщенных типах, чтобы в их коде использовать параметры-типы этого типа.
	При определении обобщенного типа или метода, переменные, указанные вместо типа T, называются параметрами типа type parameters.
T — это имя переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий тип данных. В
случае обобщенного типа или метода указанные типы данных называют аргументами-типами (type arguments).
	Преимущества обобщений:	
	Защита исходного кода. Разработчику, использующему обобщенный алгоритм, не нужен доступ к исходному тексту алгоритма.
	Безопасность типов. Попытка использования несовместимого объекта приведет к ошибке на этапе компиляции или исключению во 
время выполнения. 
	Более простой и понятный код. Поскольку компилятор обеспечивает безопасность типов, в исходном тексте требуется меньше
операция приведения типов, а такой код проще писать и сопровождать.
	Повышение производительности. До появления обобщений приходилось следить, чтобы все челны типа были совместимы с типом Object,
но тогда значимые типы, приходилось упаковать, перед вызовом членов алгоритма, что приводит к процедурам уборки мусора.
	Поскольку обобщение можно использовать для работы с конкретным значимым типом, экземпляры значимого типа могут передаваться
по значению и CLR не нужно выполнять упаковку. Операции приведения типа также не нужны, поэтому CLR не нужно контролировать
безопасность типов при их преобразовании, что также ускоряет работу кода.

		Верификация и ограничения
	Ограничение сужает перечень типов, которые можно передать в обобщенном аргументе, и расширяет возможности по работе с этими
типами. public static T Min<T>(T o1, T o2) where T : IComparable<T> 
	Маркер where сообщает компилятору, что указанный в T тип должен реализовывать обобщенный интерфейс IComparable того же типа(T)
Благодаря этому ограничению компилятор разрешает методу вызвать метод CompareTo т.к он определен в интерфейсе IComparable<T>.
	Ограничения можно применять к параметрам типа обобщенных типов и обобщенных методов. 
	При переопределении виртуального обобщенного метода в переопределяющем методе должно быть то же число параметров-типов, а они
наследуют ограничения, заданные для них методом базового класса. Переопределяемый метод вообще не вправе задавать ограничения для
своих параметров-типов, а только может переименовывать параметры-типы. Аналогично, при реализации интерфейсного, причем эти 
параметры-типы наследуют ограничения, заданные для них методом интерфейса.
	Не поддерживается перегрузка по именам параметров типа или по именам ограничений, только по арности:
	internal sealed class AType {}
	internal sealed class AType<T> {}
	internal sealed class AType<T1, T2> {}
	К параметру-типу могут применяться следующие ограничения основное (primary), дополнительное (secondary) и/или ограничение 
конструктора (constructor constraint). 

		Основные ограничения
	Основным ограничением может быть незапечатанный ссылочный тип, за исключением Object, Array, ValueType и Void в новых версиях 
языка можно использовать Enum, Delegate, MulticastDelegate. Указывая ограничения ссылочного типа означает, мы говорим компилятору,
что заданный аргумент-тип будет относиться к типу, указанному в ограничении, либо к производному от него.
	По умолчанию, если ограничение не указано, то оно будет типа Objet, но явно задавать этот тип нельзя.
	В параметре-типе может быть только одно основное ограничения.  
	Так же существуют еще два особых основных ограничения: class и struct. сlass гарантирует, что указанный аргумент-тип является
ссылочным типом. К нему относятся все классы, интерфейсы, делегаты и массивы. struct гарантирует, что указанный аргумент-тип будет
иметь значимый тип. К нему относятся все значимые типы, и перечисления, кроме Nullable<T> т.к получилась бы рекурсия.
	
		Дополнительные ограничения 
	К дополнительным ограничениям относятся ограничения интерфейсного типа. Данное ограничение гарантирует, что указанный 
аргумент-тип будет определять тип, реализующий этот интерфейс. Можно задать ноль и более интерфейсных ограничений, соответственно
тип передаваемого параметра должен реализовывать все интерфейсные ограничения и все основные ограничения, если они заданы.
	Существуют интерфейсные ограничения и ограничение параметра типа.
	Ограничением параметра типа (type parameter constraint). Позволяет задавать отношение между аргументами типа.
	public class SomeClass : ISomeInterface<MyClass>	// интерфейсные ограничения
	public class Example<T> where T : IComparable		//ограничение параметра типа
	Преимущество использования интерфейсного ограничения со значимым типом является: Избавляет от упаковки при передаче
экземпляров значимых типов, но, если тип аргумента объявить интерфейсом, то будет выполнена упаковка.

		Ограничения конструктора
	Ограничение конструктора гарантирует компилятору, что указанный аргумент-тип будет иметь неабстрактный тип, имеющий открытый
конструктор без параметров.	Можно задать не более одного ограничения конструктора. 
	Нельзя задавать одновременно struct(значимых типов) и new(), т.к у любой структуры есть обязательный конструктор без
без параметров и такая запись является избыточной.
		internal sealed class ConstructorConstraint<T> where T : new() {}
	
		Наследование в классах
	Наследование - это механизм языка, который позволяет определить производный класс на основе существующего, а также наследовать
его данные и свойства, при этом у класса может только один прямой родитель, который предоставляет набор сигнатур и реализации его
методов, а новый класс может стать базовым для другого класса, и новый производный класс унаследует все сигнатуры методов и их
реализации. В С# каждый объект прямо или косвенно наследуется от Object, что позволяет наследовать его методы.
	Наследования классов — дает возможность подстановки экземпляров производного типа в любые контексты, в которых выступают 
экземпляры базового типа Upcasting.
	Производный класс может наследовать практически все члены базового типа, кроме конструкторов - их нужно определять для каждого
класса, а при помощи base() можно вызывать конструктор базового класса.
	Производные классы могут переопределять унаследованные члены, которые в базовом классе отмечены ключевым словом virtual, а 
если член базового класса, отмечен ключевым словом abstract, то он обязательно должен переопределяться в производном классе
	Наследование применяется только для классов и интерфейсов. Другие категории типов (структуры, делегаты и перечисления) не 
поддерживают наследование. Класс может наследовать ноль и более интерфейсов, через указание их имен, но должен реализовать все
унаследованные методы интерфейсов. Интерфейсы позволяет реализовать ограниченное множественное наследование.

		Модификаторы доступа
	private являются видимыми только в производных классах, которые вложены в базовый класс.
	protected члены являются видимыми только в текущем и производных классах. Производный класс может располагаться в другой сборке.
	internal члены являются видимыми только для тех членов, которые находятся в той же сборке, что и базовый класс.
	protected internal: члены являются видимыми из того же класса, наследника и любой части программы в той же сборке. Он также 
доступен в производном классе, расположенном в другой сборке, только в том случае, если доступ осуществляется через переменную 
типа производного класса
	private protected: компонент класса доступен из любого места в своем классе или в производных классах, которые определены в 
той же сборке.
Структуры не могут использовать модификаторы private protected, protected и protected internal, поскольку структуры не могут быть 
унаследованы.

		Наследование интерфейсов
	Интерфейс представляет собой тип с набором сигнатур методов и не содержит их реализации до C#8 т.е с помощью интерфейса мы 
определяем поведение которое будет реализовано в каком-то конкретном классе. В интерфейсах можно определять статические поля, 
константы, свойства, события и индексаторы и методы (начиная с версии C# 8.0)
	При определении интерфейсного типа можно указать модификатор доступа по умолчанию internal и ключевое слово interface, а в 
соответствии с соглашением имена интерфейсных типов начинаются с прописной буквы I. 
	Интерфейс может наследовать другие интерфейсы, а наследующий интерфейс класс, должен реализовать все их методы.
	Помимо наследование интерфейсов классами, интерфейсы могут наследоваться от интерфейсов, при этом интерфейсы поддерживают 
множественное наследование.
	Аналогичным образом как и классы наследование от интерфейсов позволяет подставлять экземпляры типа, реализующего интерфейс, во
все контексты, где требуются экземпляры указанного интерфейсного типа, что позволяет создавать слабосвязанные и гибкие приложения,
например DI контейнер, MOCK-тестирование.
	CLR поддерживает обобщенные интерфейсы и интерфейсные методы.
	Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался модификатором public. 
	По умолчанию интерфейсный метод является виртуальным и запечатанным, это не позволяет производному классу переопределять 
интерфейсные методы, но если явно указать метод как виртуальный, компилятор сделает его таковым и оставит незапечатанным, что 
предоставит производному классу возможность переопределять интерфейсные методы.
	Производный класс не в состоянии переопределять интерфейсные методы, объявленные запечатанными, но может повторно унаследовать
тот же интерфейс и предоставить собственную реализацию его методов. При вызове интерфейсного метода объекта вызывается реализация,
связанная с типом самого объекта.		

		Явные и неявные реализации интерфейсных методов
	Иногда нужно определить тип, реализующий несколько интерфейсов с методами, у которых совпадают имена и сигнатуры. Требуется 
определить тип, реализующий оба этих интерфейса. В этом случае нужно реализовать члены типа путем явной реализации методов так как
этот тип должен реализовывать несколько различных методов, нужно сообщить компилятору C#, какой из методов реализацию для
конкретного интерфейса.
	Чтобы создать явную реализацию интерфейсного метода (Explicit Interface Method Implementation, EIMI) нужно перед именем метода
указано имя интерфейса, в котором определен этот метод, например IDisposable.Dispose. При явной реализации интерфейсного метода в
нельзя указывать уровень доступа, по умолчанию он получит закрытый уровень доступа (private), что запрещает любому коду
использовать экземпляр класса простым вызовом интерфейсного метода. Единственный способ вызвать интерфейсный метод — обратиться 
через переменную этого интерфейсного типа.
	EIMI-метод не может быть виртуальным, а значит, его нельзя переопределить.
	Недостатками EIMI являются: также отсутствие IntelliSense-поддержки в Microsoft Visual Studio, при приведении к интерфейсному
типу экземпляры значимого типа упаковываются, EIMI нельзя вызвать из производного типа, явная реализация интерфейсного метода не
может вызываться из производного класса.	
	
		Обобщенные интерфейсы
	Обобщенный интерфейс - это механизм который позволяет не указывать аргумент-тип, а только описать набор сигнатур, а уже в 
ссылочном или значимом типе, который реализуют обобщенный интерфейс указать этот аргументов-типов. Любая попытка работы со
значимым типом через необобщенный интерфейс, будет приводить к необходимости упаковки и потере безопасности типов, соответственно
	Обеспечивают безопасность типов на стадии компиляции. 
	При работе со значимыми типами требуется меньше операций упаковки. 
	Класс может реализовать один интерфейс многократно, просто используя параметры различного типа.
	Параметры интерфейса обобщенного типа могут быть также помечены как контравариантные или ковариантные, что позволяет более
гибко использовать интерфейсы

		Абстрактный класс
	Абстрактный класс - это класс с модификатором abstract, который указывает, что класс предназначен только для использования в 
качестве базового класса и не должен быть создан сам по себе, а его члены имеют отсутствующую или неполную реализацию. 
	Абстрактные классы могут быть наследованы от базового класса и могут переопределять виртуальные методы.
	Абстрактные классы могут быть наследованы от интерфейса и сопоставлять методы интерфейса с абстрактными методами.
	Абстрактные типы могут содержать абстрактные методы, свойства, индексаторы и события
	Абстрактный класс может иметь не абстрактные переменные, методы, конструкторы, свойства.
	При переопределении в производном классе абстрактный метод или свойство объявляются с модификатором override. Если класс имеет
хотя бы один абстрактный член, то этот класс должен быть определен как абстрактный.

		Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах
	Каждый из параметров-типов обобщенного делегата должен быть помечен как ковариантный или контравариантный. Благодаря этому 
можно выполнять приведение экземпляров обобщенного делегата к тому же типу делегата, но с другим параметром-типом. 
	Параметры-типы могут быть:
	Инвариантными - параметр-тип не может изменяться и данный подход используется по умолчанию.
	Контравариантными - параметр тип может быть преобразован к производному классу от него и обозначается ключевым словом in и 
может появляться только во входной позиции, например, в качестве параметра метода.
	Ковариантными - параметр-тип может быть преобразован к базовому классу и обозначается ключевым словом out и может появляться 
только в выходной позиции, например, возвращаемого значения метода.
	Нельзя использовать инвариантность с ключевыми словами ref и out
			
		Методы
	Метод это член типа, который содержит набор инструкций. Сигнатура метода может иметь модификатор доступа, virtual и другие, 
тип возвращаемого значения, имя метода, а так же передаваемые параметры. Тип возврата метода не является частью сигнатуры метода
в целях перегрузки метода, а только для делегата. 
	Метод может быть экземплярным либо статическим, для вызова экземплярного нужно создать объект.
	Метод можно вызывать, используя и позиционные, и именованные аргументы. Позиционные аргументы могут следовать за именованными
аргументами, только если именованные аргументы находятся в правильных позициях.
	Методы помеченные virtual, abstract можно переопределять в наследниках при помощи override, но new, скрывает реализацию
данного метода, свойства, статического поля или константы из базового класса.
	base.MethodName() - base позволяет вызывать метод из базового класса.
	При передаче параметров по значению изменение значимого типа в методе не повлияет на исходный объект, а изменения значения 
ссылочного повлияет, кроме изменения ссылки.
	При передаче параметров по ссылке используя ключевые слова ref, out, in используются, когда нужно изменить значение аргумента
в методе и сохранить это изменение после того, как управление вернется вызывающему методу, кроме in.
	Параметры метода поддерживают: params одномерный массив параметров, default(SomeType) необязательные параметры, new ValType(),
где ValType — это тип значения. Если метод содержит как обязательные, так и необязательные параметры, необязательные параметры
определяются в конце списка параметров после всех обязательных параметров.
	Возвращаемые значения: если указан тип возвращаемого значения, то метод может вернуть его при помощи return, а если тип void,
инструкцию return без значения по-прежнему можно использовать для завершения выполнения метода. Без ключевого слова return этот
метод будет останавливать выполнение при достижении конца блока кода.
	В некоторых случаях нужно, чтобы метод возвращал больше одного значения. Это можно легко сделать, используя типы кортежей и
литералы кортежа.
	Если метод передает массив в качестве аргумента и изменяет значение отдельных элементов, метод не требуется для возврата
массива т.к. C# передает все ссылочные типы по значению, а значением ссылки на массив является указатель на массив.
	Так же есть методы расширения, частичные методы, методы операторов преобразования, методы перегруженных операторов.
	Обобщенные методы: все методы, определенные в обобщенных типах, могут использовать их параметр-тип. Параметр-тип может
использоваться для параметров метода, возвращаемого значения и типа заданной внутри него локальной переменной, а так же метод
может иметь собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных.
Использование обобщенных типов с методами, получающими параметры out и ref, должны быть того же типа, что и параметр метода, чтобы
избежать возможного нарушения безопасности типов.

		Символы
	Символы в .NET Framework всегда представлены 16-разрядными кодами стандарта Юникод и являются экземпляром структуры Char, тип
System.Char содержит два открытых неизменяемых поля: константа MinValue MaxValue.
	Для облегчения работы с типом Char имеется несколько статических методов также несколько собственных экземплярных методов
	Есть три способа преобразования различных числовых типов в экземпляры типа Char, и наоборот: приведение типа, использование 
типа Convert, который содержит несколько статических методов, или использование интерфейса IConvertible, котором определены такие
методы, как ToUInt16 и ToChar.
	 
		Строки
	System.String — представляет неизменяемый набор символов, являясь прямым потомком Object, и является ссылочным типом, поэтому
всегда размещаются в куче. String относится к примитивным типам соответственно компилятор помещает эти литеральные строки в
метаданные модуля, откуда они загружаются и используются во время выполнения.
		String s = "Hi" + " " + "there."; 	// Конкатенация трех литеральных строк образует одну литеральную строку
	Конкатенацию литеральных строк, компилятор выполняет на этапе компиляции, а в метаданных модуля помещается строка "Hi there."
	Конкатенация нелитеральных строк происходит на этапе выполнения, соответственно ее применять нежелательно, так как он создает
в куче несколько строковых объектов. Рекомендуется использовать тип System.Text.StringBuilder.
	Интерполяция строк  - это когда используется знак доллара перед строкой, а внутри строки используются плейсхолдеры {}, в 
которых уже можно напрямую писать те выражения, которые мы хотим вывести. $"Имя: {name}  Возраст: {age}"
	Буквальные строки (verbatim strings) — используют при задании пути к файлу или каталогу и при работе с регулярными выражениями
		String file = "C:\\Windows\\System32\\Notepad.exe"; 				String file = @"C:\Windows\System32\Notepad.exe";
	Неизменность строк дает определенные преимущества такие как:
	Для начала можно выполнять операции над строками, не изменяя их.
	Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. 
	Сравнение строк - операторы равенства == и != по определению сравнивают не ссылки, а значения объектов string.
	Необработанные строковые литералы - доступны начиная C#11 содержат произвольный текст, не требуя escape-последовательностей. 
Необработанные строковые литералы заключены как минимум в три двойные кавычки (""").
	Интернированию строк (string interning). В CLR несколько ссылок String могут указывать на один, а не на несколько разных 
строковых объектов, если строки идентичны. А значит, можно сократить количество строк в системе и уменьшить расход памяти.
	Интернирование строк - если в приложении строки сравниваются часто методом порядкового сравнения с учетом регистра или если в
приложении ожидается появление множества одинаковых строковых объектов, то для повышения производительности надо применить
механизм интернирования строк (string interning). При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами являются
строки, а значениями — ссылки на строковые объекты в управляемой куче. Вначале таблица, разумеется, пуста. В классе String есть
два метода, предоставляющие доступ к внутренней хеш-таблице:
		String Intern(String str);  					 String IsInterned(String str);
	Intern, ищет String во внутренней хеш-таблице. Если строка обнаруживается, возвращается ссылка на соответствующий объект
String. Иначе создается копия строки, она добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию. Если приложение
больше не удерживает ссылку на исходный объект String, уборщик мусора вправе освободить память, занимаемую этой строкой. 
	IsInterned получает параметр String и ищет его во внутренней хеш-таблице. Если поиск удачен, IsInterned возвращает ссылку на
интернированную строку. В противном случае он возвращает null, а саму строку не вставляет в хеш-таблицу.
	Создание пулов строк - чтобы не допустить роста объема кода, многие компиляторы хранят литеральную строку в метаданных модуля
только в одном экземпляре. Все упоминания этой строки в исходном коде компилятор заменяет ссылками на ее экземпляр в метаданных. 
	
		StringBuilder
	Тип StringBuilder в отличие от String представляет изменяемую строку. Это значит, что изменение содержимого экземпляра SB, не 
создает новых объектов, размещаемых в управляемой куче. StringBuilder выделяет память для новых объектов только в двух случаях:
	при динамическом построении строки, размер которой превышает установленную емкость;
	при вызове метода ToString типа StringBuilder.	
	У объекта StringBuilder предусмотрено поле со ссылкой на массив структур Char. Используя члены StringBuilder, можно эффективно
манипулировать этим массивом, сокращая строку и изменяя символы строки. При увеличении строки, представляющей ранее выделенный
массив символов, StringBuilder автоматически выделит память для нового, большего по размеру массива, скопирует символы и приступит
к работе с новым массивом. А прежний массив попадет в сферу действия уборщика мусора. 
	Вызов метода ToString типа StringBuilder преобразовывает массив символов StringBuilder в объект String. Этот метод возвращает
просто ссылку на строку. Поскольку массив символов здесь не копируется, метод выполняется очень быстро.
	У типа StringBuilder несколько конструкторов. Задача каждого из них — выделять память и инициализировать три внутренних поля,
управляемых любым объектом StringBuilder: 
	Максимальная емкость (maximum capacity) по умолчанию оно равно Int32.MaxValue.
	Емкость (capacity) — поле типа Int32, показывающее размер массива символов StringBuilder. По умолчанию оно равно 16. 
	Массив символов (character array) — массив структур Char, содержащий набор символов «строки». 
	
		Форматирование нескольких объектов в одну строку
	String s = String.Format("On {0}, {1} is {2} years old.", new DateTime(2012, 4, 22, 14, 35, 5), "Aida", 9); 

		Перечислимые типы
	Перечислимым (enumerated type) называют тип, в котором описан набор пар, состоящих из символьных имен и значений т.е это 
обычная структура, внутри которой описан набор константных полей и одно экземплярное поле. Константные поля попадают в метаданные
сборки. Программу, где используются перечислимые типы, проще написать и понять, а у разработчиков возникает меньше проблем с ее 
сопровождением т.к программист видит осмысленные символьные имена, а не цифры. Перечислимые типы подвергаются строгой проверке 
типов. Например,компилятор сообщит об ошибке, если в качестве значения я попытаюсь передать методу тип Color.Orange, когда метод 
ожидает перечислимый тип Fruit (фрукт).	
	Перечислимые типы относятся к значимым типам и наследуется от типа Enum <= ValueType <= Object.  
	Перечислимого типа не может быть методов, свойств и событий, но методы можно имитировать при помощи методов расширения.
	При компиляции перечислимого типа компилятор C# превращает каждый идентификатор в константное поле типа.
	В основе любого перечисления лежит один из основных типов, например (s)byte, (u)short, int используется по умолчанию и (u)long
	Компилятор C# считает перечислимые типы примитивными, поэтому для операций с их экземплярами можно применять операторы	(==, 
!=, <, >, <=, >=, +, –, ^, &, |, ~, ++ и ––).
	Компилятор C# допускает приведение экземпляров одного перечислимого типа к другому. 
	Также поддерживается явное и неявное приведение к числовому типу.
	Имеющийся экземпляр перечислимого типа можно связать со строковым представлением — для этого следует вызвать ToString, 
унаследованный от System.Enum: 	public static Array GetValues(Type enumType) и 	public Array GetEnumValues(); 
	Этот метод вместе с методом ToString позволяет вывести все идентификаторы и числовые значения перечисления
				
		Битовые флаги	
	Перечисления можно использовать для создании битовых флагов, благодаря этому экземпляр enum может иметь комбинацию значений
констант, определенных в списке. Для создания перечисления с битовым флагом нужно добавить атрибут [Flags] или [FlagsAttribute]
	Определяя перечислимый тип, битовыми флагами, каждому идентификатору следует явно присвоить числовое значение. 
	Стоит добавлять идентификатор None, значение которого определено как 0. 
	Константы должны быть степенями двойки - это гарантирует, что комбинации флагов не будут перекрываться.
	Если есть часто используемые комбинации флагов, то их можно добавить в перечисление.
	Стоит использовать только положительные константы, чтобы не вводить никого в заблуждение.
	Т.к константы должны содержать степень двойки, то можно задавать их несколькими способами: двоичными литералами, 
числовым литералом с операцией сдвига, десятичными числами и шестнадцатеричными.
	Для комбинирования, сброса и проверки флагов используются битовые операции.	Битовые маски широко используются в среде .Net,
в частности для указания привязки объектов к контейнерам и определения уровня доступа к файлам, это лишь малая часть из 
перечислений которые входят в состав .Net Framework.

		Делегаты
	 Делегат (delegates) - функциями обратного вызова, которая обеспечивает безопасность типов при выполнении обратного вызова
методов, а так же позволяют последовательно вызывать несколько методов.
	Делегаты могут вызывать статические и экземплярные методы.	
		internal delegate void Feedback(Int32 value);// Объявление делегата; 
	Делегаты определяются при помощи ключевого слова C# delegate, а оператор new создает экземпляр делегата.
	Сигнатура метода должна быть совместима с сигнатурой делегата - это означает что оба типа должны принимать один и тот же
аргумент и возвращать значение одного и того же типа.
	делегаты могут быть параметрами методов, а так же можно возвращать из методов.
	Класс делегата, определенный компилятором, содержит четыре метода: конструктор, а также методы Invoke, BeginInvoke и EndInvoke
	Делегаты можно определять как внутри класса (вложенные в другой класс), так и в глобальной области видимости. По сути, т.к 
делегаты являются классами, их можно определить в любом месте, где может быть определен класс.
	Класс MulticastDelegate является производным от класса Delegate, который, в свою очередь, наследует от класса System.Object.	
	Делегаты поддерживают ковариантность и контравариантность ссылочных типов при привязке метода к делегату. 			
	Обратный вызов нескольких методов (цепочки делегатов) Цепочкой (chaining) называется коллекция делегатов, дающая возможность
вызывать все методы, представленные этими делегатами. Для этого есть перегруженные версии операторов += и -= для экземпляров
делегатов. Эти операторы вызывают методы Delegate.Combine и Delegate.Remove соответственно.
	Если делегат возвращает некоторое значение, то возвращается значение последнего метода из списка вызова, в качестве
альтернативы можно воспользоваться экземплярным методом GetInvocationList класса MulticastDelegate. Этот метод позволяет в
явном виде вызвать любой из делегатов в цепочке:	
	Можно не определяем метод обратного вызова, а подставить реализацию метода обратного вызова непосредственно в код, а не в
отдельный метод. Скажем, наш код можно записать так:  ThreadPool.QueueUserWorkItem( obj => Console.WriteLine(obj ), 5);
							
		Обобщенные делегаты	
	При определении типа делегата с параметрами типа, компилятор задает методы класса делегата, а параметры типа применяются ко
всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.	(чет не понятно, но понятно)
	В .NET Framework имеются 17 делегатов Action, от не имеющих аргументов вообще до имеющих 16 аргументов. Кроме делегатов 
Action имеется 17 делегатов Func, которые позволяют методу обратного вызова вернуть значение. Но, если нужно передать аргумент по
ссылке, используя ключевые слова ref или out, может потребоваться определение собственного делегата:
	delegate void Bar(ref Int32 z);
	Аналогично нужно действовать в ситуациях, когда требуется передать делегату переменное число параметров при помощи ключевого
слова params
	Поддержка обобщенных делегатов в CLR позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом
безопасность типов. Более того, благодаря обобщенным делегатам экземпляры значимого типа могут передаваться методам обратного
вызова без упаковки. 

		Настраиваемые атрибуты
	Настраиваемые атрибуты представляют собой средство передачи дополнительной информации, которая хранится в метаданных 
управляемого модуля. Атрибуты могут применяться как ко всему типу: классу, интерфейсу и т.д., так и к отдельным его частям:
методу, свойству и т.д. Чтобы применить атрибут для этого нужно имя атрибута поместить в квадратные скобки перед именем класса или
другим членом типа.
	Можно применить один или несколько атрибутов ко всей сборке, к модулю или к более мелким элементам программы, например к
классам и свойствам. Атрибуты могут принимать параметры, также как методы и свойства. Можно явным образом указать target - целевой
объект атрибута, например, что атрибут применяется к методу, параметру или возвращаемому значению. А при помощи отражения можно
получать сведения атрибутов, которые применены к объекту, используя метод GetCustomAttributes.
	Настраиваемый атрибут — это экземпляр класса, который должен прямо или косвенно наследовать от абстрактного класса Attribute и
должен иметь открытый конструктор для создания экземпляров. 
			
		Null-совместимые значимые типы
	Класс System.Nullable<T> - это структура, которая позволяет принимать значимым типам значение null, а ее экземпляры могут
размещаться в стеке потока. Часто используется в связке с БД, т.к переменные, которые она может возвращать, могут быть равны null.
Но следует учесть, что операции с Nullable типом выполняются медленнее аналогичных операций с другими значимыми типами.
	Структура Nullable<T> имеет два свойства: Value - возвращает значение объекта и HasValue: возвращает true или false, если
объект равен null. В качестве параметра T могут использоваться только структуры, но можно использовать упрощенный синтаксис
воспользовавшись знаком вопроса: Int32? y = null;
	Можно выполнять преобразования и приведение экземпляров Nullable типов к другим типам.
	Можно применять операторы к экземплярам null-совместимых значимых типов. Но следует учитывать, что если в операции участвует
nullable-тип, то результатом также будет значение nullable-типа и если один из операндов равен null, то результатом операции
также будет null, а в операциях сравнения, если хотя бы один из операндов равен null, то возвращается false.: 
	int? x = 5;		int z = x + 7; - нельзя; int? w = x + 7; - можно; int d = x.Value + 7; - можно
	int? x = null;  int? w = x + 7; // w = null
	Можно использовать is с шаблоном типа, чтобы проверить и получить значение базового типа или свойство HasValue: int? a = 42;
	var str = (a is int valueOfA) ? $"a is {valueOfA}" : "a does not have a value";
	var str = (а.HasValue) ? $"a is {valueOfA}" : "a does not have a value";
	Можно использовать оператор объединения null-совместимых значений ?? и ??= Если левый операнд не равен null, оператор
возвращает его значение. В противном случае возвращается значение правого операнда
	Упаковка null-совместимых значимых типов 
	Если в переменную типа Nullable<Int32> присвоено значение null, то для передачи этой переменной ссылочному типу, ее следует
упаковать и передать ссылку на упакованный тип Nullable<Int32>. При упаковке экземпляра Nullable<T> проверяется его равенство на
null, но в случае положительного результата вместо упаковки возвращается null. Но если присвоено значение отличное от null,
например 5, то тип Nullable<Int32> упаковывается в тип Int32 с аналогичным значением.
	Распаковка null-совместимых значимых типов
	Упакованный значимый тип T распаковывается в T или в Nullable<T>. Если упакованный значимый тип равен null, то и при
выполннении распаковки в тип Nullable<T> присваивается значение null, а в T исключение NullReferenceException. 
	При вызове метода GetType для объекта типа Nullable<T> CLR возвращает тип T вместо Nullable<T>, а так же будет произведена 
упаковка. Поэтому для определения int или int? нужно использовать связку Nullable.GetUnderlyingType и оператор typeof
	bool IsNullable(Type type) => Nullable.GetUnderlyingType(typeof(int?)) != null;
								
		Механика обработки исключений. try-catch-finally. throw ex vs throw. Создание пользовательских исключений; Корректное 
		восстановление после исключения;
	Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а иногда и вовсе невозможно.При
обработке исключений используются ключевые слова try, catch и finally для действий, которые могут оказаться неудачными. Например,
при передачи файла по сети может неожиданно оборваться сетевое подключение или просто нужно закрыть сетевое подключение или файл.
private void SomeMethod() {
try { // Код, требующий корректного восстановления или очистки ресурсов}
catch (InvalidOperationException) { // Код восстановления работоспособности после исключения InvalidOperationException}
catch (IOException) { // Код восстановления работоспособности после исключения IOException}
catch {Код восстановления работоспособности после остальных исключений - их обычно генерируют повторно.
	throw;}
finally { // Код, выполняющий очистку ресурсов после операций, начатых в блоке try. Он выполняется ВСЕГДА}
	// Код, следующий за блоком finally, выполняется, если в блоке try не генерировалось исключение или если исключение было 
перехвачено блоком catch, а новое не генерировалось
}
	Блок try
	В блок try помещается код, требующий очистки ресурсов или восстановления, после исключения, а сам код очистки содержится в
блоке finally. Так же может располагаться код, приводящий к генерации исключения. Код же восстановления вставляют в один или
несколько блоков catch.
	Блок try должен быть связан хотя бы с одним блоком catch или finally; сам по себе он не имеет смысла иначе будет ошибка.
	Когда внутри такого блока try возникает исключение, поток управления переходит к первому подходящему обработчику исключений в
стеке вызовов. Если для созданного исключения не существует обработчиков, выполнение программы прекращается с сообщением об ошибке
	Один блок try может быть вложен ноль и больше блоков try. Исключение, генерируемое во внутреннем блоке try и не перехваченное
в соответствующем блоке catch, передается во внешний блок try.
	Блок catch
	В блок catch помещают код, который должен выполняться в ответ на исключение. Выражение в скобках после ключевого слова catch
называется типом исключения (catch type). Один блок catch соответствует одному событию, после которого может потребоваться
восстановление приложения. 
	Поиск подходящего блока catch осуществляется сверху вниз, поэтому сначала следуют потомки с наибольшей глубиной наследования,
потом — их базовые классы и, наконец, — класс Exception или блок с неуказанным типом исключений.
	При обнаружении блока catch нужного типа выбирается способ восстановления после исключения. Еще раз сгенерировать то же
исключение throw или throw ex, сгенерировать исключение другого типа throw new exceptOb для передачи информации о нем коду,
расположенному выше в стеке или позволить программному потоку выйти из catch естественным образом.
	В последнем же случае происходит переход к блоку finally (если он, конечно, существует). После выполнения всего содержащегося
в нем кода, управление переходит к расположенной после блока finally инструкции. Если блок finally отсутствует, поток переходит к
инструкции, расположенной за последним блоком catch. 
	В C# после типа перехватываемого исключения можно указать имя переменной, которая будет ссылаться на сгенерированный объект,
потомок класса System.Exception. В коде блока catch эту переменную можно использовать для получения информации об исключении .
	Если код в блоке try не порождает исключение, CLR никогда не переходит к выполнению кода блоке catch, а сразу переходя к коду
блока finally, если таковой существует. Выполнив код блока finally, поток переходит к инструкции, следующей за этим блоком.
	Фильтры исключений
	Фильтры исключений позволяют обрабатывать исключения в зависимости от определенных условий. Для их применения после выражения
catch идет выражение when, после которого в скобках указывается условие: catch (DivideByZeroException) when (y == 0) {cw("0");}
	Блок finally
	Код блока finally выполняется всегда. Обычно этот код производит очистку после выполнения блока try. Если в блоке try был
открыт некий файл, блок finally должен содержать закрывающий этот файл код, а если код блока try выполняется без исключений, файл
закрывается. 
	Блок try может существовать и без блока finally его следует поместить после всех блоков catch. Одному блоку try может
соответствовать только один блок finally.
	Явное создание исключений исключение можно вызвать явным образом с помощью C# throw new exceptOb;
	Перехваченное исключение можно вызвать повторно с помощью оператора throw, которое повторно выбрасывает исключение, которое
было обнаружено, и сохраняет трассировку стека (путь к источнику исключения), а throw ex генерирует одно и то же исключение, но
сбрасывает трассировку стека на этот метод это полезно, если нужно скрыть от пользователя конфиденциальную информацию, которую
может содержать трассировка стека.

		Создание пользовательских исключений.
	Можно создавать собственные классы исключений для этого нужно создать сериализуемый класс, который наследует от Exception, а
имя класса должно заканчиваться на Exception. Классы должен определять три конструктора:
    public InvalidDepartmentException() : base() { } один конструктор без параметров, 
    public InvalidDepartmentException(string message) : base(message) { } свойство сообщения
		и тот, который задает как свойство сообщение так и InnerException свойство.
    public InvalidDepartmentException(string message, Exception inner) : base(message, inner) { }
	Определите любые дополнительные свойства и конструкторы которые бутут хранить дополнительную информацию.
	При добавлении новых свойств в производный класс исключений необходимо переопределить метод ToString() чтобы он возвращал
добавленные сведения.	
	При использовании инструкций lock, using и foreach блоки try/finally создаются автоматически. Компилятор строит эти блоки и
при переопределении деструктора класса метод Finalize.
	При работе с упомянутыми конструкциями написанный вами код помещается в блок try, а код очистки — в блок finally. А именно:
	если вы используете инструкцию lock, то внутри блока finally снимается блокировка;
	если вы используете инструкцию using, то внутри блока finally для объекта вызывается метод Dispose;
	если вы используете инструкцию foreach, то внутри блока finally для объекта IEnumerator вызывается метод Dispose;
	если вы определяете деструктор, то внутри блока finally вызывается метод Finalize базового класса
					
		Корректное восстановление после исключения
	Нужно использовать блоки try/catch/finally для восстановления после ошибок, освобождения ресурсов или ресурсов, которые лежат
за пределами dotNet.
	Обработка общих условий без выдачи исключений. Для условий, которые могут возникнуть, но способны вызвать исключение,
рекомендуется реализовать обработку таким способом, который позволит избежать исключения. Например, если попытаться закрыть уже
закрытое подключение, вы получите InvalidOperationException. Этого можно избежать, используя оператор if для проверки состояния
подключения перед попыткой закрыть его.	Если вы не проверяете состояние подключения перед закрытием, можно перехватить
InvalidOperationException исключение блоком catch.
	Можно использовать специальные методы или свойства предоставляемые классом, чтобы недопустить возникновения исключения.
Например при чтении из файла, определять, достигнут ли конец файла.
	Необработанные исключения - если ни один из блоков catch не отвечает типу исключения, возникает необработанное исключение 
(unhandled exception). Обнаружив в процессе поток с необработанным исключением, CLR немедленно уничтожает этот поток. 
Необработанное исключение указывает на ситуацию, которую не предвидел программист, и должно считаться признаком серьезной ошибки.
		
		Потоки и процессы. Их различия. Переключения контекста. background и foreground thread
	Первые операционные системы не поддерживали концепцию потоков. Соответственно задачи которые выполнялись длительное время
приостанавливали выполнение других задач, либо приводили к ошибки и проходилось перезагружать систему. Поэтому для решения этих
проблем были придуманы потоки и процессы. Каждому процессу выделяется собственный поток исполнения, который работает как
виртуальный процессор. Если код приложения войдет в бесконечный цикл, то блокируется только связанный с этим кодом процесс, 
а остальные процессы продолжают функционировать.
	Процесс - набор ресурсов, используемый отдельным экземпляром приложения и имеет собственно виртуальное адресное пространство,
что гарантирует, что код и данные одного процесса будут изолированы для другого
	Различие между процессом и потоком: поток и процесс служат для разделения работы, но поток стоит выбирать для легковесных
операций, в то время как процесс для тяжелых операций. Каждый процесс имеет собственное виртуальное пространство с набором
ресурсов, а инициализированный поток использует эти ресурсы. Обмен данных между потоками в рамках одного процесса быстрее, чем у
отдельных процессов.
	Переключения контекста (context switching) - механизм который позволяет распределять физический процессор между всеми своими
потоками путем переключения контекста на другой поток. Переключение контекста повышает надежность
системы и скорость реагирования на действия конечных пользователей, но снижает производительность.
	Фоновые и активные потоки background и foreground. 
	foreground - активные поток, при завершении всех активных потоков также принудительно завершат свою работу все запущенные 
фоновые потоки и завершит выполнение приложения. Поток можно превращать из активного в фоновый и обратно, а при помощи
свойства IsBackground узнать фоновый он или активных. 
	Основной поток приложения и все потоки, в созданные путем объекта Thread, по умолчанию являются активными. А вот потоки из 
пула по умолчанию являются фоновыми.

		Способы создания потоков.
	Первый способ используя явное создание потока при помощи Thread, для создания которого следует передать конструктору имя
метода, а для запуска потока нужно вызвать метод Start. Сигнатура метода должна совпадать с сигнатурой делегата с параметром 
либо без:	delegate void ParameterizedThreadStart(Object obj);
	Потоки, созданные путем конструирования объекта Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию
являются фоновыми. 
	Недостатком является то, что для каждого отдельного задания нужно создавать новый поток и нельзя переопределить для потока 
новое задание, что приводит к проблеме производительности.

	Второй способ использовать пул потоков ThreadPool. Каким образом поток берется с тред пула и возвращается туда обратно
	Среда CLR способна управлять собственным пулом потоков.	Если в один процесс загружаются несколько экземпляров CLR, для каждого
из них формируется собственный пул. Итак, при инициализации CLR пул потоков пуст, пока не появится запрос, который помещается в 
очередь пула потоков. Далее код пула извлекает запросы из очереди и распределяет их среди потоков из пула. Если у пула нет потока,
то создается новый поток, а при завершении исполнения своего задания поток не уничтожается, а возвращается в пул в ожидание 
следующего запроса это позволяет повысить производительность, но если приложение отправляет пулу много запросов, которые он не 
успевает обслужить с помощью одного потока, то создаются дополнительные потоки, которые через некоторое время бездействия, после
уменьшения нагрузки пробуждаются и самоуничтожатся, освобождая ресурсы.
	Для добавления в очередь пула потоков асинхронных вычислительных операций обычно вызывают следующий метод класса ThreadPool:
ThreadPool.QueueUserWorkItem(new WaitCallback(SomeMethod)); и соответствующий делегат delegate void WaitCallback(Object state);
	Преимущества: нет необходимости создавать новый поток на каждое задание, что повышает производительность приложения. Пул 
потоков управляет потоками эффективно, уменьшая количество создаваемых, запускаемых и останавливаемых потоков. Используя пул 
потоков, можно сосредоточиться на решении задачи, а не на инфраструктуре потоков приложения.
	Самой большой проблемой является отсутствие встроенного механизма, позволяющего узнать о завершении операции и получить
возвращаемое значение.  Все потоки в пуле потоков являются фоновыми. В случае завершения работы всех приоритетных потоков в 
процессе работа всех фоновых потоков тоже останавливается. Сделать поток из пула приоритетным не удастся.
Нельзя изменять приоритет или имя находящего в пуле потока. Потоки в пуле подходят для выполнения только коротких задач. Если 
необходимо, чтобы поток функционировал все время (как, например, поток средства проверки орфографии в Word), его следует 
создавать с помощью класса Thread. Нельзя создать поток с фиксированной идентичностью, чтобы можно было прерывать его или 
находить по имени.
	
	Третий способ - задания Task, данный класс описывает отдельную задачу, которая запускается асинхронно в фоновом потоке в 
одном из потоков из пула потоков, но так же ее можно запустить синхронно. 
	Способы создания Task:
	Создать экземпляр Task, передав в качестве параметра делегат Action или лямбда-выражение. А для операций, возвращающие 
значения используется Task<TResult> класс и метод Result, которые позволяет получить итоговое значение.
		Task task = new Task(() => CW("Hello")); и вызвать метод task.Start(); для запуска задания.
		Task<Int32> t = new Task<Int32>(n => Sum((Int32)n), 1000000000); t.Result позволяет получить итоговое значение.
	Использовать статический метод Run, который ставит в очередь заданную работу для запуска в пуле потоков
		Task task = Task.Run(() => CW("Hello"));
	Фабрика заданий TaskFactory используется для создания группы заданий, а TaskFactory<TResult> если эти задания должны
возвращать некое значение, а метод StartNew сразу запускает задачу.
		Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
	Можно создать и запустить массив задач при помощи Task или двумя другими способами, а метод Task.WaitAll(tasks) позволит 
дождаться выполнение всех задач.
		Task<Int32>[] parent = new Task<Int32>[](() => {много Task}
	Существует способ узнать о завершении задания и запустить следующе при помощи метода ContinueWith, чтобы избежать блокировки
потоков:
		Task<Int32> t = Task.Run(() => Sum(CancellationToken.None, 10000)); 
		Task cwt = t.ContinueWith(task => Console.WriteLine("The sum is: " + task.Result));
	
	t.Wait() - метод позволяет дождаться завершения задания и после этого получить результат его выполнения, даже если все 
foreground потоки завершили свое выполнение - они будут ждать и приложение не закроется.
	t.Result - получаем результат выполнения, возвращаемого вычислительной операцией.
	Метод WaitAll позволяет ожидать завершения всех объектов Task. Метод возвращает значение true после завершения всех объектов
и значение false, если истекает время ожидания, а так же блокирует вызывающий поток до завершения всех объектов Task в массиве.
	t.ContinueWith - метод,который, создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи
Task. Во внутренней реализации объект Task содержит коллекцию ContinueWith. Это дает возможность несколько раз вызвать метод
ContinueWith при помощи единственного объекта Task. Когда это задание завершится, все задания из коллекции ContinueWith окажутся в
очереди в пуле потоков.
	Если вычислительное задание генерирует необработанное исключение, оно поглощается и сохраняется в коллекции, а потоку пула
разрешается вернуться в пул. Затем при вызове метода Wait или свойства Result эти члены вбросят исключение AggregateException.
	Для написания масштабируемого программного обеспечения следует избегать блокировки потоков. Вызов метода Wait или запрос
свойства Result при незавершенном задании приведет, скорее всего, к появлению в пуле нового потока, что увеличит расход ресурсов и
отрицательно скажется на расширяемости. 
	
		Концепция асинхронности, TAP. Асинхронные методы. Какие операции лучше выполнять синхронно, а какие асинхронно.
	Во что разворачивается компилятором конструкция await? (CPU bound vs IO bound)
	Асинхронность подразумевает выполнение операции без ожидания ее завершения и без блокировки вызывающего потока, благодаря
чему можно приступить к выполнению другой задачи.
	TAP (Task-based Asynchronous Pattern) — тот самый async/await (если говорить строго, то эти слова появились уже после
появления подхода и типов Task и Task<TResult>, но async/await значительно улучшил эту концАепцию)
	Асинхронные методы
	Асинхронные методы - это метод помеченый модификатором async, который означает, что в этом методе можно использовать 
инструкцию await, которое позволяет обойтись без блокировки вызывающего потока, когда элемент управления достигает выражения 
await, а затем продолжить выполнение кода, когда задача завершается, но если ожидающая задача не завершена, то ход выполнения 
метода с ключевым словом await приостанавливается до завершения ожидаемой задачи. После завершения задачи можно возобновить 
выполнение в методе.  Оператор await заставляет компилятор сгенерировать код, который запрашивает свойство Result объекта 
Task<TResult> и присваивает результат локальной переменной, или выдает исключение в случае ошибки, а затем выполняется 
оставшаяся часть кода. Асинхронный метод обычно имеет тип возвращаемого значения Task<TResult>, Task, IAsyncEnumerable<T> 
или void, который в основном используется для определения обработчиков событий, где требуется возвращать тип void, а также 
вызывающий объект метода не может перехватывать исключения, которые выдает этот метод.
	Асинхронный метод не может объявлять параметры out, ref, или in, но может вызывать методы, имеющие такие параметры.
	Когда нельзя использовать await:
	Оператор await можно использовать почти в любом месте метода, помеченного ключевым словом async.
	Оператор await может встречаться внутри блока try, но не внутри блоков catch или finally, соответственно всегда можно 
поставить не внутри блока catch, а после него, для чего следует либо воспользоваться предложением return, либо завести 
булевскую переменную, в которой запомнить, возбуждала ли исходная операция исключение. 
	Во что разворачивается компилятором конструкция await?
	Конструкция async/await разворачивается компилятором в конечный автомат. В конечном автомате переменные вашего метода 
становятся полями, чем достигается возможность запоминать состояние работы метода и продолжать его после ожидания завершения 
длительной операции.
	Асинхронный метод обладает следующими признаками: В заголовке метода используется модификатор async, метод содержит одно или
несколько выражений await. В качестве возвращаемого типа используется один из следующих: void, Task, Task<T> или ValueTask<T>.
Для приличия соблюдать конвенцию о суффиксе Async и желательно добавлять перегрузку с CancellationToken.
	Асинхронная функция не может иметь параметры out, ref или in.
	Оператор await не может использоваться в блоке catch, finally или unsafe.
	Объект должен выполнять определенные условия, чтобы к нему можно было применить await: тип должен иметь public или internal 
метод GetAwaiter() - метод возвращает объект ожидания; Должен реализовать интерфейс INotifyCompletion, с методом 
void OnCompleted(Action continuation); Должен иметь экземплярные свойство bool IsCompleted.
	Какие операции лучше выполнять синхронно, а какие асинхронно.
	Используйте async /await только для тех мест, которые могут длиться «долго»
	Создание Task и других структур для управления асинхронными операциями добавляет некоторые накладные расходы. Если ваша
операция действительно продолжительна, например выполнение IO запроса, тогда эти расходы в основном не будут заметны. А в том 
случае, если ваша операция коротка или займёт несколько циклов процессора, тогда возможно будет лучше выполнять эту операцию 
синхронно. В целом, команда, работавшая над .NET Framework, проделала неплохую работу по выбору функциональсти, которая должна
быть асинхронной. Так, если метод фреймворка заканчивается на Async и возвращает задачу, тогда, скорее всего вы должны
использовать его асинхронно. К числу таких длительных операций можно отнести:
	• сетевые запросы;
	• доступ к диску;
	• продолжительные задержки.
	Предпочитайте async/await вместо Task
	Написание асинхронного кода, используя async/await, намного упрощает и сам процесс создания кода, и его чтение, нежели 
использование задач Task. Task строит цепочку продолжений, которая увеличивается в соответствии с количеством задач, 
связанных последовательно, и состояние системы управляется через замыкания, найденные компилятором. Async/await строит машину
состояний, которая не использует дополнительных ресурсов при добавлении новых шагов. В большинстве сценариев async/await будет
использовать меньше ресурсов и выполняться быстрее, чем задачи Task.

	Вам нужно выкопать во дворе бассейн.
	Вы взяли лопату и копаете. Это однопоточная работа
	Вы пригласили друга Васю и копаете вместе, периодически задевая друг-друга лопатами. Это многопоточная работа
	Пока вы копаете бассейн, Вася копает канаву под водопровод. Никто никому не мешает. Это распараллеливание
	Вы пригласили бригаду землекопов, а сами с Васей пошли пить пиво. Когда бригада все сделает, к вам придут за деньгами. Это асинхронная работа.
	Количество лопат в хозяйстве - это количество ядер в системе

	CPU-bound и IO-Bound операции
	CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне 
текущей железки. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов 
обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число 
вычислительных устройств) бессмысленно поскольку это приведет к падению общей эффективности вычислений. ОС-ке придется 
переключать несколько доступных ядер для обслуживания сотен потоков. А этот процесс не является дешевым.
	
		Контекст синхронизации. ConfigureAwait(false) vs ConfigureAwait(true) vs без использования ConfigureAwait.
	Контекст синхронизации (SynchronizationContext) - это тип, который позволяет возобновить выполнение метода в конкретном 
потоке. Идея в том, когда код исполняется в каком-то потоке, мы можем получить текущий контекст синхронизации и сохранить его. 
Впоследствии этот контекст можно использовать для того, чтобы продолжить исполнение кода в том потоке, в котором оно было 
начато. В классе SynchronizationContext есть важный метод Post, который гарантирует, что переданный делегат будет исполняться 
в правильном контексте.
Важно! В момент приостановки метода при встрече оператора await текущий контекст SynchronizationContext сохраняется.
Далее, когда метод возобновляется, компилятор вставляет вызов Post, чтобы исполнение возобновилось в запомненном контексте.

	ConfigureAwait
	ConfigureAwait - это метод, который принадлежит классу Task и позволяет указать, необходимо ли нам выполнять продолжение 
в том же контексте, где была вызвана асинхронная операция. 
	По умолчанию, без использования этого метода, контекст запоминается и продолжение ведется в нем с помощью метода Post, но и 
является дорогой операцией. Поэтому, если производительность на 1-м месте, и нам необязательно продолжать операцию в том же 
контексте, то можно указать ConfigureAwait(false). 
	ConfigureAwait(false) - это означает, что неважно, в каком контексте продолжится выполнение.
	ConfigureAwait(true) - задаёт поведение по-умолчанию и не несёт в себе никакого смысла.

		Что такое CancellationToken? Отмена асинхронных операций.	
	Отмена асинхронных операций связывается с типом CancellationToken. По соглашению всякий метод, поддерживающий отмену, 
должен иметь перегруженный вариант, в котором за обычными параметрами следует параметр типа CancellationToken
При вызове метода ThrowIfCancellationRequested отмененного объекта CancellationToken возбуждается исключение типа 
OperationCanceledException. Библиотека Task Parallel Library знает, что такое исключение представляет отмену, а не ошибку, и 
обрабатывает его соответственно. Например, в классе Task имеется свойство IsCanceled, которое автоматически принимает значение 
true, если при выполнении async-метода произошло исключение OperationCanceledException.
Удобной особенностью подхода к отмене, основанного на маркерах CancellationToken, является тот факт, что один и тот же маркер 
можно распространить на столько частей асинхронной операции, сколько необходимо, – достаточно просто передать его всем частям.
Неважно, работают они параллельно или последовательно, идет ли речь о медленном вычислении или удаленной операции, – один 
маркер отменяет всё.

		Виды синхронизации потоков. lock, Monitor
	lock - оператор lock определяет блок кода, для блокировки которого используется объект-заглушка, когда выполнение доходит до
оператора lock, объект блокируется и весь код становится недоступным для других потоков до завершения работы текущего потока.
Остальные потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода, а после окончания работы
блока кода, объект освобождается и становится доступным для других потоков.
	Не используйте один и тот же экземпляр объекта блокировки для разных общих ресурсов: это может привести к взаимоблокировке или
состязанию при блокировке.
	Удерживайте блокировку в течение максимально короткого времени, чтобы сократить число конфликтов при блокировке.
	lock это упрощенный синтаксис класса Monitor.
	Monitor - метод Monitor.Enter принимает два параметра: объект блокировки и значение типа bool, которое указывает на результат
блокировки, если он равен true, то блокировка успешно выполнена. Рекомендуется поместить этот код в try блок, а вызов Exit метода, 
в котором происходит освобождение объекта, поместить в finally блок. Это гарантирует снятие блокировки даже при возникновении 
исключения, если блокировка осуществлена успешно он становится доступным для других потоков. Но есть опасность, что в случае
ошибки следующий поток может работать с поврежденными данными.
	lock и monitor - одно и то же. lock - синтаксический сахар - вызывает методы Monitor.Enter и Monitor.Exit. lock работает на
порядки быстрее чем Mutex, но к нему невозможно получить доступ из другого процесса, а вот к Mutex - можно. Класс Monitor обладает
одним важным преимуществом по сравнению с оператором lock в C#: он позволяет добавлять значение тайм-аута для ожидания получения
блокировки. Таким образом, вместо того, чтобы ожидать блокировку до бесконечности, можно вызвать метод TryEnter и передать в нем
значение тайм-аута, указывающее, сколько максимум времени должно ожидаться получение блокировки.

		Конструкции режима ядра:
	Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в
одном экземпляре. Они работают намного медленнее конструкций пользовательского режима, так как требуют координации со стороны
операционной системы. К примитивным конструкциям синхронизации потоков в режиме ядра относятся события (events) и семафоры
(semaphores). На их основе строятся более сложные конструкции аналогичного назначения, например Mutex
	В пространстве имен System.Threading существует абстрактный базовый класс WaitHandle. 
	Вот как выглядит иерархия этих классов:
		WaitHandle
			EventWaitHandle
				AutoResetEvent
				ManualResetEvent
			Semaphore
			Mutex
			
	Mutex — это примитив синхронизации, является производными от класса WaitHandle, предоставляющий монопольный доступ к общему
ресурсу только одному потоку. Если поток получает мьютекс, второй поток, который хочет получить этот мьютекс, приостанавливается
до тех пор, пока первый поток не выпустит мьютекс т.е к критической секции может получить доступ только один поток.
	Класс Mutex обеспечивает идентификацию потоков, поэтому мьютекс может быть освобожден только потоком, который его приобрел. В
отличии от Semaphore у которого нет идентификации потоков. Мьютекс также можно передавать через границы домена приложения.
	К Mutex можно получить доступ из другого процесса в отличии lock, но работает он намного медленнее.
	Сначала создаем объект Mutex: 	Mutex mutexObj = new Mutex()
	Основную работу по синхронизации выполняют методы WaitOne() и ReleaseMutex(). 
	Метод mutexObj.WaitOne() приостанавливает выполнение потока до тех пор, пока не будет получен мьютекс mutexObj. Изначально
мьютекс свободен, поэтому его получает один из потоков, а после выполнения всех действий, поток освобождает его с помощью метода
mutexObj.ReleaseMutex(). Далее мьютекс получает следующий ожидающий поток. Таким образом, когда выполнение дойдет до вызова
mutexObj.WaitOne(), поток будет ожидать, пока не освободится мьютекс. И после его получения продолжит выполнять свою работу.

	Semaphore - работает подобно Mutex, но позволяет определить несколько потоков, чтобы получить доступ к критической секции, а в 
конструкторе указывается количество потоков. Количество семафоров уменьшается каждый раз, когда поток входит в семафор, и
увеличивается, когда поток освобождает семафор. Если счетчик равен нулю, последующие запросы блокируются до тех пор, пока другие
потоки не отпустят семафор.
	Семафоры бывают двух типов: локальные и именованные системные семафоры. 
	Если создается объект Semaphore, принимающии имя в конструкторе, он связывается с семафором операционной системы с таким именем
Именованные системные семафоры видны всей операционной системе и могут использоваться для синхронизации действий процессов. Можно
создать несколько Semaphore объектов, представляющих один и тот же именованный системный семафор, и использовать OpenExisting
метод для открытия существующего именованного системного семафора.
	Локальный семафор существует только внутри процесса. Его может использовать любой поток в вашем процессе, имеющий ссылку на
локальный объект Semaphore. Каждый Semaphore объект является отдельным локальным семафором.
	Для работы с потоками класс Semaphore имеет два основных метода:
	WaitOne(): ожидает получения свободного места в семафоре
	Release(): освобождает место в семафоре
	Семафоры (semaphores) также представляют собой обычные переменные типа Int32, управляемые ядром. Ожидающий семафора поток
блокируется при значении 0 и освобождается при значениях больше 0. При снятии блокировки с ожидающего семафора потока ядро
автоматически вычитает единицу из счетчика. С семафорами связано максимальное значение типа Int32, которое ни при каких 
обстоятельствах не могут превысить текущие показания счетчика иначе будет вызвано исключение SemaphoreFullException.
	The SemaphoreSlim class represents a lightweight, fast semaphore that can be used for waiting within a single process when 
wait times are expected to be very short. This would mean that a SemaphoreSlim could not be used for cross-process synchronization

	События (events) представляют собой переменные типа Boolean, находящиеся под управлением ядра. Ожидающий события поток
блокируется, если оно имеет значение false, и освобождается в случае значения true. 
	EventWaitHandle представляет событие синхронизации потока и может находиться в сигнальном или несигнальном состоянии. Если
состояние события несигнальное, поток, который вызывает перегрузку события WaitOne, будет заблокирован, пока состояние события не
станет сигнальным методом Set(), который задает сигнальное состояние события. Поведение EventWaitHandle после получения
сигнала зависит от его режима сброса:
- EventResetMode.AutoReset, автоматически сбрасывается после освобождения одного потока в состоянии ожидания. Это похоже на 
турникет, пропускающий только один поток каждый раз, когда он переводится в сигнальное состояние. Такое поведение характерно для 
класса AutoResetEvent, наследующего EventWaitHandle.
- EventResetMode.ManualReset, находится в сигнальном состоянии, пока не будет вызван его метод Reset. Это как ворота, которые 
закрыты до получения сигнала и остающиеся затем открытыми, пока кто-нибудь их не закроет. Такое поведение характерно для класса 
ManualResetEvent, наследующего EventWaitHandle. 
- Класс ManualResetEventSlim является упрощенной альтернативой ManualResetEvent.
	
	AutoResetEvent - этот класс представляет событие синхронизации потоков, который позволяет при получении сигнала переключить
данный объект-событие из сигнального в несигнальное состояние. Для этого создаем переменную типа AutoResetEvent. Передавая в
конструктор значение true, указывая, что создаваемый объект изначально будет в сигнальном состоянии.
	Когда начинает работать поток, то первым делом срабатывает вызов waitHandler.WaitOne(). Метод WaitOne указывает, что главный
поток переводится в состояние ожидания. После выполнения работы вызывается метод waitHandler.Set, который уведомляет все ожидающие
потоки, что объект waitHandler снова находится в сигнальном состоянии, теперь следующий ожидающий поток, переводит waitHandler в
несигнальное состояние и выполняет свой код. А остальные потоки снова ожидают.
	ManualResetEvent - основное отличие от AutoResetEvent заключается в том, что при установке одного set работу начинают от
одного и более потоков, а не один, и для того что бы перевести поток в не сигнальное состояние используется Reset().
	Если у нас в программе используются несколько объектов AutoResetEvent, то мы можем использовать для отслеживания состояния
этих объектов статические методы WaitAll и WaitAny, которые в качестве параметра принимают массив объектов класса WaitHandle - 
базового класса для AutoResetEvent.	
	Итак, что происходит при выполнении программы:
	1. AutoResetEvent waitHandler = new AutoResetEvent(true) - подал сигнал
	2. Первый поток в очереди к нему 
	3. waitHandler.WaitOne(); - поймал сигнал, и погасил текущий поток - главный т.е ввёл остальные потоки в режим ожидания.
	4. Выполнился блок кода
	5. waitHandler.Set(); - отдал-включил сигнал. - включил главный поток(вывел главный поток из режима ожидания)
	6. Второй поток в очереди: пункты 3,4,5 - поймал сигнал, погасил, выполнился, отдал-включил
	7. И так далее

		Deadlock, livelock, starvation.
	Deadlock - взаимоблокировка (deadlock) называется ситуация, когда как минимум два потока останавливаются и ожидают друг от
друга снятия блокировки. Поскольку оба потока ожидают друг от друга выполнения соответствующего действия, получается, что они
блокируют друг друга, из-за чего их ожидание может длиться бесконечно.
	livelock - если поток, использующий в данный момент конструкцию, не освободит ее, ожидающий конструкции поток может оказаться
заблокированным навсегда. В этом случае в пользовательском режиме поток бесконечно исполняется процессором; этот вариант
блокировки называется активной (живой) блокировкой (livelock) или зависанием.
	starvation - во время включения потока Б эксклюзивный ресурс всегда занят другим потоком, из-за чего поток Б прекращает свою
работу не может выполнить свои операции.

		Подробнее об операторе foreach
	Цикл foreach является универсальным инструментом для обработки коллекций/последовательностей. Способ его преобразования
компилятором зависит от типа перебираемой коллекции (обобщенная/необобщенная) и представляет собой простой цикл while, в котором
вызываем метод enumerator.MoveNext(). Пример обхода необобщенной коллекции выглядит следующим образом (листинг 4.5).
Объекты должны наследоваться от IEnumerable и реализовывать GetEnumerator
public static void ForEachIEnumerable(IEnumerable sequence)
{
	// foreach(var e in sequence) {Console.WriteLine(e);}
	IEnumerator enumerator = sequence.GetEnumerator();
	object current = null;	
	try
	{
		while (enumerator.MoveNext())
		{
			current = enumerator.Current;
			Console.WriteLine(current);
		}
	}
	finally
	{
		IDisposable disposable = enumerator as IDisposable;
		if (disposable != null)
		{
			disposable.Dispose();
		}
	}
}	
	
		Классы коллекций для параллельного доступа. Parallel LINQ. Класс Interlocked, атомарные операции
	В FCL существует четыре безопасных в отношении потоков класса коллекций, принадлежащих пространству имен 
System.Collections.Concurrent: 
	ConcurrentQueue, ConcurrentStack, ConcurrentDictionary, ConcurrentBag и BlockingCollection
	Они предоставляют поточно-ориентированные реализации интерфейсов коллекции. Классы concurrent коллекции можно безопасно
использовать в многопоточных приложениях, где возможен одновременный доступ к коллекции со стороны двух или больше параллельно 
исполняемых потоков.
	ConcurrentQueue<T> - этот класс коллекции реализован со свободным от блокировок алгоритмом и использует 32 массива, которые
внутренне скомбинированы в связный список. Для доступа к элементам очереди применяются методы Enqueue(), TryDequeue()
и TryPeek(). Имена этих методов очень похожи на уже известные методы Queue<T>, но с добавлением префикса Try к тем из них, 
которые могут дать сбой.
	ConcurrentStack<T> - очень похож на ConcurrentQueue<T>, но с другими методами доступа к элементам. Внутри этот класс 
использует связный список для хранения элементов.
	ConcurrentBag<T> - Этот класс не определяет никакого порядка для добавления или извлечения элементов. Он реализует концепцию
отображения потоков на используемые внутренне массивы, и старается избежать блокировок. Для доступа к элементам применяются
методы Add(), TryPeek() и TryTake().
	ConcurrentDictionary<TKey, TValue> - безопасная в отношении потоков коллекция ключей и значений. Для доступа к членам в
неблокирующем режиме служат методы TryAdd(), TryGetValue(), TryRemove() и TryUpdate(). 
	BlockingCollection<T> - коллекция, которая осуществляет блокировку и ожидает, пока не появится возможность выполнить
действие по добавлению или извлечению элемента. BlockingCollection<T> предлагает интерфейс для добавления и извлечения элементов
методами Add() и Take(). Эти методы блокируют поток и затем ожидают, пока не появится возможность выполнить задачу.

	Parallel LINQ 
	По умолчанию все элементы коллекции в LINQ обрабатываются последовательно, но начиная с .NET 4.0 в пространство имен
System.Linq был добавлен класс ParallelEnumerable, который инкапсулирует функциональность PLINQ (Parallel LINQ) и позволяет
выполнять обращения к коллекции в параллельном режиме. При обработке коллекции PLINQ использует возможности всех процессоров в 
системе. Источник данных разделяется на сегменты, и каждый сегмент обрабатывается в отдельном потоке. Это позволяет произвести 
запрос на многоядерных машинах намного быстрее. Поэтому смысл применения PLINQ имеется преимущественно на больших коллекциях или
при сложных операциях, где действительно выгода от распараллеливания запросов может перекрыть возникающие при этом издержки.
	Атомарная операция — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть
частично выполнена и частично не выполнена. 
	Класс Interlocked позволяет создавать простые операторы для атомарных операций с переменными. Например, операция i++ не
является безопасной в отношении потоков. Она подразумевает извлечение значения из памяти, увеличение этого значения на 1 и его
обратное сохранение в памяти. Такие операции могут прерываться планировщиком потоков. Класс Interlocked предоставляет методы,
позволяющие выполнять инкремент, декремент, обмен и считывание значений в безопасной к потокам манере.
	Применение класса Interlocked является гораздо более быстрым подходом по сравнению с остальными приемами по обеспечению
синхронизации. Однако пользоваться им можно для устранения только простых последствий синхронизации. Например, вместо того чтобы
применять оператор lock для блокирования доступа к переменной при установке для нее нового значения в случае, если ее текущим
значением является null, можно воспользоваться классом Interlocked, что гораздо быстрее: Decrement; Exchange; Increment;
CompareExchange;	

		Класс Parallel. Parallel.Invoke, Parallel.For и Parallel.ForEach
	Класс Parallel также является частью TPL и предназначен для упрощения параллельного выполнения кода. Parallel имеет ряд
методов, которые позволяют распараллеливать задачу. Одним из методов, позволяющих параллельное выполнение задач, является метод 
Invoke. Метод Parallel.Invoke в качестве параметра принимает массив объектов Action, то есть мы можем передать в данный метод
набор методов, которые будут вызываться при его выполнении. Количество методов может быть различным, но в данном случае мы
определяем выполнение трех методов. Опять же как и в случае с классом Task мы можем передать либо название метода, либо
лямбда-выражение. И таким образом, при наличии нескольких ядер на целевой машине данные методы будут выполняться параллельно на
различных ядрах.
	Метод Parallel.For позволяет выполнять итерации цикла параллельно. Он имеет следующее определение: For(int, int, Action<int>)
Первый параметр метода задает начальный индекс элемента в цикле, а второй параметр - конечный индекс. Третий параметр - делегат
Action - указывает на метод, который будет выполняться один раз за итерацию.
	Метод Parallel.ForEach осуществляет итерацию по коллекции, реализующей интерфейс IEnumerable, подобно циклу foreach, только
осуществляет параллельное выполнение перебора. Он имеет следующее определение:
	ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source,Action<TSource> body) где первый параметр представляет 
перебираемую коллекцию, а второй параметр - делегат, выполняющийся один раз за итерацию для каждого перебираемого элемента 
коллекции. На выходе метод возвращает структуру ParallelLoopResult, которая содержит информацию о выполнении цикла.
	метод Break позволяет выйти из цикла.
	Методы Parallel.ForEach и Parallel.For возвращают объект ParallelLoopResult, наиболее значимыми свойствами которого являются
два следующих:
	IsCompleted: определяет, завершилось ли полное выполнение параллельного цикла
	LowestBreakIteration: возвращает индекс, на котором произошло прерывание работы цикла

		Почему при CPU Bound лучше не использовать async-await, но можно использовать Parallel.For(), Task.Run()?
	Ответ на этот вопрос зависит от того, какие ресурсы наиболее интенсивно используются:
	 - если CPU, то лучше использовать Task.Run(), Parallel.For() и т. д.;
	 - а если I/O (диск, сеть, внешние устройства), то async/await.
	Parallel.For(), Task.Run() и схожие с ними методы берут свободный поток для каждой запускаемой задачи. А т.к число 
одновременно выполняемых потоков конечно, то в случае с активным использованием I/O операций, в какой-то момент, новые задачи 
будут ждать завершения уже запущенных. При этом CPU практически не нагружен и простаивает. Т. е. не смотря на наличие
ресурсов, часть I/O операций будет отложена.
Указанная выше проблема не актуальна в случае потоков, интенсивно использующих CPU. В этой ситуации процессор будет постоянно 
загружен работой и простоя не будет.
	Пара async/await работает по другому. По своей сути это конечный автомат, который позволяет во время ожидания использовать
тот же самый поток для следующей в списке задачи. Таким образом, используя небольшое число потоков можно инициировать большее
число I/O операций и ожидать их завершения. При этом свободные потоки смогут продолжать обслуживать другие задачи приложения.

		Дилеммы разработчиков:
		Базовый класс или интерфейс?
	Любой тип может наследовать только одну реализацию, но если нужно реализовать подобие множественного наследования или 
слабосвязанное, гибкое приложение, например, DI контейнер или MOCK-объект, а так же значимые типы не могут наследоваться от 
произвольного базового класса, то в этом случае нужно определять интерфейс.
	Иногда проще определить новый тип, производный от базового, чем создать интерфейс. Базовый тип может предоставлять массу
функций, и в производном типе потребуется внести лишь незначительные изменения, чтобы изменить его поведение. При создании
интерфейса в новом типе придется реализовывать все члены.
	Управление версиями. 
	Когда вы добавляете метод к базовому типу, производный тип наследует стандартную реализацию этого метода без всяких затрат. 
Пользовательский исходный код даже не нужно перекомпилировать. Добавление нового члена к интерфейсу требует изменения 
пользовательского исходного кода и его перекомпиляции. Для интерфейса придется менять и добавлять реализацию в каждого наследника,
а следовательно, и перекомпилировать. Особенно сильно это влияет, если меняется интерфейс в библиотеке, которая используется в
различных проектах. Для базового класса — такой проблемы нет. Наследники просто принимают изменения базового типа и их даже не
нужно перекомпилировать.

		Абстрактный класс или интерфейс?
	Рассказать про абстрактный класс. Когда следует использовать абстрактные классы:
	Если надо определить общий функционал для родственных объектов, чтобы все производные классы на всех уровнях наследования
имели некоторую общую реализацию. 
	При использовании абстрактных классов, если мы захотим изменить базовый функционал во всех наследниках, то достаточно поменять
его в абстрактном базовом классе. А в случае с интерфейсом, придется вносить изменения и также во всех классах, которые данный
интерфейс реализуют.
	Абстрактные классы можно комбинировать вместе c интерфейсами т.к абстрактный класс может наследоваться от интерфейсов.
	Когда следует использовать интерфейсы:
	Если нам надо определить функционал для группы разрозненных объектов, которые могут быть никак не связаны между собой.
	Если мы проектируем небольшой функциональный тип.
	В новой версии С# можно добавить реализацию методам и свойствам по умолчанию, но из-за того, что в интерфейс не поддерживает
экземплярные поля, а только статические поля и константы, то мы не сможем управлять состоянием объекта по сравнению с классами.
Но преимуществом является, то что это позволяет добавить совместимость с такими языками как Java, где уже есть подобная реализация,
а также сохраняет обратную совместимость на уровне сборки т.е если мы добавим в интерфейс новый метод, то нужно будет его реализовать,
но если мы добавим реализацию по умолчанию, то этот интерфейсный метод не обязательно будет реализовывать.
	Допустим, у нас есть система транспортных средств: легковой автомобиль, автобус, трамвай, поезд. Поскольку данные объекты 
являются родственными, мы можем выделить у них общие признаки, то в данном случае можно использовать абстрактный класс, например,
Vehicle, который определяет абстрактный метод перемещения Move(), а классы-наследники его реализуют, но если объекты малосвязанные
между собой, то для определения общего для всех них функционала лучше определить интерфейс.
	Говоря об использовании абстрактных классов и интерфейсов можно привести еще такую аналогию, как состояние и действие. 
Как правило, абстрактные классы фокусируются на общем состоянии классов-наследников. В то время как интерфейсы строятся вокруг
какого-либо общего действия.

		Статический класс или singleton
	Singleton является более гибким по сравнению со статическим классом по скольку является объектом соответственно его можно
передавать как параметр, реализовывать интерфейсы, наследоваться, сериализовать/десериализовать а также можно управлять временем 
жизни. Статический класс используется для логической группировки схожих методов, констант, полей и свойств, а также может создавать
статические методы расширения

		Событие или делегат
	События — это члены типа, который позволяет типу регистрировать и отменять регистрацию на событие, и поле-делегат для 
управления набором зарегистрированных методов и получения уведомлений на которые он подписался.
	Событие не может возвращать значения и вызывается только из типа в котором было объявлено, можно объявить в интерфейсе, а так же 
всегда объявляется как public поле, а не свойство.
	Делегат (delegates) - функциями обратного вызова, которая обеспечивает безопасность типов при выполнении обратного вызова
методов, а так же позволяют последовательно вызывать несколько методов.
	Событие не может возвращать значения и вызывается только из типа в котором было объявлено, можно объявить в интерфейсе, а так же 
всегда объявляется как public поле, а не свойство используются для уведомления об изменениях в объекте. Делегат - делегирует свою 
работу внешнему коду, вызывая методы других объектов, и может быть параметром в методе или возвращаемым значением.

		Лямбда или делегат
	Лямбды - предоставляют более удобный синтаксис для использования делегатов или деревьев выражений. Они объявляют список параметров
и тело метода, но не имеют собственного официального удостоверения, если они не назначены делегату. В отличие от делегатов их можно
напрямую назначать в правой части при регистрации событий, а также в различных предложениях и методах LINQ.

		Какая разница между методами Finalize и Dispose. Чем плох деструктор/финализатор и когда использовать IDisposable?
	Финализатор используется для того, чтобы явно освободить неуправляемые ресурсы перед тем, как он будет очищен Garbage Collector’ом.
К неуправляемым ресурсам можно отнести соединения с базами данных, сетевые соединения, файлы, а также прочие элементы, которые мы не
являются частью .Net, но используются в нашем коде. В общем виде финализации позволяет объекту освободить ресурсы, которые он использует
Декларирование финализатора похоже на декларирование конструктора, но перед названием необходимо добавить знак «тильда».
	Одним из недостатков использования финализаторов является то, что мы не знаем точно, когда он будет вызван. То есть мы знаем, что
финализатор будет вызван, когда Garbage Collector будет удалять наш объект из памяти, но опять-таки, мы не можем точно сказать, когда
это произойдёт. Кроме того, при финализации двух связанных объектов порядок вызова деструкторов не гарантируется. Соответственно если
мы работаем с файлом, то ожидание пока в системе не будет вызван GC, нам не подходит.
	Чтобы очистить неуправляемы ресурсы быстрее нужно построить для этого объект IDisposable-обёртку или если в классе уже есть
управляемые (IDisposable) ресурсы. Интерфейс IDisposable содержит декларацию только одного метода: Dispose, реализуя этот метод, вы
должны выполнить одно важное обязательство: даже многократный вызов Dispose должен происходить без ошибок. В рамках данного метода можно
освободить неуправляемые ресурсы немедленно и это метод может быть вызван каждым пользователем вашего класса. В C# предоставлен 
специальный синтаксис для решение данной задачи – использование ключевого слова using в контексте объектов, которые имплементируют 
интерфейс IDisposable. Ключевое слово using в этом случае гарантирует, что после использования данного объекта будет вызван метод Dispose,
а в случае исключений они будут обработаны соответствующим образом. Использование using автоматически добавляет к коду инструкции
try/finally. Если программист хотел бы расширить этот синтаксис и использовать блок catch, то связку try/catch/finally необходимо будет
написать самостоятельно.
	Разница между использованием финализаторов и использованием интерфейса IDisposable. Финализаторы вызываются Garbage Collector’ом и
у нас нет особых рычагов влияния, когда это произойдет, с другой стороны, если объект реализует IDisposable, то после использования объекта,
мы можем явно освободить ресурсы из кода, вызывая метод Dispose, когда объект, по нашему мнению, уже не нужен.

		Сборщик мусора. Что это. Триггеры вызова. Как работает. Что влияет на его скорость работы. Количество поколений. Что такое LOH. 
Как определить производительность GC.
	Garbage Collector - это механизм который управляет выделением и освобождением памяти для приложения. Очистка памяти – это
ресурсоёмкий процесс, а также перед уборкой мусора приостанавливается работа всех потоков, связанных с приложением он запускается, когда
в куче отсутствует место для создания нового объекта т.е превышение порога памяти выделенной для первого поколения или операционная система
сигнализирует отсутствие свободного места в памяти, а также завершение работы CLR, выгрузки домена приложения или вызов статического метода
Collect объекта System.GC. 
	Во время работы уборщика мусора он проверяет счётчик ссылок на другие объекты, а также наличие наличие ссылки на корневой элемент, 
который расположен в callStack-e, а также маркируют объекты у которых есть ссылки на корневой элемент. В результате мы имеем набор 
маркированных не маркированных объектов. Не маркированные объекты процессы уборки мусора не переживут, а с маркированными объектами будет 
произведена дефрагментация т.е на место не маркированных объектов будут перемещены маркированным объекты. В итоге объекты пережившие уборку
мусора переносятся из поколения ноль в первое, всего поколений 2. Это количество поколений подобрано экспериментальным путем и является 
наиболее оптимальным. Для ускорения работы GC, при первой попытке очистки – проверяются объекты только «поколения 0». Если был освобожден
достаточный объем памяти, то работа GC прекращается. В противном случае происходит очистка следующих поколений.
	Так же существуют большие объекты, размер которых превышает 85к байт и размещаются они в Large Object Heap(LOH). Её особенностью
является то, что она не дефрагментируется т.к. на их перемещение в памяти потребуется слишком много процессорного времени, а также эти 
объекты принадлежат поколению 2 соответственно очистка этих объектов достаточно крайне редка.
	Для мониторинг работы уборщика мусора, существуют следующие статические методы класса GC вызываются для выяснения числа операций уборки
мусора в конкретном поколении или для объема памяти, занятого в данный момент объектами в управляемой куче.
	Int32 CollectionCount(Int32 generation);
	Int64 GetTotalMemory(Boolean forceFullCollection);

		Сложность О большое. Сравнение сложности, Пространственная сложность
	Сложность О большое является одним из самых фундаментальных инструментов анализа сложности алгоритма. Например функция O (n²)
описывает, что n - представляет размер входных данных, а функция внутри скобок дает представление насколько сложен алгоритм.
	О большое (O()) описывает верхнюю границу сложности.
	Малое O (o()) описывает верхнюю границу, исключая точную оценку.
	Омега (Ω ()) описывает нижнюю границу сложности.
	Тета (Θ ()) описывает точную оценку сложности.
	Вообще, когда мы говорим о Большом O, мы на самом деле имеем в виду Тета (Θ Theta).
	Порядок сложностей: O(1), O(log(n)), Полиномы, O(√n) поскольку можно представить полиномом со степенью 0.5, многочлены O(n⁴), O(n⁵),
Факториалы, Умножение
	Пространственная сложность связана с тем, сколько памяти будет использовать программа, и, следовательно, также является
важным фактором для анализа.

		Структуры данных: Массивы; Отличие массива от List. Linked List, Doubly linked lists, CircularLinkedList, 
CircularDoublyLinkedList; Stack, Queue, Dequeue, PriorityQueue; Массив, List; Binary Heap, Binary Search Tree, АВЛ-дерева; 
Обходы дерева, Балансировка узлов; hashtable, hashset, dictionary

		Виды интерфейсов коллекций. IQueryable vs IEnumerable. IEnumerable, ICollection, IList, List, IDictionary, ISet,
	Concurrent Collections, Immutable Collections. С какими коллекциями можно использовать Linq?
	Общий интерфейс для коллекций - интерфейс ICollection<T> дает возможность изменять коллекцию и узнать ее размер. Он 
наследуется от интерфейса IEnumerable<T>, который указывает,
что тип реализует GetEnumerator. Благодаря чему для него доступна конструкция foreach. С IEnumerable часто используются расширения
из System.Linq. Generic интерфейс используется при возвращении из запросов (например к базе данных или к другим коллекциям).
	IQueryable в отличии от IEnumerable – IQueryable предлагает высокую производительность в случае работы с большим объемом
данных. IQueryable предварительно фильтрует данные по запросу а затем отправляет только отфильтрованные данные клиенту.
	Разница между IQueryable и IEnumerable
Основное отличие между этими интерфейсами в том, что IEnumerable работает со всем массивом данных, а IQueryable с отфильтрованным.
IEnumerable получает все данные на стороне сервера и загружает их в память а затем позволяет сделать фильтрацию по данным из памяти.
Когда делается запрос к базе данных, IQueryable выполняет запрос на серверной стороне и в запросе применяет фильтрацию. 
	Интерфейс IList <T> описывает коллекции с элементами, доступ к которым можно получить по их индексу. Для этого он
добавляет индексатор для получения и записи значения:
	Интерфейс ISet<T> описывает набор уникальных элементов, которые не гарантируют сохранение их порядка в списке.
	IDictionary<TKey, TValue> - это третий интерфейс, расширяющий интерфейс ICollection<T>. В отличие от предыдущих двух,
этот предназначен для хранения пар ключ-значение вместо отдельных значений, т.е. он использует KeyValuePair<TKey, TValue>
в качестве универсального параметра в ICollection<T>.
	Для сортировки ключей доступны две разные реализации (SortedDictionary<TKey, TValue> и SortedList<TKey, TValue>),
каждая из которых имеет свои преимущества и недостатки.
	Queue и Stack - не реализуют ни один из специализированных интерфейсов, полученных из интерфейса ICollection<T>. Класс
Queue<T> реализует принцип FIFO (first in, first out) - первым пришел, первым вышел, а класс Stack<T> похож на класс Queue<T>,
но он реализует принцип LIFO (последний пришел, первый вышел). Единственный элемент, который непосредственно доступен в этой
коллекции, - это тот, который был добавлен совсем недавно.
	Concurrent Collections  они предоставляют поточно-ориентированные реализации интерфейсов коллекции. Классы concurrent
коллекции можно безопасно использовать в многопоточных приложениях.
	Immutable Collections Immutable (неизменяемые) коллекции не включены в библиотеку базовых классов. Чтобы использовать их
в проекте должен быть установлен пакет NuGet System.Collections.Immutable. Вместо использования синхронизирующих блокировок,
как это делают параллельные коллекции, неизменяемые коллекции не могут быть изменены после их создания. Это автоматически
делает их безопасными для использования в многопоточных сценариях.

		Массивы
	Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию. Базовым для всех 
	массивов является абстрактный класс System.Array, производный от System.Object и являются ссылочным типом и
размещаются в управляемой куче, а переменная в приложении содержит не элементы массива, а ссылку на массив.
	Сложность: По индексу O(1), поиск O(n)
	Поддерживаются массивы:
    Одномерные (single-dimension) [] SZ-массивы или векторами - одномерный массив с нулевым начальным индексом;
    Многомерные (multidimension) [,] или больше [,,];
    Нерегулярные (jagged) массивы массивов [][].
	По возможности нужно ограничиваться одномерными массивами с нулевым начальным индексом, которые называют векторами, поскольку
векторы обеспечивают наилучшую производительность, т.к для операций с ними используются команды промежуточного языка (IL).
	Производительность одномерного массива с нулевой нижней границей чем многомерных массивов или массивов с ненулевой нижней 
границей поскольку есть специальные команды для работы с одномерными массивами с нулевой нижней границей, которые позволяют
JIT-компилятору генерировать оптимизированный код. А благодаря тому, что первый индекс равен нулю, отсутствует необходимость
вычислять смещение на каждой итерации.
	У многомерных массивов есть ранг т.е количество измерений. Доступ к элементам осуществляется посредством двух и более индексов
		Double[,] myDoubles = new Double[10, 20]; // Создание двухмерного массива типа Doubles
	Нерегулярные (jagged) массивы — то есть «массивы массивов». Производительность одномерных нерегулярных массивов с нулевым 
начальным индексом такая же, как у обычных векторов. Однако обращение к элементу нерегулярного массива означает обращение к двум
или больше массивам одновременно. Point[][] myPolygons = new Point[3][] // Создание одномерного массива из массивов типа Point
	Чтобы привести массив к другому оба типа массивов должны иметь одинаковую размерность; кроме того, должно иметь место неявное
или явное преобразование из типа элементов исходного массива в целевой тип. 
	Недостатки простого массива являются, если вам нужно неизменное количество объектов, то массив вполне подходит. Но если 
нужно добавить в массив ещё один элемент, то в простом массиве этого сделать невозможно. Или если нужно удалить элемент из 
массива. В простом массиве это так же невозможно. Т.к вы привязаны к одному количеству элементов. 

		Динамический массив List. List vs Array, Count vs Capacity.
	Динамический массив — это массив, который может менять свой размер. В основе List лежит Array, но он имеет два
дополнительных блока данных Count и Capacity. В них хранятся действительный размер простого массива и объём данных, который
может на самом деле храниться в простом массиве.
	Сложность: По индексу O(1), поиск элемента по значению O(n), вставка в конец O(1) и середину O(n) т.к нужно данные сдвигать.
	Недостатки динамических массивов
    Допустим, массив очень велик, а вам нужно часто добавлять и удалять объекты. При этом объекты могут часто копироваться в
другие места, а многие указатели становиться недействительными. Если вам нужно вносить частые изменения в середине динамического
массива, то для этого есть более подходящий тип линейной структуры данных
	Также можно получить утечку памяти дело в том, что при увеличении массива растёт его Capacity, но методы Clear, Remove не
уменьшает размер Capacity соответственно при очистке массива мы не уменьшаем его реальный зарезервированный объём памяти. В 
таком случае лучше использовать присвоение новой ссылки List = new List;
	List<KeyValuePair> 						vs 						Dictionary<T Key, T Value>
	1. Lighter														1. Heavy
	2. Insertion is faster in List									2. Insertion is slower. Has to compute Hash
	3. Searching is slower than Dictionary							3. Searching is faster because of Hash.
	4. This can be serialized to XMLSerializer						4. Can't be serialized. Custom code is required.
	5. Changing the key,value is not possible. Keyvaluepair can 	5. You can change and update dictionary.
be assigned value only during creation. If you want to change 
then remove and add new item in same place.

		Linked List, Двусвязный список, Кольцевой односвязный список, Кольцевой двусвязный список, Преимущества и недостатки.
	Связный список (Linked List) представляет набор связанных узлов, каждый из которых хранит собственно данные и ссылку
на следующий узел.
	Связный список разработан для оптимизированния вставки и удаления. Медленно работает при индексировании и поиске.
	Для хранения данных предназначено свойство Data. 
	Для ссылки на следующий узел определено свойство Next.
Методы:
	AddLast - добавление элемента в конец списка:
		При помощи tail(хвост) - указывает всегда на последний элемент списка. Сложность O(1) 
		Без помощи tail(хвост) - 					Сложность O(n)
	AddFirst - добавление элемента в начало списка.	Сложность О(1)
	Remove - удаление элемента. 					Сложность O(n)
	Contains - для проверки наличия элемента. 		Сложность O(n)
	Clear - удаляет все ссылки;
	IEnumerable - можно реализовать, чтобы список можно было бы перебрать во внешней программе 	с помощью цикла foreach.
		
	Двусвязный список, Кольцевой односвязный список, Кольцевой двусвязный список
	Двусвязные списки также представляют последовательность связанных узлов, однако теперь каждый узел хранит ссылку
на следующий и на предыдущий элементы.
	Кольцевой односвязный список являются разновидностью связных списков. Их отличительной особенностью является то,
что условный последний элемент хранит ссылку на первый элемент, поэтому список получается замкнутым или кольцевым.
	Кольцевой двусвязный список представляет замкнутый список,  в котором указатель на элемент может перемещаться 
как вперед, так и назад по кругу.

		Stack, Queue, Dequeue, PriorityQueue
	Стек представляет собой структуру данных, которая работает по принципу LIFO (Last In First Out - "последний пришел -
первый вышел"). При добавлении и удалении из стека последний добавленный элемент будет первым удаляемым.
Для стека нужно всего три метода: 
	Push добавляет объект в стек O(1)
	Pop удаляет объект из стека O(1)
	Top даёт самый последний объект в стеке. O(1)
	
	Очередь представляет собой структуру данных, которая работает по принципу FIFO (First In First Out, «первым зашёл,
первым вышел»).	При добавлении и удалении из очереди первый добавляемый элемент будет первым извлекаемым. 
Очереди нужно четыре метода: 
	Push_Back добавляет элемент к концу очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.

	Двухсторонней очередь, если часто нужно добавлять или удалять элементы из обоих концов очереди. 
	Push_Back добавляет элемент к концу очереди;
	Push_Front добавляет элемент в начало очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Pop_Back удаляет элемент из конца очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	
	Очередь с приоритетом очень похожа на обычную очередь. Программа добавляет элементы с конца и извлекает элементы из
начала. Разница в том, что можно задавать приоритеты определённым элементам очереди. Все самые важные элементы
обрабатываются в порядке FIFO. Потом в порядке FIFO обрабатываются элементы с более низким приоритетом. 
	И так повторяется, пока не будут обработаны в порядке FIFO элементы с самым низким приоритетом.

	Стеки, очереди, двухсторонние очереди и очереди с приоритетом можно реализовать на основе других структур данных.
Это не фундаментальные структуры данных, но их часто используют. Они очень эффективны, когда нужно работать только с
конечными элементами данных, а серединные элементы не важны.
	НЕДОСТАТКИ 	Видимо зависят от на какой структуре данных они были реализованы, но это не точно)

		Binary Heap, Binary Search Tree, АВЛ-дерева, Обходы дерева, Балансировка узлов
    Двоичная куча - binary heap - представляет собой полное бинарное дерево, т.е у каждого узла не более двух потомков,
а так же все уровни полностью заняты данными, а последний заполнен слева направо. Двоичная куча может быть минимальной
или максимальной: 
    В максимальной куче ключ любого узла всегда больше ключей его потомков или равен им; 
    В минимальной куче ключ любого узла меньше ключей его потомков или равен им.
    Для чтения элемента с самым высоким приоритетом О(1);
    Для добавления и извлечения элементов О(log(n));
    Сортировка O(nLog(n)).
    Max - получение максимального элемента О(1);
    DelMax - удаление максимального элемента О(log(n)) - т.к. нужно делать балансировку;
    Add - добавление элемента О(log(n)) - т.к. нужно делать балансировку.
Балансировка:
    Заключается в выполнении Swap корневого элемента с узловым и так далее рекурсивно до самой вершины, до тех пор пока
родительский элемент не будет больше чем потомки.
Удаление:
    После удаления элемента вместо него переносится самый крайний добавленный элемент, далее этот элемент балансируется
с потомками, если нужно.
Добавление элемента
	Новый элемент добавляется на последнее место в массиве, то есть позицию с индексом heapSize, но может потребоваться
балансировка.
Формулы:
    Левый потом: 2i+1; Правый потомок 2i+2; Предок (i-1)/2.
    Благодаря этим формулам можно легко древовидный вид преобразовать в линейный и реализовать на массиве, чтобы получать
быстрый доступ к элементам.

	Двоичное дерево поиска
    Каждый узел имеет до двух дочерних узлов (потомков).
    Каждый узел меньше своих потомков справа, а его потомки слева меньше его самого.
    Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой
операции пропорционально логарифму общего числа элементов в дереве.
Сложность:
    Search    O(log n);
    Insert    O(log n);
    Delete    O(log n).
Элементы, не имеющие потомков, называются листьями. А тот, что не имеет предка — корнем. 

    АВЛ-дерево — это прежде всего двоичное дерево поиска, ключи которого удовлетворяют стандартному свойствам бинарного
дерева, но особенностью АВЛ-дерева является то, что оно является сбалансированным в следующем смысле: 
    для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу. 

	Обходы дерева:
    Префиксный: - Для копирования дерева с сохранением позиций элементов.
        1 - текущий элемент; 2 - левый элемент; 3 - правый элемент.
    Постфиксный: - При удалении элементов дерева.
        1 - левый элемент; 2 - правый элемент; 3 - текущий элемент.
    Инфиксный: - Возвращает отсортированное дерево.
        1 - левый элемент; 2 - текущий элемент; 3 - правый элемент.
        
	Балансировка узлов
    В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение ситуации, когда balance factor некоторых
узлов оказывается равными 2 или -2, т.е. возникает разбалансировка поддерева.
    Выполняется левый или правый поворот. 
                y           x
            x      c     a    y
        a     b            b   c
    Большой поворот применяется при условии h(s)>h(D) и сводится к двум простым — сначала правый поворот вокруг q и затем 
левый вокруг p.

		Hashtable, Hashset, Хэш-функция, коллизия
	Hashtable - представляет собой структуру данных, в которой данные хранятся в виде пар ключ-значение, где ключ 
ассоциируется с индексом т.е ключ передается в хэшфункцию, которая высчитывает число, а это число используется как индекс. 
Преимущество хеширования заключается в том, что оно обеспечивает постоянство времени выполнения от O(1) операций поиска, 
извлечения и установки значений независимо от размера структуры.
При добавлении данных в хэш-таблицу нельзя добавлять данные с одинаковым ключом, а так же ключ не может быть равен null, 
но value может быть и одинаковые value, но с разным ключом.
		Hashtable openWith = new Hashtable();
		openWith.Add("txt", "notepad.exe");
		openWith.Add(1, "notepad.exe"); // разный тип данных и ключей
	Хэш-функция должна выдавать один и тот же результат при подаче одинакового значения. Так же она должна равномерно 
распределять значения по все области значений и чем быстрее будет вычислять значение тем лучше.
	Хэш-коллизиями называются ситуации, когда для двух разных ключей функция возвращает одинаковое число. В хэш-таблицах
для борьбы с коллизией создается отдельный контейнер под этот хэш, в который помещаются ключи, но в таком случае сложность
увеличивается до O(n)
	Hashset и dictionary разрешают конфликт с коллизией по-другому, а именно для одинаковых хэшей не создается отдельная
таблица, а просто заполняется ближайший следующий элемент в этой же таблице.
Хеши важны для ассоциативных массивов и индексирования баз данных.

	Класс HashSet<T> предоставляет собой структуру данных, которая не содержит повторяющихся элементов и содержит элементы
неупорядоченно (без сортировки). Позволяет быстро определить, есть такой элемент или нет поскольку использует индекс, 
который вычисляется из хэш-кода элемента. В основе имеет реализацию Hashtable соответственно времени выполнения от O(1).
		HashSet<int> evenNumbers = new HashSet<int>();

	Dictionary представляет собой структуру данных, в которой данные хранятся в виде пар ключ-значение, но в отличии от
Hashtable класс Dictionary<K, V> key и value нужно типизировать при инициализации словаря. В основе лежит структура 
Hashtable соответственно времени выполнения от O(1).
		Dictionary<int, string> people = new Dictionary<int, string>();
	Тип, используемый в качестве ключа словаря, должен переопределять метод GetHashCode() класса Object. Всякий раз,
когда класс словаря должен найти местоположение элемента, он вызывает метод GetHashCode().
	Помимо реализации GetHashCode() тип ключа также должен реализовывать метод IEquatable<T>.Equals() либо переопределять
метод Equals() класса Object. Поскольку разные объекты ключа могут возвращать один и тот же хеш-код, метод Equals() 
используется при сравнении ключей словаря. Словарь проверяет два ключа А и В на эквивалентность, вызывая A.Equals(В).

		SortedDictionary, SortedList, SortedSet
	Класс SortedDictionary<TKey, Tvalue> представляет бинарное дерево поиска, в котором все элементы отсортированы на
основе ключа. В основе лежит красно черное дерево. Тип ключа должен реализовать интерфейс IComparable<TKey>. 
	SortedList<TKey, TValue> так же представляет коллекцию в которой все элементы отсортированы по ключу, но в 
основе лежит массив.
	Классы SortedDictionary<TKey, Tvalue> и SortedList<TKey, TValue> имеют схожую функциональность. Но поскольку
SortedList<TKey, TValue> реализован в виде списка, основанного на массиве, a SortedDictionary<TKey, Tvalue> реализован
как словарь, эти классы обладают разными характеристиками:
	SortedList<TKey, TValue> использует меньше памяти, чем SortedDictionary<TKey, TValue>
	SortedDictionary<TKey, TValue> быстрее вставляет и удаляет элементы.
	При наполнении коллекции отсортированными данными SortedList<TKey,TValue> работает быстрее, если при этом не
требуется изменение емкости.
	 Класс SortedSet<T> содержит упорядоченный список различающихся элементов в основе лежит красно черное дерево.
	 								Вставка			Удаление 		Поиска элемента
	SortedList<TKey, TValue>		O(n)			O(n)			O(log2(n))
	SortedDictionary<TKey, TValue>	O(log2(n))		O(log2(n))		O(log2(n))
	SortedSet<T>					O(log2(n))		O(log2(n))		O(log2(n))

		Что такое LINQ. Как реализованы основные методы Linq под капотом, такие как: First, Where, Count, OrderBy,
	Distinct, Contains, GroupBy.
	LINQ упрощает ситуацию, используя одинаковый шаблон для работы с различными типами источников данных, например, базы данных SQL,
наборы данных ADO.NET или просто коллекции .NET, а также с теми источниками данных, которые поддерживают интерфейс IEnumerable<T> или
интерфейс, наследуемый от него например IQueryable<T>.
	Все операции запросов LINQ состоят из трех отдельных действий: источник данных, запрос и выполнение запроса. Это важно понимать
поскольку выполнение запроса откладывается до тех пор, пока переменная запроса не будет обработана в операторе foreach. Но также можно
выполнить запрос принудительно, вызвав методы ToList, ToArray или методы Count, Max, Average и First. Они выполняются без явного
оператора foreach, поскольку сам запрос должен использовать foreach для возвращения результат. 
	LINQ поддерживает два вида синтаксиса: синтаксис запросов и синтаксис методов
		var res = from n in MyArray
          where n > 0
          select n;
	IEnumerable<int> numQuery2 = numbers.Where(num => num % 2 == 0).OrderBy(n => n);
	Все стандартные методы реализованы как расширяющие, большинство из них принимает в параметр лямбда-выражение или делегат.
Оба вида синтаксиса можно использовать вместе. Поскольку все операторы запроса реализованы в виде расширяющих методов, можно легко
добавить собственные.
	Лямбда-выражения - это специальный синтаксис для сокращённого объявления анонимных методов. => - лямбда оператор, который
читается как "переходит в". Слева от лямбда оператора стоят параметры ввода, справа - выражение. В лямбда-выражения можно
использовать внешние переменные:
	https://bool.dev/blog/detail/shpargalka-po-linq-i-sql
	https://bool.dev/blog/detail/obyasnenie-metodov-linq-v-net-s-pomoshchyu-kartinok
	https://github.com/dotnet/runtime/blob/main/src/libraries/System.Linq/src/System/Linq/Last.cs

		Как работает сравнение типов через Equals() и == в Reference Type. Как работает сравнение Value типов через Equals.
Сравнение с помощью вспомогательных классов и интерфейсов (IEqualityComparer, IStructuralEquatable, IComparable). Правила
реализации метода Equals и оператора равенства (==).
	ReferenceEquals работает идентично ==, сравнивая ссылки на объекты в heap'е т.е если ссылки на объекты идентичны, то 
возвращает true, и для структур будет false, по скольку будет произведена упаковка:
		var obj1 = new TestClass { Count = 2};
		var obj2 = new TestClass { Count = 2};
		Console.WriteLine(obj1 == obj2); false
		Console.WriteLine(obj1.Equals(obj2)); false  - Equals не переопределен.
		Console.WriteLine(object.ReferenceEquals(obj1, obj2)); false
		Console.ReadKey();
	virtual bool Equals(Object obj) - по сути за ним стоит стандартная реализация object.Equals которая вызывает
ReferenceEquals под капотом, но у значимых типов уже есть стандартная реализация этого метода, но для сложных типов следует
переопределить и GetHashCode, поскольку это может повысить производительность.
	static bool Equals(Object objA, Object objB) - является оберткой виртуального метода Equals, но перед его вызовом, делает
проверку равенства ссылок путем == и проверку на null каждого из объектов проверки.
	Сравнение с помощью вспомогательных классов и интерфейсов:
	IEqualityComparer - этот интерфейс позволяет реализовать настраиваемое сравнение на равенство для коллекций. Сравнение
при помощи таких сравнивающих объектов применяют, например, Hashtable и Dictionary<K, V>, а также некоторые LINQ-методы.
К этому интерфейсу есть и его реализация с помощью EqualityComparer<T>, который проверяет реализует ли объект интерфейс 
IEquatable<T>, и в противном случае выполняет сравнение через стандартный Equal(object). Но рекомендуется наследовать от
класса EqualityComparer<T> вместо реализации IEqualityComparer<T> интерфейса.
	IComparable - проверка на равенство так же может быть выполнена  через сравнение больше/меньше/равно. Для этого
используются операторы сравнения </>, интерфейсы IComparable (аналог метода Equals(object)), IComparable<T> (аналог интерфейса IEquatable<T>)
	IStructuralEquatable работает в паре с интерфейсом IEqualityComparer. Интерфейс IStructuralEquatable реализуют такие
классы как System.Array или System.Tuple. IStructuralEquality декларирует то, что тип может составлять более крупные объекты,
которые реализуют семантику значимых типов и вряд ли когда-либо нам потребуется его самостоятельно реализовывать.
	Правила реализации метода Equals и оператора равенства (==): Реализовав метод Equals следует реализовать GetHashCode, а также
реализовать метод Equals следует при реализации оператора равенства (==) и интерфейса IComparable, но при реализации IComparable
также рекомендуется реализовать перегрузку оператора для операторов (==), (!=), (<) и (>)
	Не вызывайте исключения из методов Equals и GetHashCode или оператора равенства (==).

		В чем разница между ключевыми словами virtual, override и new
	Виртуальный метод (virtual) – это метод, который может быть переопределен в классе-наследнике. Такой метод может иметь 
стандартную реализацию в базовом классе.
	Переопределение метода (override) – это изменение реализации метода, установленного как виртуальный (в классе наследнике
метод будет работать отлично от базового класса).
	Модификатор override расширяет метод virtual базового класса, а модификатор new скрывает доступный метод базового класса.
Разница проявляется в случае полиморфизма. Если вы работаете с экземпляром класса-наследника через его родительский класс,
то в случае, если вы будете вызывать переопределенный виртуальный метод (override), то будет вызвана его реализация из наследника,
а если перекрытый (new), то будет вызван метод базового класса.

		Оператор yield
	Оператор yield является итератором, который использует оператор yield для перебора набора значений. Например реализовав метод
GetEnumerator() с помощью оператора yield return фактически представляет итератор, который возвращает некоторое значение. Используя 
цикла foreach мы можем перебрать объект как обычную коллекцию. При получении каждого элемента в цикле foreach будет срабатывать
оператор yield return, который будет возвращать один элемент и запоминать текущую позицию.
	Конструкция yield break, позволяющая прервать генерацию последовательности, то есть остановить генератор насовсем. 
Вызов MoveNext, при котором будет выполнен yield break, вернёт false

		Тип record
	Records представляют новый ссылочный тип, который появился в C#9 и в С#10 для структур. Ключевая особенность records состоит в 
том, что они могут представлять неизменяемый (immutable) тип, но чтобы сделать его действительно неизменяемым, для свойств вместо 
обычных сеттеров надо использовать модификатор init. Тип record по умолчанию обладает рядом дополнительных возможностей по 
сравнению с классами и структурами. Например у него уже есть реализация по умолчанию для сравнения record по значению, метод ToString
который выводит состояние объекта в отформатированном виде, а также реализованы операторы == и !=. С помощью оператора with можно 
создать record на основе другого record: 
		var tom = new Person("Tom", 37);
		var sam = tom with { Name = "Sam" };
	Кроме конструкторов можно создавать и деконструктор, который раскладывает тип на кортеж значений, но самое важное, что можно
создать позиционный record это короткая запись, которая автоматически создаст конструктор, деконструктор:
		public record Person(string Name, int Age); - это все!
	Но для структур позиционные record являются изменяемыми, что бы свойства стали не изменяемыми нужно поместить readonly:
		public readonly record struct Person(string Name, int Age); - теперь автоматически будет создаваться свойство с init

		Принципы ООП. Инкапсуляция, наследование и полиморфизм. Агрегация, композиция, ассоциация.
	Инкапсуляция — это механизм языка, который связывает код и данные вместе и сохраняет их в безопасном месте как 
от внешнего вмешательства так , так и от неправильного использования данных. В C# для инкапсуляции используются публичные 
свойства и методы объекта. Переменные, за редким исключением, не должны быть публично* доступными.
	Наследование - это механизм языка, который позволяет определить производный класс на основе существующего, а также наследовать
его данные и свойства. Наследование позволяет ускорить процесс разработки за счет повторного использования кода. Наследование
позволяет выстроить архитектуру типов и открывает путь к полиморфизму.
	Полиморфизм – это механизм языка, который позволяет написать разные реализации для одного интерфейса т.е один 
интерфейс - множество реализаций». В C# полиморфизм проявляется по-разному и прибавляются несколько понятий:
	Перегрузка методов, абстрактные методы, обобщение, а так же который достигается при помощи upcasting и соответственно
ключевых слов virtual, override и new. Ну и инвариантность, ковариантность и контравариантность - то же что upcasting и
downcasting, но в обобщениях.
	new обеспечивает сокрытие A a = new B(); - вызовется метод из A.
	При upcasting методы, которые не описаны в родителе, недоступны.
	Агрегация - это когда в конструктор класса передаётся ссылка на существующий экземпляр класса.
	Композиция - это когда не передаем в конструктор, а создаем в нем новый объект, который будет неразрывно связан с этим объектом.
	Ассоциация - это когда создаем объект как свойство. Агрегация и композиция являются частным случаем ассоциации.
	Для хранения адресов виртуальных методов используется таблица виртуальных методов, общая для всех объектов одного класса. 
Именно поэтому конкретный виртуальный метод, который будет вызван, определяется во время выполнения (позднее связывание), 
а не во время компиляции (раннее связывание

		Parse, TryParse, Convert
	Все примитивные типы имеют два метода, которые позволяют преобразовать строку к данному типу. Метод Parse() в качестве 
параметра принимает строку и возвращает объект текущего типа. Например:
		int a = int.Parse("10");
		double b = double.Parse("23,56");
	TryParse() попытается преобразовать строку к типу и, если преобразование прошло успешно, то возвращает true. Иначе 
возвращается false:
		bool result = int.TryParse(input, out var number);
	Если преобразование пройдет неудачно, то исключения никакого не будет выброшено, просто метод TryParse возвратит 
false, а переменная number будет содержать значение по умолчанию.
	Класс Convert представляет еще один способ для преобразования значений, но он выбрасывает исключение FormatException
в случае неудачного преобразования. Для этого в нем определены следующие статические методы: 
		To(примитивный тип) например ToBoolean(value), ToByte(value).
	В качестве параметра в эти методы может передаваться значение различных примитивных типов, необязательно строки:
		int n = Convert.ToInt32("23");
		bool b = true;
		double d = Convert.ToDouble(b);

		IEnumerable vs IQueryable
	IQueryable в отличии от IEnumerable – IQueryable предлагает высокую производительность в случае работы с большим объемом
данных. IQueryable предварительно фильтрует данные по запросу а затем отправляет только отфильтрованные данные клиенту.
	Разница между IQueryable и IEnumerable
Основное отличие между этими интерфейсами в том, что IEnumerable работает со всем массивом данных, а IQueryable с отфильтрованным.
IEnumerable получает все данные на стороне сервера и загружает их в память а затем позволяет сделать фильтрацию по данным из памяти.
Когда делается запрос к базе данных, IQueryable выполняет запрос на серверной стороне и в запросе применяет фильтрацию. 

		Класс Stream, TextReader. Сериализация и десериализация, зачем нужна Reflection
	System.IO.Stream - представляет собой байтовый поток и является абстрактным базовым классом для всех остальных классов 
потоков, в нем определен набор членов, которые обеспечивают поддержку синхронного и асинхронного взаимодействия с хранилищем
например, файлом или областью памяти. Существует множество реализаций этого класса, например:
	System.IO.MemoryStream - Для чтения и записи в память.
	System.Net.Sockets.NetworkStream - для работы с сетевыми данными.
	FileStream - для чтения и записи данных в любой файл, а именно с текстовыми файлами, так и с бинарными.
	System.IO.StreamReader и StreamWriter базовым является TextReader - для работы непосредственно с текстовыми файлами.

	Сериализация представляет собой процесс преобразования состояния объекта в форму, пригодную для передачи т.е с возможной
последующей передачей в поток. Десериализация - осуществляется преобразование потока в объект. Вместе эти процессы
обеспечивают хранение и передачу данных. Например для передачи объекта по сети, когда используется HttpClient можно
использовать библиотеку Newtonsoft.Json и его методы JsonConvert.SerializeObject и DeserializeObject при post и get методах
соответственно.
	Чтобы объект определенного класса можно было сериализовать, надо этот класс пометить атрибутом Serializable. 
Сериализация применяется к свойствам и полям класса. Если мы не хотим, чтобы какое-то поле класса сериализовалось, то мы 
его помечаем атрибутом NonSerialized. Атрибут Serializable автоматически не наследуется.
	Форматы сериализации используется: бинарный, SOAP или XML. Они по-разному обрабатывают приватные поля и свойства. 
	BinaryFormatter - приватные поля и свойства будут сериализованы. Сериализует данные в двоичную форму. Но не рекомендуется
использовать, поскольку он считается не безопасным.
	SoapFormatter - приватные поля и свойства будут сериализованы
	XmlSerializer - приватные поля и свойства будут потеряны, чтобы этого избежать при использовании формата XML
необходимо обеспечить доступ к этим приватным полям через публичные свойства
	JSON (JavaScript Object Notation) - основная функциональность по работе с JSON сосредоточена в пространстве имен 
System.Text.Json, и он является быстрее чем Newtonsoft.Json.

	Рефлексия – это способность кода C# читать и использовать другой код C# во время выполнения, т.е читать типы, записанные в
файлах DLL, и выполнять логику из сторонних библиотек. Например чтение атрибутов. Для получения информации типе есть оператор
typeof, метод GetType() и статический метод Type.GetType(), а далее можно получить множество информации о типе при помощи методов
и свойств.
	Недостаток заключается в то, что код получается громоздким и его не очень удобно, а так же использует большое 
количество ресурсов приложение из-за чего приложение, будет малопроизводительным и относительно медленным.

		Как реализовать singleton
	Проблема singleton-а заключается в том, что он не отвечает принципу единой ответственности поскольку он отвечает
чтобы никто не могу создать объект этого типа, а также в нём определённая логика. Также объект созданный как singleton 
должен существовать в единственном экземпляре, но бывает так что заказчик внезапно передумывает и просит создать ещё 
один экземпляр соответственно придётся исправлять большое количество кода. Поэтому лучше всего не реализовывать его 
самому, а использовать DI контейнер с временем жизни singleton. Но чтобы создать его нужно:
	1. Сделать приватный конструктор
	2. Создать и вызвать статичный метод, который проверяет есть ли уже созданный объект данного типа. 
	3. В этом методе реализовать поддержку многопоточности т.е внутри первого if создать lock, а внутри него проверить
уще раз, что бы окончательно исключить, что другой поток не сделал экземпляр и после этого создать экземпляр,
проинициализировав приватное статическое поле.
		private static LockSingleton _instance;
        private static object _syncRoot = new object();
        static LockSingleton(){}
        public static LockSingleton GetInstance()
        {
            if (_instance == null)
            {
                lock (_syncRoot)
                {
                    if (_instance == null)
                    {
                        _instance = new LockSingleton();
                    }
                }
            }
            return _instance;
        }

		SOLID, IoC, DI, IoC-контейнер, Преимущества DI, Время жизни объектов.
    Single Responsibility Principle - принцип единственной обязанности. У класса должна быть только одна причина для изменения 
т.е класс должен выполнять одну единственную задачу. Весь функционал класса должен быть целостным, обладать высокой связностью.
	Open/Closed Principle - принцип открытости/закрытости. Сущности программы должны быть открыты для расширения, но закрыты для 
изменения.
	Liskov Substitution Principle- принцип подстановки Лисков. Должна быть возможность вместо базового типа подставить любой его 
наследник без изменения свойств программы. 
    Существует несколько правил, которые должны быть соблюдены для выполнения принципа подстановки Лисков. Прежде всего это 
правила контракта. - Контракт представляет собой некоторый интерфейс базового класса, который задает ряд ограничений или правил, 
и производный класс должен выполнять эти правила:
	Предусловия (Preconditions) не могут быть усилены в наследнике т.е. нельзя добавлять больше предусловий, чем это определено 
в базовом классе. Предусловия - это условия, которые находятся в самом начале метода причем предусловием могут быть только 
public свойства, поля или параметры метода. ПРИВАТНОЕ поле не может быть объектом для предусловия, так как оно не может быть 
установлено из вызывающего кода.
	Постусловия (Postconditions) не могут быть ослаблены в подклассе т.е нельзя убирать или уменьшать постусловия, которые 
определены в базовом классе. Постусловия это условия, которые стоят в самом конце метода перед вызовом return.
	Инварианты (Invariants) — все условия базового класса - также должны быть сохранены и в подклассе. Это условия например как 
поле Age, которое не должно превышать 100 как в свойстве, так и в методе. 
	В целом подтипы должны проходить все тесты, которые проходят базовые классы.
    Как правило проблема решается в общем случае с помощью абстрагирования и выделения общего функционала, который уже наследуют
классы. То есть не один из них наследуется от другого, а оба они наследуются от одного общего класса.
	Interface Segregation Principle - принцип разделения интерфейсов. Несколько специализированных интерфейсов лучше, чем один 
универсальный. Т.е универсальный интерфейс лучше разделить на несколько разных интерфейсы. В итоге разделение интерфейсов делает
систему слабосвязанной, и тем самым ее легче модифицировать и обновлять.
	Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего
уровня. И те и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от
абстракций. Служит для создания слабосвязанных сущностей, которые легко тестировать, модифицировать и обновлять.
    
	Inversion of Control (IoC) - инверсия управления  — это принцип, для написания слабо связанного кода. Суть которого в том, 
что объект не сам создает свои зависимости, а когда для этого объекта зависимости поставляются из вне. Например при помощи
агрегации интерфейса, абстрактного класса или базового. А IoC-контейнер поможет поставить требуемые зависимости.
    Dependency Injection (DI) - внедрение зависимостей — это одна из реализаций этого принципа. Это идея, обработки вне зависимого
класса, когда зависимый класс не создает экземпляры других классов, а эти экземпляры передаются ему во время инициализации, а
ответственность создания этих классов передаются на третью сторону. Существует несколько способов получения зависимостей: 
    Constructor Injection - через конструктор используется интерфейс вместо конкретного класса
	Setter, Field и Method Injection - через свойства, поле, и параметр метода;
	Так же можно, через middleware и Startup: 
		через конструктор, свойство HttpContext.RequestServices или параметр метода Invoke в компонентах middleware;
		через IServiceCollection в методе ConfigureServices в классе Startup;
		через IApplicationBuilder в методе Configure в классе Startup;

    IoC-контейнер — это какая-то библиотека, фреймворк, программа, которая позволит вам упростить и автоматизировать
написание кода с использованием данного подхода на столько, на сколько это возможно, например ASP.NET.CORE есть
встроенный контейнер служб IServiceProvider и сервисы регистрируются в методе Startup.ConfigureServices.
	Время жизни объектов:
	AddTransient() - такие объекты создаются при каждом обращении к ним.
	AddScoped() - создает один экземпляр объекта с заданным временем существования - временем существования одного 
запроса  т.е пока существует запрос так же существует и объект.
	AddSingleton() создает один объект для всех последующих запросов. При этом объект создается только тогда когда 
он непосредственно необходим и после создания он продолжает существовать.

	Регистрация групп сервисов с помощью расширения, используется для того чтобы отдельные проекты могли зарегистрировать все 
что в них есть в главном API проекте
	Можно ли из сервиса с одним временем жизни вызвать другой сервис с другим временем жизни(не всегда, но можно), например,
нельзя передавать через конструктор scoped в singleton объекты. Например есть singleton Middleware в который инжектируется
TimeService, а в него Timer и если один из них будет scoped, то во время выполнения будет ошибка, для выхода из этой ситуации 
ни TimeService, ни ITimer не должны иметь жизненный цикл Scoped. То есть это может быть Transient или Singleton.
	Тоже самое произойдет если инжектировать через метод Invoke в middleware - scoped-объекты.

	Другие принципы: DRY
	Don’t Repeat Yourself/Duplication Is Evil (DRY/DIE) — не повторяйся. Одинаковый код должен быть вынесен в отдельный метод и 
использован другими.
	Keep It Simple, Stupid! (KISS) - не усложняй! Делайте максимально простую и понятную архитектуру, применять шаблоны 
проектирования и не изобретать велосипед.​
	You Ain’t Gonna Need It (YAGNI) - не добавляйте функциональность пока она вам не нужна. Вы только потратите время на 
реализацию, отладку, тестирование и поддержку кода который может и не использоваться.   
	Command-Query Separation (CQS) - функции некоторого интерфейса должны быть или запросами, возвращающими ответ, или командами,
изменяющими состояние системы, но не одновременно. Никогда функция не должна возвращать ответ и изменять состояние системы 
одновременно.
	Descriptive And Meaningful Phrases (DAMP) - принцип написания модульных тестов таким образом, чтобы происходящее в них можно
было понять без дополнительных комментариев и документации. Достигается использованием описательных имен и допускает небольшие
нарушения принципа DRY при необходимости.
	Arrange Act Assert (AAA) - правило создания модульных тестов – задать условия (Arrange), выполнить действие (Act) и проверить
итог (Assert).
	GRASP (General Responsibility Assignment Software Patterns) - GRASP представляет из себя набор принципов, определяющих
распределение ответственностей по классам в приложении:
	Information Expert (Информационный эксперт) – класс, который владеет максимумом необходимой информации для выполнения задачи,
то он и должен быть ответственен за исполнением этой задачи. Например, т.к если Account хранит информацию о счете то именно он
должен предоставить выписку с него.
	Creator (Создатель) – классы, создающие другие классы. Это может быть фабрика, пул и т.д.
	Controller (Контроллер) – объект, который несет в себе управляющие функции, он должен отвечать за обработку входных запросов и
решает кому должен делегировать запросы на выполнение. Яркий пример, Контроллер в шаблоне MVC. 
	Low Coupling (Низкая связанность) – данный принцип говорит о том, что написание кода должно быть на основе интерфейсов и 
абстракций, а не конкретных реализаций, чтобы код был слабо связан и зависел только от абстракций. Это способствует упрощению 
повторного использования кода, его поддержки, модификации, тестированию. По сути это DIP из SOLID, а DI является его реализацией.
	High Cohesion (Высокое сцепление) – методы внутри классы должны быть тесно связаны между собой. Это еще одна гарантия, того
что класс обеспечивается реализацию четко определенной единственной ответственности. Классы с низким сцеплением легко можно
разделить на несколько. По сути это​ SRP с SOLID принципов, а высокая связанность получается в результате соблюдения SRP.
	Pure Fabrication (Чистая выдумка) – представляет собой классы, которые не отображают реальных объектов из предметной области
приложения. Например, у нас есть объект Customer данные о котором должна храниться в БД, для этого нужно создать сервис или, 
репозиторий, который будет доставать и сохранять такой объект в базу данных.
	Indirection (Посредник) – необходим для устранения сильной связанности нескольких классов. Для этого возложите ответственность
на промежуточный объект, чтобы он осуществлял связь между другими компонентами или службами, чтобы они не были напрямую связаны.
Такое решение можно сделать с помощью GoF паттерна медиатор и при помощи него происходит взаимодействия между ними. К слову, 
Контроллер в MVC является также посредником между Моделью и Представлением.
	Protected Variations (Защищенные изменения) – данный принцип предполагает определение объектов, которые наиболее вероятно
будут подвержены изменениям, и применение мер, по минимизации нежелательного влияний этих изменений на остальные части приложения.
	Polymorphism (Полиморфизм) – возможность объектов с одинаковой спецификацией иметь различную реализацию. То есть объекты
классов Square и Circle могут отображаться, реализовав метод render по разному, несмотря не то, что они оба подклассы Shape, метод
render определен в Shape. (Overriding). Принцип полиморфизма является основополагающим в ООП. В этом контексте принцип тесно
связан с GoF паттерном strategy. Это самый яркий пример реализации полиморфизма.

		Формы нормализации таблиц, цель нормализации.
	Цель нормализации - исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении,
редактировании и удалении кортежей(строк таблицы).
	Первая НФ - переменная отношения находится в первой нормальной форме, когда каждый его кортеж содержит только одно значение
для каждого из атрибутов. Другими словами в каждом поле таблицы должно быть только одно значение и не должно быть
повторяющихся строк.
	Вторая НФ - переменная отношения находится во второй нормальной форме, когда она находится в первой нормальной форме и 
каждый неключевой атрибутов зависит от первичного ключа целиком, а не от какой-то его части. Исправляется это путем декомпозиции
таблицы - разделение таблицы на несколько, в которых есть свой уникальный первичный ключ.
	Третья НФ - переменная отношения находится в третьей нормальной форме, когда она находится во второй нормальной форме, и все
атрибуты зависят только от первичного ключа, а не от других атрибутов. Исправляется декомпозицией таблиц.
	Нормальная форма Бойса-Кода - переменная отношения находится в нормальной форме Бойса-Кода, когда каждая её нетривиальная и
неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ. Другими словами
таблица в 3 НФ и ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов. Соответственно, что требования
нормальной формы Бойса-Кода предъявляются только к таблицам, у которых первичный ключ составной. Таблицы, у которых первичный
ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной форме Бойса-Кода.
	Четвертая Нф - переменная отношения находится в четвертой нормальной форме, когда она находится в нормальной форме Бойса-Кода
и не содержит нетривиальных многозначных зависимостей. Другими словами таблица в НФ Бойса-Кода и устраняются нетривиальные 
многозначные зависимости. Многозначная зависимость выглядит следующим образом: таблица должна иметь как минимум три столбца,
например A, B и C, при этом B и C между собой никак не связаны и не зависят друг от друга, но по отдельности зависят от A, и для
каждого значения A есть множество значений B, а также множество значений C. Соответственно нужно декомпилировать на две таблицы:
 A => B, A => C; Например, есть таблица Студент, Курс, Хобби, то таким образом, мы можем наблюдать в этой таблице нетривиальную
 многозначную зависимость Студент => Курс и Студент => Хобби.
	Пятая НФ - переменная отношения находится в пятой нормальной форме, когда таблица находится в 4 НФ, а также после устранения
нетривиальные зависимостей можно провести декомпозиция без потерь таким образом, что бы при объединении декомпозированых таблиц
мы получили исходную таблицу. Например есть таблица Сотрудник, Проект, Направление, но есть ряд ограничений, которые приводят к
зависимостям {Сотрудник, Проект}, {Сотрудник, Направление} и {Проект, Направление}, как видно тут нельзя разделить только на две
таблицы т.к есть зависимость Проект, Направление, соответственно нужно разделить на 3 таблицы.

		Связи таблиц.
    Связь один к одному образуется, когда одному ключевому столбцу соответствует только один ключевой объект в другой таблице.
	Связь один-ко-многим образуется, когда записи первой таблицы соответствует несколько записей в другой таблице, но запись в
другой таблице не может иметь более одной соответствующей ей записи в исходной таблице. Например, одна команда и много игроков.
	Связь «Многие ко многим» образуется, когда нескольким записям из одной таблицы соответствует несколько записей из другой
таблицы и организовывается посредством связывающей таблицы.	Например, статья и много тегов, а любой тег может ставиться
нескольким статьям.

		Реляционная база данных. Система управления базами данных, Нереляционные базы данных NoSQL, Key-value базы данных,
	Документоориентированные БД.
	Реляционная база данных  – это набор данных, хранящиеся в структурированном виде, которые организованны в виде набора таблиц,
состоящих из столбцов и строк. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке – значение атрибута. 
Каждая стока таблицы представляет собой набор связанных значений, относящихся к одному объекту или сущности, а строка может быть 
помечена уникальным идентификатором, называемым первичным ключом, или с помощью внешних ключей.
	Система управления базами данных (СУБД) — это комплекс программных средств, позволяющая создавать базы данных и манипулировать
данными в них. Например, Oracle, MySQL, MS SQL Server и тд.
	Нереляционные базы данных — это база данных, в которой в отличие от большинства традиционных систем баз данных не используется 
табличная схема строк и столбцов. В этих базах данных применяется модель хранения, оптимизированная под конкретные требования 
типа хранимых данных. Например, данные могут храниться как простые пары "ключ — значение", документы JSON или графов.
	Key-value базы данных – это тип баз данных, которые хранят данные как совокупность пар «ключ-значение», в которых ключ служит
уникальным идентификатором. Преимущества: скорость работы, простота модели хранения данных, гибкость: значения могут быть любыми,
включая JSON. Недостатки: плохо масштабируется по мере усложнения моделей данных, неэффективность при работе с группой записей.
Примером такой БД является Redis — это база данных, размещаемая в памяти, которая используется, в основном, в роли кеша,
находящегося перед другой, «настоящей» базой данных, вроде MySQL или PostgreSQL. Кеш, основанный на Redis, помогает улучшить
производительность приложений. Он эффективно использует скорость работы с данными, характерную для памяти, и смягчает нагрузку
центральной базы данных приложения.
	Документоориентированные БД – это тип баз данных, направленный на хранение и запрос данных в виде документов, подобном JSON.
Они оперируют «документами», сгруппированными по коллекциям. Документ представляет собой набор атрибутов (ключ и соответствующее
ему значение). В них отсутствует схема данных, что позволяет добавлять новую информацию в некоторые записи, не требуя при этом,
чтобы все остальные записи в базе данных имели одинаковую структуру. Документы в базе данных адресуются с помощью уникального
ключа, обычно это строка, которая генерируется автоматически. По нему можно, например, извлекать запись или ссылаться на другие
документы. А также помимо простого поиска документов по ключу, как в key-value базах данных, они предоставляют свой язык
запросов, функционал, синтаксис и производительность которого отличается от одной реализации к другой. Примером такой БД 
является MongoDB.

		Структура реляционных баз данных.
	В реляционных базах данных информация хранится в связанных друг с другом таблицах. Сами же таблицы состоят из: строк, которые
называют «записи», столбцов, которые называют «полями» или же «атрибутами». В каждой таблице каждый столбец имеет заранее 
определённый тип данных.
	Чтобы избегать неоднозначности при поиске в таблицах присутствуют первичный ключ. Это поле или набор полей, но тогда это,
составной ключ, значение которого однозначно определяет запись в таблице.
	Внешний ключ – это поле (или набор полей) в одной таблице, которое ссылается на первичный ключ в другой таблице.
	Таблица с внешним ключом называется дочерней таблицей, а таблица с первичным ключом называется базовой или родительской
таблицей.

		SQL, Транзакции, Базовый синтаксис SQL запроса, Select, функции, DISTINCT, WHERE, IS NULL, BETWEEN, IN, Оператор LIKE,
	ESCAPE-символ, оператор ORDER BY, GROUP BY, Агрегатные функции, HAVING, Порядок выполнения SQL запроса
	 SQL (Structured Query Language) – основной интерфейс работы с реляционными базами данных. SQL используется для добавления, 
обновления и удаления строк данных, извлечения наборов данных для обработки транзакций и аналитических приложений, а также для 
управления всеми аспектами работы базы данных.
	 Транзакции – это один или несколько операторов SQL, выполненных в виде последовательности операций, представляющих собой
	единую логическую задачу. Транзакция представляет собой неделимое действие, то есть она должна быть выполнена как единое
целое и либо должна быть записана в базу данных целиком, либо не должен быть записан ни один из ее компонентов. Транзакция
завершается либо действием COMMIT, либо ROLLBACK. Каждая транзакция рассматривается как внутренне связный, надежный и независимый
от других транзакций элемент.
	Select
	Select - это оператор, который позволяет получить данные из СУБД. Он позволяет выводить данные не только из таблиц, но и
литералы: SELECT "Hello world"
	* - используется для вывода всех полей из определённой таблицы: SELECT * FROM FamilyMembers
	SELECT member_id, member_name FROM FamilyMembers - если необходимо вывести информацию только по определённым столбцам таблицы,
а не всю сразу, то это можно сделать перечисляя названия столбцов через запятую.
	Псевдонимы - если мы хотим вывести какие-то столбцы таблицы, но чтобы в итоговой выборке они были названы иначе, мы можем
использовать оператор AS: SELECT member_id, member_name AS Name FROM FamilyMembers
	Литерал — это указанное явным образом фиксированное значение, например, число 12 или строка "SQL".
	Применение функций
	При составлении SQL запросов мы можем использовать встроенные функции. Например:
UPPER - если мы хотим вывести строку в верхнем регистре. SELECT UPPER("Hello world") AS upper_string;
LOWER - возвращает строку, в которой все символы записаны в нижнем регистре. SELECT LOWER('SQL Academy') AS lower_string;
YEAR - возвращает год для указанной даты. SELECT YEAR("2022-06-16") AS year;
INSTR - осуществляет поиск подстроки в строке, возвращая позицию её первого символа SELECT INSTR('sql-academy', 'academy') AS idx;
LENGTH - возвращает длину указанной строки. SELECT LENGTH('sql-academy') AS str_length;
LEFT - возвращает заданное количество крайних левых символов строки. LEFT(str, number_of_characters)
TIMESTAMPDIFF(second, time_out, time_in), чтобы получить разницу во времени в секундах между двумя датами.
	Операции над результатом функции - если мы хотим получить первые три буквы в строке и преобразовать их в заглавные. Используем
функции: LEFT и UPPER, где результат одной функции будет аргументом для второй. SELECT UPPER(LEFT('sql-academy', 3)) AS str;
	Исключение дубликатов, DISTINCT
	DISTINCT предписывает СУБД убрать из результирующей выборки все повторения и может быть применено только к первому полю:
SELECT DISTINCT 'поля_таблиц' FROM наименование_таблицы;
	При использовании оператора DISTINCT для двух и более колонок будут удаляться записи, которые имеют одинаковые значения по
всем полям.
	Where - если требуется сделать выборку по определённому условию. Нельзя возвращать более одной колонки в where для сравнения. 
SELECT [DISTINCT] поля_таблиц FROM наименование_таблицы WHERE условие_на_ограничение_строк [логический_оператор другое_условие];
SELECT * FROM Student WHERE first_name = "Grigri" AND YEAR(birthday) > 2000;
	Результатом сравнения любого значения с NULL является NULL. Исключением является оператор эквивалентности: 
NULL <=> NULL - получим true; NULL <=> 3 - false;
NOT	- меняет значение оператора сравнения на противоположный
XOR	- возвращает общее значение выражения истинно, если один и только один аргумент является истинным
	IS NULL - позволяет узнать равно ли проверяемое значение NULL, т.е. пустое ли значение, а если мы хотим найти все записи, 
где поле не равно NULL, то IS NOT NULL:
SELECT * FROM Teacher WHERE middle_name IS NULL; 		SELECT * FROM Teacher WHERE middle_name IS NOT NULL;
	BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами
значения min и max. Он идентичен условию: ... WHERE field >= min AND field <= max
SELECT * FROM Payments WHERE unit_price BETWEEN 100 AND 500;
	IN - позволяет узнать входит ли проверяемое значение столбца в список определённых значений.
SELECT * FROM FamilyMembers WHERE status IN ('father', 'mother');
	Оператор LIKE
	Оператор LIKE используется при условных запросах, когда мы хотим узнать соответствует ли строка определённому шаблону.
Синтаксис ... WHERE поле_таблицы [NOT] LIKE шаблон_строки. Шаблон может включать следующие специальные символы:
% - Последовательность любых символов (число символов в последовательности может быть от 0 и более);
_ - любой единичный символ.
Пример SELECT name, email FROM Users WHERE email LIKE '%@hotmail.%'
... WHERE поле_таблицы LIKE 'text%' - сопоставляется любым строкам, начинающимся на «text»
... WHERE поле_таблицы LIKE '%text' - сопоставляется любым строкам, заканчивающимся на «text»
... WHERE поле_таблицы LIKE '_ext' - сопоставляется строкам, имеющим длину 4 символа, при этом 3 последних обязательно должны быть
«ext». Например, слова «text» и «next»
... WHERE поле_таблицы LIKE 'begin%end' - сопоставляется строкам, начинающихся на «begin» и заканчивающихся на «end»
	ESCAPE-символ используется для экранирования специальных символов (% и \). В случае если вам нужно найти строки, вы можете
использовать ESCAPE-символ. Например, вы хотите получить идентификаторы задач, прогресс которых равен 3%:
SELECT job_id FROM Jobs WHERE progress LIKE '3!%' ESCAPE '!'; Если бы мы не экранировали трафаретный символ, то в выборку попало
бы всё, что начинается на 3.
	ORDER BY - используется для упорядочивания записей. 
SELECT поля_таблиц FROM наименование_таблицы WHERE ... ORDER BY столбец_1 [ASC | DESC][, столбец_n [ASC | DESC]], где ASC и 
DESC - направление сортировки: ASC - сортировка по возрастанию (по умолчанию); DESC - сортировка по убыванию, а для сортировки
результатов по двум или более столбцам их следует указывать через запятую:
...ORDER BY столбец_1 [ASC | DESC], столбец_2 [ASC | DESC];
	GROUP BY - если для группировки отдельных записей, в группы. 
SELECT [литералы, агрегатные_функции, поля_группировки] FROM имя_таблицы GROUP BY поля_группировки;
SELECT home_type FROM Rooms GROUP BY home_type
Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, т.е. при группировке по полю, 
содержащему NULL-значения, все такие строки попадут в одну группу.
При использовании оператора GROUP BY мы перешли от работы с отдельными записями на работу с образовавшимися группами. В связи с
этим мы не можем просто вывести любое поле из записи (например, has_tv или price), как мы это могли делать раньше. Так как в
каждой группе может быть несколько записей и в каждой из них в этом поле может быть разное значение.
При использовании GROUP BY мы можем выводить только:
- литералы, т.е. указанное явным образом фиксированные значения т.е они ни от чего не зависят.
- результаты агрегатных функций, т.е. вычисленные значения на основании набора значений.
SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type
Так выполненный запрос сначала разбивает все записи из таблицы Rooms на 3 группы, опираясь на поле home_type. Далее, для каждой
группы суммирует все значения, взятые из поля price у каждой записи, входящей в текущую группу, и затем полученный результат
делится на количество записей в данной группе.
- поля группировки. Мы можем их выводить, так как в рамках одной группы поля, по которым осуществлялась группировка, одинаковые.
В GROUP BY можно группировать только литералы, агрегирующие функции и поле, по которому была группировка, если полей больше, то 
нужно перечислить все в GROUP BY а,б,с
	Агрегатные функции
	Агрегатная функция – это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение.
SELECT [литералы, агрегатные_функции, поля_группировки] FROM имя_таблицы GROUP BY поля_группировки;
SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type
SUM(поле_таблицы)	Возвращает сумму значений
AVG(поле_таблицы)	Возвращает среднее значение
COUNT(поле_таблицы)	Возвращает количество записей
MIN(поле_таблицы)	Возвращает минимальное значение
MAX(поле_таблицы)	Возвращает максимальное значение
Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT(*).
	HAVING
	Оператор HAVING - используется для фильтрации групп.
SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type HAVING avg_price > 50
	Порядок выполнения SQL запроса
Почему нельзя использовать WHERE и зачем нужен отдельный оператор для фильтрации групп? Все дело в порядке выполнения SQL 
запроса:
From - получение всех записей из таблицы;
Where - фильтрация записей по определенным условиям;
Group by - формирование групп на основе записей после фильтрации;
Having - фильтрация групп по определенным условиям;
Order by - сортировка полученных результатов.
	Наш первый запрос был неверный, потому что мы пытались использовать поле avg_price у образовавшихся групп ещё до их образования,
так как выполнение оператора WHERE предшествует группировке. То есть оператор WHERE в момент его исполнения ничего не знает о
последующей группировке, он работает только с записями из таблицы. Так мы, например, с его помощью можем отфильтровать записи
таблицы Rooms по цене до применения группировки и лишь затем вычислить среднюю стоимость групп оставшегося жилья.
	Общая структура запроса с оператором HAVING
SELECT [константы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
WHERE условия_на_ограничения_строк
GROUP BY поля_группировки
HAVING условие_на_ограничение_строк_после_группировки
ORDER BY условие_сортировки

		Многотабличные запросы, JOIN, Внутреннее соединение INNER JOIN, Внешнее соединение OUTER JOIN, Внешнее левое
	соединение (LEFT OUTER JOIN), Внешнее правое соединение (RIGHT OUTER JOIN), Внешнее полное соединение (FULL OUTER JOIN)
	Общая структура многотабличного запроса
SELECT поля_таблиц FROM таблица_1
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2
    ON условие_соединения
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
    ON условие_соединения]
Как можно увидеть по структуре, соединение бывает: внутренним INNER (по умолчанию) и внешним OUTER, при этом внешнее соединение
делится на левое LEFT, правое RIGHT и полное FULL, а ON позволяет сопоставить таблицы друг другу и соединение сработало. В
большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле)
	Внутреннее соединение INNER JOIN
Внутреннее соединение — соединение, при котором находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем
самым образуя новую таблицу, содержащую поля из первой и второй исходных таблиц. Если не указаны какие-либо параметры, JOIN
выполняется как INNER JOIN, то при внутреннем соединении INNER является опциональным.
... INNER JOIN Goods ON Payments.good_id = Goods.good_id  - Так как в нашем условии указано равенство полей Payments.good_id и
Goods.good_id, то при внутреннем соединении в итоговой выборке окажутся только записи, где в обоих таблицах есть одинаковое
значение good_id.
	Использование WHERE для соединения таблиц
Для внутреннего соединения таблиц также можно использовать оператор WHERE. Например, вышеприведённый запрос, написанный с помощью
INNER JOIN, будет выглядеть так:
SELECT family_member, member_name FROM Payments, FamilyMembers
    WHERE Payments.family_member = FamilyMembers.member_id
	Внешнее соединение OUTER JOIN
Внешнее соединение может быть трёх типов: левое (LEFT), правое (RIGHT) и полное (FULL). По умолчанию оно является полным. Главным
отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух
таблиц (FULL).
	Внешнее левое соединение (LEFT OUTER JOIN)
Соединение, которое возвращает все значения из левой таблицы, соединённые с соответствующими значениями из правой таблицы, если
они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае.
SELECT поля_таблиц FROM левая_таблица LEFT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ 
Получение данных, относящихся только к левой таблице:
SELECT поля_таблиц FROM левая_таблица LEFT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
WHERE правая_таблица.ключ IS NULL
	Внешнее правое соединение (RIGHT OUTER JOIN)
Соединение, которое возвращает все значения из правой таблицы, соединённые с соответствующими значениями из левой таблицы, если
они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае.
SELECT поля_таблиц FROM левая_таблица RIGHT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
Получение данных, относящихся только к правой таблице:
SELECT поля_таблиц FROM левая_таблица RIGHT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
WHERE левая_таблица.ключ IS NULL
	Внешнее полное соединение (FULL OUTER JOIN)
Соединение, которое выполняет внутреннее соединение записей и дополняет их левым внешним соединением и правым внешним
соединением. 
SELECT поля_таблиц FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
Алгоритм работы полного соединения:
- Формируется таблица на основе внутреннего соединения (INNER JOIN)
- В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN)
- В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN)
Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать,
используя: LEFT JOIN => UNION ALL => RIGHT JOIN => WHERE левая_таблица.ключ IS NULL
SELECT * FROM левая_таблица LEFT JOIN правая_таблица  ON правая_таблица.ключ = левая_таблица.ключ
UNION ALL
SELECT * FROM левая_таблица RIGHT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
WHERE левая_таблица.ключ IS NULL
	Получение данных, относящихся как к левой, так и к правой таблице:
SELECT поля_таблиц FROM левая_таблица INNER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
	Получение данных, не относящихся к левой и правой таблицам одновременно (обратное INNER JOIN):
SELECT поля_таблиц FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
WHERE левая_таблица.ключ IS NULL OR правая_таблица.ключ IS NULL

		Ограничение выборки, оператор LIMIT, Подзапросы, Подзапрос с одной строкой с одним столбцом, Подзапросы с несколькими
	строками и одним столбцом, оператор ALL, IN, ANY, Многостолбцовые подзапросы, Коррелированные подзапросы, Обобщённое
	табличное выражение, оператор WITH, Объединение запросов, оператор Union, INTERSECT, EXCEPT, оператор CASE, функция IF,
	IFNULL, NULLIF
	Оператор LIMIT позволяет извлечь определённый диапазон записей из одной или нескольких таблиц.
Общая структура запроса с оператором LIMIT:
SELECT поля_выборки FROM список_таблиц LIMIT [количество_пропущенных_записей,] количество_записей_для_вывода;
Если не указать количество пропущенных записей, то их отсчёт будет вестись с начала таблицы. Оператор LIMIT реализован не во всех
СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для тех случаев, когда необходимо
сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.
Для того, чтобы вывести строки с 3 по 5, нужно использовать такой запрос:
SELECT * FROM Company LIMIT 2, 3;
Или, что то же самое:
SELECT * FROM Company LIMIT 3 OFFSET 2;
	Подзапросы
	Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется
перед основным запросом. Как и любой другой SQL запрос, подзапрос возвращает результирующий набор, который может быть одним из
следующих: одна строка и один столбец; нескольких строк с одним столбцом; нескольких строк с несколькими столбцами.
	Подзапрос с одной строкой с одним столбцом
Данный тип подзапросов также известен как скалярный подзапрос. Он может использоваться в различных частях основного SQL запроса,
но чаще всего он используется в условиях ограничений выборки с помощью операторов сравнения (=, <> - не равно, >, <).
Следующий простейший запрос демонстрирует вывод единственного значения (названия компании).
SELECT (SELECT name FROM company LIMIT 1) AS company_name;
Таким же образом можно использовать скалярные подзапросы для фильтрации строк с помощью WHERE, используя операторы сравнения. С
помощью данного запроса возможно получить самого младшего члена семьи. Подзапрос в данном случае необходим для получения
максимальной даты рождения, которая затем используется в основном запросе для фильтрации строк.
SELECT * FROM FamilyMembers WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
	При использовании результата подзапроса с операторами сравнения, важно, чтобы подзапрос возвращал именно скалярное значение
(1 строка и 1 колонка). Если бы данный подзапрос вернул несколько значений, то СУБД бы вернула ошибку, сообщающую, что ожидалось,
что подзапрос вернёт лишь 1 запись: «ER_SUBQUERY_NO_1_ROW: Subquery returns more than 1 row». Поэтому стоит быть осторожным при
написании подзапросов и представлять, какой результат вернёт подзапрос, и какие операторы мы можем использовать вместе с
результирующим набором.
	Подзапросы с несколькими строками и одним столбцом
	Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения, как это можно было
делать со скалярными подзапросами. Однако c подзапросами, возвращающими несколько строк и один столбец, можно использовать 3
дополнительных оператора:
	- Подзапрос и оператор ALL - c помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе,
полученным подзапросом. При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в
наборе вернут TRUE. Например, для всех ли жилых помещений выполняется условие, что оно дешевле чем 200:
SELECT 200 > ALL(SELECT price FROM Rooms)
Выведите названия товаров из таблицы Goods (поле good_name), которые ещё ни разу не покупались ни одним из членов семьи
(таблица Payments): Select good_name From Goods Where good_id <> All(Select good From Payments)
	- Подзапрос и оператор IN - проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может
использоваться подзапрос, возвращающий несколько строк с одним столбцом. Например, если нам необходимо получить всю информацию о
владельцах жилья стоимостью больше 150 условных единиц, то это можно сделать следующим образом:
SELECT * FROM Users WHERE id IN (SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150)
	- Подзапрос и оператор ANY - имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения
со значением в наборе вернёт TRUE. Давайте с его помощью напишем такой же запрос, что мы делали с оператором IN: найдём
пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150.
SELECT * FROM Users WHERE id = ANY (SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150)
	Многостолбцовые подзапросы
До этого мы рассматривали лишь подзапросы, возвращающие один столбец. Но мы также можем работать с подзапросами, возвращающими
несколько столбцов и несколько строк (производные таблицы). SQL поддерживает сравнение не только по одной колонке, но позволяет
попарно сравнивать значения в основном запросе со значениями в подзапросе. Например, если мы хотим получить информацию о всех
бронированиях, в которых цена жилья на момент брони (Reservations.price) соответствует текущей стоимостью жилья (Room.price). То
мы это можем сделать следующим образом:
SELECT * FROM Reservations WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
Выведите список комнат (все поля, таблица Rooms), которые по своим удобствам (has_tv, has_internet, has_kitchen, has_air_con)
совпадают с комнатой с идентификатором "11".
Select * From Rooms Where (has_tv, has_internet, has_kitchen, has_air_con) IN 
					(Select has_tv, has_internet, has_kitchen,has_air_con From Rooms Where id = 11);
	Коррелированные подзапросы
Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного
запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе.
Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса. Пример коррелированного подзапроса
Например, следующий коррелируемый подзапрос находит кто и сколько потратил:
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount) FROM Payments WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
В данном случае, коррелированный подзапрос ссылается к столбцу member_id из основного запроса. Коррелированный подзапрос 
отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен,
а для каждой строки, которая может быть включена в окончательный результат. Так в нашем случае основной запрос к таблице
FamilyMembers возвращает 8 записей и для каждой из них выполняется коррелированный подзапрос. Влияние на производительность:
Следует обратить внимание на то, что использование коррелированных подзапросов может вызвать проблемы с производительностью,
особенно если содержащий запрос возвращает много строк, так как коррелированный подзапрос будет выполняться для каждой строки
содержащего запроса отдельно.
С помощью коррелированного подзапроса выведите имена всех членов семьи (member_name) и цену их самого дорогого купленного товара.
Для вывода цены самого дорогого купленного товара используйте псевдоним good_price. Если такого товара нет, выведите NULL.
Select FamilyMembers.member_name, (
    Select Max(amount* unit_price) From Payments Where FamilyMembers.member_id = Payments.family_member Group by family_member 
) as good_price
From FamilyMembers
	Обобщённое табличное выражение, оператор WITH
Обобщённое табличное выражение или CTE (Common Table Expressions) - это временный результирующий набор данных, к которому можно
обращаться в последующих запросах. Для написания обобщённого табличного выражения используется оператор WITH. Выражение с WITH
считается «временным», потому что результат не сохраняется где-либо на постоянной основе в схеме базы данных, а действует как
временное представление, которое существует только на время выполнения запроса, то есть оно доступно только во время выполнения
операторов SELECT, INSERT, UPDATE, DELETE или MERGE. Оно действительно только в том запросе, которому он принадлежит, что
позволяет улучшить структуру запроса, не загрязняя глобальное пространство имён. Синтаксис оператора WITH
WITH название_cte 	[(столбец_1 [, столбец_2 ] …)] AS 
	(подзапрос)
    [, название_cte [(столбец_1 [, столбец_2 ] …)] AS 
	(подзапрос)] …
Порядок использования оператора WITH:
Ввести оператор WITH => Указать название обобщённого табличного выражения => Опционально: определить названия для столбцов
получившегося табличного выражения, разделённых знаком запятой =>  Ввести AS и далее подзапрос, результат которого можно будет
использовать в других частях SQL запроса, используя имя, определённое на 2 этапе => Опционально: если необходимо более одного
табличного выражения, то ставится запятая и повторяются шаги 2-4.
Создаём табличное выражение Aeroflot_trips, содержащие все полёты, совершенные авиакомпанией «Aeroflot»:
WITH Aeroflot_trips (aeroflot_plane, town_from, town_to) AS
    (SELECT plane, town_from, town_to FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
SELECT * FROM Aeroflot_trips;
	Обобщённые табличные выражения были добавлены в SQL для упрощения сложных длинных запросов, особенно с множественными
подзапросами. Их главная задача – улучшение читабельности, простоты написания запросов и их дальнейшей поддержки. Это происходит
за счёт сокрытия больших и сложных запросов в созданные именованные выражения, которые потом используются в основном запросе.
	Объединение запросов, оператор Union
Результаты выполнения SQL запросов можно объединять. Для этого существует оператор UNION. Общая структура запроса с оператором
UNION: 
SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;
UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.
- Не путайте операции объединения запросов с операциями объединения таблиц. Для этого служит оператор JOIN.
- Не путайте операции объединения запросов с подзапросами. Подзапросы выполняются для связанных таблиц.
Объединение таблиц оператором UNION выполняется для таблиц никак не связанных, но со схожей структурой.
Для того, чтобы UNION корректно сработал нужно: чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число
столбцов, с одним и тем же типом данных и в той же самой последовательности. Существует два других оператора, чьё поведение
крайне схоже с UNION:
INTERSECT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором
элементе SELECT.
EXCEPT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором
элементе SELECT.
Примеры использования: выведите полные имена (поля first_name, middle_name и last_name) всех студентов и преподавателей.
Select first_name , middle_name , last_name From Student
Union
Select first_name , middle_name , last_name From Teacher
	Условная логика, оператор CASE
Позволяет писать условную логику, чтобы в зависимости от набора условий возвращать одно из множества возможных значений. И 
реализуется с помощью оператора CASE. Синтаксис поискового выражения CASE
CASE
    WHEN условие_1 THEN возвращаемое_значение_1
    WHEN условие_n THEN возвращаемое_значение_n
    [ELSE возвращаемое_значение_по_умолчанию]
END
Если условие_1 возвращает истинное значение, то выражение CASE вернёт возвращаемое_значение_1, иначе будет сделана проверка на
условие_2 и т.д. Если ни одно из предложенный условий не будет выполнено, то вернётся NULL или
возвращаемое_значение_по_умолчанию, если была использована конструкция ELSE.
Рассмотрим оператор CASE на примере определения этапа школьного образования.
SELECT name,
CASE
  WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (10, 11) THEN "Старшая школа"
  WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (5, 6, 7, 8, 9) THEN "Средняя школа"
  ELSE "Начальная школа"
END AS stage
FROM Class
	Условная функция IF
Простое сравнение двух чисел. Так как 10 не больше 20, функция вернёт "FALSE". Функции IF можно также вкладывать друг в
друга, эмулируя оператор CASE.
IF (условное_выражение, значение_1, значение_2);
SELECT IF(10 > 20, "TRUE", "FALSE");
	Функции IFNULL и NULLIF направленны на обработку NULL значений. 
	Функция IFNULL возвращает значение, переданное первым аргументом, если оно не равно NULL, иначе возвращает 
альтернативное_значение:  IFNULL(значение, альтернативное_значение);
Select first_name, 
    IFNULL(middle_name, "Empty") as middle_name
From Teacher
	Функция NULLIF возвращает NULL, если значение_1 равно значению_2, в противном случае возвращает значение_1.
	NULLIF(значение_1, значение_2);
	
		Добавление данных, оператор INSERT, Обновление данных, оператор UPDATE, Удаление данных, оператор DELETE и TRUNCATE,
	Создание и удаление баз данных, Создание и удаление таблиц
Для добавления новых записей в таблицу предназначен оператор INSERT. Общая структура запроса с оператором INSERT
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...) | SELECT поле_таблицы, ... FROM имя_таблицы ...
Значения можно вставлять перечислением с помощью слова VALUES, перечислив их в круглых скобках через запятую или c помощью
оператора SELECT.
INSERT INTO Goods (good_id, good_name, type) VALUES (20, 'Table', 2);
Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведёт к
ошибке.При добавлении новой записи с уникальными индексами решением может быть дополнительный запрос, направленный на выявление
максимального значения первичного ключа для генерации нового уникального значения.
INSERT INTO Goods SELECT COUNT(*) + 1, 'Table', 2 FROM Goods;
В MySQL введён механизм его автоматической генерации. Для этого достаточно снабдить первичный ключ good_id атрибутом
AUTO_INCREMENT. Тогда при создании новой записи в качестве значения good_id достаточно передать NULL или 0— поле автоматически
получит значение, равное максимальному значению столбца good_id, плюс единица.
В PostgreSQL есть схожий механизм для автоматической генерации уникального идентификатора. Для этого он имеет типы SMALLSERIAL,
SERIAL, BIGSERIAL, которые не являются настоящими типами, а скорее просто удобством записи столбцов с уникальным идентификатором.
Столбец с одним из вышеперечисленных типов будет являться целочисленным и автоматически увеличиваться при добавление новой записи.
CREATE TABLE Goods (
	good_id SERIAL
	...
 );
	Обновление данных, оператор UPDATE
Для редактирования существующих записей в таблицах существует SQL оператор UPDATE. Будьте внимательны, когда обновляете данные.
Если вы пропустите оператор WHERE, то будут обновлены все записи в таблице. Общая структура запроса с оператором UPDATE:
UPDATE имя_таблицы SET поле_таблицы1 = значение_поля_таблицы1, поле_таблицыN = значение_поля_таблицыN [WHERE условие_выборки]
UPDATE FamilyMembers SET member_name = "Andie Anthony" WHERE member_name = "Andie Quincey";
В запросах на обновление данных можно менять значения, опираясь на предыдущие значение.
UPDATE Payments SET unit_price = unit_price * 2
	Удаление данных, оператор DELETE
Для этого в SQL предусмотрены операторы DELETE и TRUNCATE, из которых наиболее универсальным и безопасным является первый вариант.
DELETE FROM имя_таблицы [WHERE условие_отбора_записей];
Если условие отбора записей WHERE отсутствует, то будут удалены все записи указанной таблицы.
Эту же операцию (удаления всех записей) можно сделать также с помощью оператора TRUNCATE. Он выполнит удаление таблицы и
пересоздаст её заново - этот вариант работает гораздо быстрее, чем удаление всех записей одна за другой (как в случае с DELETE)
особенно для больших таблиц.
TRUNCATE TABLE имя_таблицы;
Оптимизатор запросов СУБД MySQL автоматически использует оператор TRUNCATE, если оператор DELETE не содержит условия WHERE или
конструкции LIMIT. Однако у оператора TRUNCATE есть ряд отличий:
- Не срабатывают триггеры, в частности, триггер удаления
- Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
- Сбрасывает счётчик идентификаторов до начального значения
- Чтобы использовать, необходимы права на изменение таблицы
- Удаление записей при многотабличных запросах
Если в DELETE запросе используется JOIN, то необходимо указать из каких(ой) именно таблиц(ы) требуется удалять записи.
DELETE имя_таблицы_1 [, имя_таблицы_2] FROM
имя_таблицы_1 JOIN имя_таблицы_2
ON имя_таблицы_1.поле = имя_таблицы_2.поле
[WHERE условие_отбора_записей];
Например, необходимо удалить все бронирования жилья, в котором отсутствует кухня. Тогда запрос будет выглядеть следующим образом:
DELETE Reservations FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
Если бы, помимо удаления бронирования, нам нужно было также удалить и жилье, то запрос приобрёл бы следующий вид:
DELETE Reservations, Rooms FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
	Создание и удаление баз данных
Создание базы данных имеет следующий синтаксис: CREATE DATABASE имя_базы_данных;
Проконтролировать создание базы данных можно с помощью оператора SHOW DATABASES;
Удаление базы данных осуществляется с помощью оператора DROP DATABASE: DROP DATABASE имя_базы_данных;
	При создании базы данных или при её удалении может возникнуть ошибка, что база данных с таким именем уже существует (при
создании) или, наоборот, данной базы данных не существует (при удалении). Для таких случаем существует конструкция IF [NOT] EXIST.
То есть, если мы хотим создать базу данных только при условии, что она пока не существует, то используется следующий синтаксис:
CREATE DATABASE IF NOT EXIST имя_базы_данных;
Если мы хотим удалить базу данных только при условии, что она существует, то используется следующий синтаксис:
DROP DATABASE IF EXIST имя_базы_данных;
	Создание и удаление таблиц
Перед созданием таблицы необходимо выбрать базу данных, в которую таблица будет записана. Это делается с помощью оператора USE:
USE имя_базы_данных;
Для создания таблицы используется оператор CREATE TABLE. Его базовый синтаксис имеет следующий вид:
CREATE TABLE [IF NOT EXIST] имя_таблицы (
     столбец_1 тип_данных,
    [столбец_2 тип_данных,]
    ...
    [столбец_n тип_данных,]
);
Например, создадим таблицу пользователей.
CREATE TABLE Users (
    id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18
);
Для того, чтобы посмотреть описание созданной таблицы можно воспользоваться оператором DESCRIBE: DESCRIBE Users;
Запрос для создания таблицы с внешним ключом будет и при наличии внешних ключей можно определить поведение текущей записи, при
изменении или удалении записи, на которую она ссылается.
CREATE TABLE Users (
    id INT,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18,
    company INT,
    PRIMARY KEY (id),
    FOREIGN KEY (company) REFERENCES Companies (id)
    ON DELETE RESTRICT ON UPDATE CASCADE
);
ON DELETE RESTRICT означает, что если попробовать удалить компанию, у которой в таблице Users есть данные, база данных не даст
этого сделать: Cannot delete or update a parent row: a foreign key constraint fails
Если бы было указано ON DELETE CASCADE, то при удалении компании были бы удалены все пользователи, ссылающиеся на эту компанию.
ON DELETE SET NULL - при её использовании база данных запишет NULL в качестве значения поля company для всех пользователей,
работавших в удалённой компании.
ON UPDATE CASCADE означает, что если компания изменит свой идентификатор, то все пользователи (Users) получат новый
идентификатор в поле company.
	Удаление таблицы
Удаление таблицы производится при помощи оператора DROP TABLE: DROP TABLE [IF EXIST] имя_таблицы;


		Паттерны несколько каждого вида. Какие архитектурные паттерны вы знаете?

		Сетевое взаимодействие и протоколы:
		REST vs GRPc, Microservices, MessageBroker

		тестирование NUnit
		Dapper vs EF
		
		
		SQL
		
		Что делает браузер, чтобы отобразить страницу
		Жизненный цикл ASP.NET MVC приложения.txt
		Основы архитектуры IIS-конвейера обработки запроса.txt
		Что происходит с HTTP-запросом от момента его поступления на 80-й порт и до передачи управления странице.txt
	

		Clean architecture
	Состоит из слоев:
	Presentation - Web API
		Controllers - контроллеры.
		Program.cs - 
	Core
		Application - тут будет реализована вся логика запросов, получение валидация и тд А именно интерфейсDb контекста, который
будет реализован в Persistence
		Common - содержит инфраструктуру т.е все что относится к поведению, исключения, интерфейсы, маппинг и тд.
		Cqrs - содержит команды и запросы для всех сущностей. которые состоят из Command и CommandHandler. 
			Используется библиотека MediatR
		Domain
			Entities - описываем набор таблиц
		Dto - содержит набор EntityDto, в них же можно маппить
	Infrastructure
		Persistence - уровень который ответственный с взаимодействием с БД( есть ссылка с Application and Domain)
			Configurations - описываем конфигурации сущности таблицы для Fluent из Domain.Entities	

		CORS
	CORS - расшифровывается как Cross-origin resource-sharing, т.е совместное использование ресурсов между разными источниками - 
технология современных браузеров, которая позволяет веб-страницам доступ к ресурсам другого домена. Например, если с одного сайта 
попытаются запросить ресурс домен которого отличается, хоть сам запрос выполнится успешно, но будет получена ошибка CORS policy.
Причина по которой ресурс будет неполученн это Same-Origin Policy и сделанное это для того, что сайт с определенным доменом, не могли
отправлять запросы на сайты которые не входят в его обязанности. Но для того что бы разрешить работу JS на сторонних сайтах, чтобы
они могли получать доступ к нашим ответам API, то нужно включить CORS в заголовок ответа от сервера и делается на стороне сервера.
	Источник- origin состоит из: протокол(например https), хост(напр example.com), порт
	Существует класс атак подделка межсайтовых запросов Cross Site Request Forgery - CSRF+ от которых не защищает Same origin Policy

		когда hashtable быстрее чем статический массив   https://www.youtube.com/watch?v=K4sYJHuNgmE&ab_channel=Winderton
https://www.youtube.com/watch?v=nFEkZXD2wFI&ab_channel=loftblog
https://www.youtube.com/watch?v=jBvkN8_c7t8&ab_channel=loftblog
		Эффективная работа с EntityFramework Core
		lazyLoading  https://youtu.be/pzas6e-ArpM?t=1020


		В каких случаях может пригодиться ValueTask?
--Ссылки:
Наглядная таблица с разными Join - https://sql-academy.org/ru/guide/outer-join

Alt+enter+создать конструктор=конструктор с инициализированными полями ))
https://bool.dev/blog/detail/voprosy-na-sobesedovanii-dlya-senior-net-developer