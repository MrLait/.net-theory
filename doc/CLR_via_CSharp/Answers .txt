		CLR
	Common Language Runtime, CLR — общеязыковая среда выполнения — это среда выполнения, которая подходит для разных языков 
программирования. 
	Исходный код программы может быть написан на любом языке, поддерживающем среду выполнения CLR. Затем соответствующий
компилятор проверяет синтаксис и анализирует исходный код программы. Результатом компиляции будет являться managed module. 
Помимо управляемого модуля компилятор генерирует IL-код и метаданные. 

		managed module
	Управляемый модуль (portable executable, PE) — стандартный переносимый исполняемый файл 32-разрядной или 64-разрядной Windows,
и требует для своего выполнения CLR. 
	Упровляемый модуль состоит: 
	- Заголовок PE32/PE32+  - содержит версию разрядности Windows в которой может испольнятся этот модуль, а также, тип файла,
временную метку, когда файл был собран. 
	- Заголовок CLR - заголовок включает нужную версию CLR, флаги, метку метаданных MethodDef - точки входа в управляемый модуль,
а также месторасположение, размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр;
	- Метаданные - это таблицы, описывающие типы данных и их члены, определенные в исходном коде и на которые имеются ссылки 
в исходном коде. Существуют три категории таблиц: определений, ссылок и манифестов.
	- Код Intermediate Language (IL) - код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует 
IL в машинные команды.
		
		IL-код
	IL-код - это код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды.
IL — язык более высокого уровня по сравнению с большинством других машинных языков. Он позволяет работать с объектами и имеет 
команды для создания и инициализации объектов, вызова виртуальных методов и непосредственного манипулирования элементами 
массивов, а так же нем есть команды инициирования и перехвата исключений для обработки ошибок.

		Метаданные
	Метаданные — это набор таблиц данных, описывающих то, что определено в управляемом модуле, например типы и их члены. 
В метаданных также есть таблицы, указывающие, на что ссылается управляемый модуль, например на импортируемые типы и их члены, 
которые всегда связаны с файлом, содержащим IL-код. Благодаря тому что компилятор генерирует метаданные и код одновременно и 
привязывает их к конечному управляемому модулю, возможность рассинхронизации метаданных и описываемого ими IL-кода исключена.
	 Например функциясреды Visual Studio IntelliSense анализирует метаданные и сообщает, какие методы, свойства, события и поля 
предпочтительны в данном случае и какие именно параметры требуются конкретным методам.
	Метаданные позволяют сериализовать поля объекта, а затем передать провести процесс десериализации, восстановив объект и его 
состояние на удаленном компьютере.
	Метаданные позволяют сборщику мусора отслеживать жизненный цикл объектов. При помощи метаданных сборщик мусора может 
определить тип объектов и узнать, какие именно поля в них ссылаются на другие объекты
	Существуют три категории таблиц: определений, ссылок и манифестов. 
В ходе компиляции исходного текста компилятор также обнаруживает типы, поля, методы, свойства и события, на которые имеются 
ссылки в исходном тексте. Все сведения о найденных сущностях регистрируются в нескольких таблицах ссылок, составляющих метаданные. 

		assembly
	Сборка (assembly)- это совокупность одного или нескольких файлов, которые представляет собой исполняемое приложение, либо 
библиотеку DLL, содержащую набор типов, а один из файлов сборки выбирается для хранения ее манифеста, который предстваляет 
собой набор таблиц метаданных, содержащих в основном имена файлов, составляющих сборку. 
	Сборка обеспечивает логическую группировку одного или нескольких управляемых модулей или файлов ресурсов, поддерживающего 
многократное использование, безопасность и управление версиями. Например, редко используемые типы и ресурсы можно вынести в 
отдельные файлы сборки, которые могут загружаться по запросу из Интернета по мере необходимости в процессе выполнения программы.
	Модули сборки также содержат сведения о других сборках, на которые они ссылаются. Это позволяет среда CLR определить все 
прямые зависимости данной сборки, необходимые для ее выполнения.

		manifest
	Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном содержат имена файлов, которые входят в сборку,
Кроме того, эти таблицы описывают версию и региональные стандарты сборки, ее издателя, общедоступные экспортируемые типы, 
а также все составляющие сборку файлы.
		
		unsafe
	По умолчанию компилятор C# компании Microsoft генерирует безопасный код - это код безопасность которого подтверждается в 
процессе верификации. Небезопасный код - это код, способный напрямую работать с адресами памяти и манипулировать с байтами по 
этим адресам. Соответственно использование небезопасного кода создает значительный риск: он может повредить структуры данных и 
использовать или создавать уязвимости в системе безопасности. По этой причине компилятор C# требует, чтобы все методы, содержащие
небезопасный код, помечались ключевым словом unsafe, а при компиляции исходного кода использовался параметр компилятора /unsafe.

		Библиотека FCL
	FCL (Framework Class Library) - является одним из компонентов .NET Framework, который содержит набор сборок в формате DLL, 
содержащих несколько тысяч определений типов. Так как FCL содержит буквально тысячи типов, взаимосвязанные типы объединяются в 
одно пространство имен.
		
		CTS
	CTS (Common Type System) спецификация, которая описывает способ определения и поведение типов.
Компания Microsoft предоставляет CTS вместе с другими частями .NET Framework в органкомитет ECMA с целью стандартизации. 
Стандарт называется CLI (Common Language Infrastructure) и определяется спецификацией ECMA-335. Согласно спецификации CTS, 
тип может содержать ноль и более членов. Иметь, поля, методы, модификаторы доступа, а также определяет правила, управляющие 
наследованием, работой виртуальных методов, сроком жизни объектов и т.д.

		CLI
	CLI (Common Language Infrastructure) - общеязыковая инфраструктура, а в документ ECMA-335 содержится спецификация общеязыковой
инфраструктуры (CLI)
	
		CLS
	CLS (Common Language Speciication) в ней перечислен минимальный набор возможностей, которые должны поддерживаться компилятором
для генерирования типов, совместимых с другими компонентами, написанными на других CLS-совместимых языках на базе CLR.
	CLS определяет правила, которым должны соответствовать типы и методы с внешней видимостью, для того чтобы они могли 
использоваться в любом CLS-совместимом языке программирования

		Глобальный кэш сборок
	Место, где располагаются совместно используемые сборки, называют глобальным кэшем сборок (global assembly cache, GAC).
	Зачем «регистрировать» сборку в каталоге GAC? Например две компании сделали свою сборку OurLibrary, состоящую из файла с 
одинаковыи именем и поскольку файл, копируемый последним, перезапишет первый и тем самым нарушит работу какого-нибудь приложения,
чтобы не допустить этого для установки в GAC можно использовать специальный инструмент, который создаст отдельные папки для каждой
из этих сборок и скопирует каждую сборку в свою папку.

		System.Object
В CLR каждый объект прямо или косвенно является производным от System.Object. Благодаря тому, что все типы, в конечном счете, 
являются производными от System.Object, любой объект любого типа гарантированно имеет минимальный набор методов.
 - Equals - возвращает true, если два объекта имеют одинаковые значения. 
 - GetHashCode - возвращает хеш-код для значения данного объекта. 
 - ToString - по умолчанию возвращает полное имя типа, но можно переопределить, чтобы он возвращал объект String, содержащий 
состояние объекта в виде строки. 
 - GetType - позволяет получить тип данного объекта. Может использоваться с классами, реализующими отражение для получения 
информации о типе в виде метаданных. Является невиртуальным, его нельзя переопределить.
 - MemberwiseClone этот невиртуальный метод выполняет неглубокое клонирование Object. Возвращается ссылка на созданный
экземпляр, у которого значимые типы будут своими, а ссылочные общие.
 - Finalize - этот виртуальный метод вызывается автоматически уборщиком мусора. В типах работающих с неуправляемыми ресурсами, 
следует переопределить этот метод. 
 - ReferenceEquals - Определяет, совпадают ли указанные экземпляры Object. В отличие от Equals, сравнивает объекты по ссылке, 
а не значению. И являются статическими, принимая два объекта для сравнения.
	Что такое объект и класс?
	Объект - это экземпляр класса имеющий поведение и состояние определенное классом. 
	
		Что делает оператор new?
	CLR требует, чтобы все объекты создавались оператором new, который вычисляет количества байт, необходимых для хранения всех 
экземплярных полей типа и всех его базовых типов.
	Для каждого объекта в куче добавляет дополнительные члены, указатель на объект (type object pointer) и индекс блока 
синхронизации (sync block index). Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого объекта
	Выдялет и резервирует необходимое количество памяти в управляемой куче. Выделенные байты инициализируются нулями (0).
	Инициализация указателя на объект-тип и индекса блока синхронизации.
	Вызов конструктора экземпляра типа с параметрами, указанными при вызове new, а так же вызывается конструктор System.Object, 
который ничего не делает, а просто возвращает управление.
	В итоге new возвращает ссылку на вновь созданный объект.

		Приведение типов
	Приведение типов - это механизм, при помощи которого мы можем преобразовать один тип в другой. C# поддерживает несколько 
видов приведения типов такие как:
	Неявные преобразования - в этом случае специального синтаксиса не требуется, например, преобразования из меньших в большие 
целочисленные типы, или	Upcusting - преобразования из производных классов в базовые классы.
	Явные привидине - если в ходе привидения данные могут быть утрачены или завершиться сбоем. Downcasting - для приведения типа к
производному от него типу. Для явных преобразований требуется выражение приведения такие как is, as, typeof или (T).
	Object o = new Employee();
	Employee e = (Employee) o;
	Пользовательские преобразования - для этого используются ключевые слова operator и implicit или explicit.
	Преобразования с использованием вспомогательных классов, таких как BitConverter, Convert, Parse, TryParse.
	
		Операторы is и as, typeof
	Оператор is проверяет совместимость объекта с данным типом и возвращает true или false и никогда не генерирует исключение. 
Для null-ссылок оператор is всегда возвращает false, так как объекта, тип которого нужно проверить, не существует.
		if (o is Employee) { Employee e = (Employee) o;	}
	Но C# предложен механизм, повышающий эффективность кода с помощью оператора as. 
		Employee e = o as Employee; 
		if (e != null) { // Используем e внутри инструкции if}
	as возвращает ненулевой указатель на этот объект, а если нет, то оператор as возвращает null. При этом верифицирует тип 
объекта только один раз, а if лишь сравнивает e с null — такая проверка намного эффективнее, чем определение типа объекта. 
	Оператор typeof получает экземпляр System.Type для указанного типа. Оператор typeof принимает в качестве аргумента: 
имя типа или параметр типа: typeof(T), typeof(List<string>), typeof(int). Аргумент может быть типом dynamic или string?


		Namespace
	Пространства имен используются для логической группировки родственных типов, чтобы разработчику было проще найти нужный тип, а
также средство, позволяющее удлинить имя типа и сделать его уникальным, добавив к началу имени групп символов, разделенных точками
	alias - В C# есть еще одна форма директивы using, позволяющая создать псевдоним для отдельного типа или пространства имен. 

		Примитивные типы
	Типы данных, которые поддерживаются компилятором напрямую, у которых существуют прямые аналоги в библиотеке классов FCL. 
Например, int - System.Int32.(s)byte, (u)short, (u)int, (u)long, float, double, decimal, bool, char, string, object, dynemic.
	Можно неявное делать приведение типа, если не будет потери данных, но если есть вероятность потери данных, то требуется 
явного приведения типа. Например из Int32 в Byte так как при больших величинах Int32 теряется точность.	

		checked и unchecked
	checked и unchecked - механизм управления проверки переполнения, при выполнени арифметических операции над примитивными типами
	checked - если требуется указать, что выражение будет проверяться на переполнение. Выдастся исключение OverflowException.
	unchecked - если требуется проигнорировать переполнение. В этом случае результат усекается, чтобы не выйти за пределы 
диапазона представления чисел для целевого типа выражения.

		Примитивный тип данных dynamic
	Тип данных dynamic позволяет опустить проверку типов во время компиляции. Кроме того, объекты, объявленные как dynamic, могут
в течение работы программы менять свой тип.	Компилятор конвертирует тип dynamic в Object и применяет DynamicAttribute к различным
частям метаданных, где это необходимо. 
	Компилятор не позволит неявно присводить тип Object к другому типу, нужно использовать явное приведение типов, но типом 
dynamic можно неявно привести к другому типу, только в таком случае CLR на этапе выполнения проверит правильность приведения с 
целью обеспечения безопасности типов. Если тип объекта несовместим с приведением, CLR выдает исключение InvalidCastException.
	Любое выражение может быть явно приведено к типу dynamic.
	dynamic можно использовать для определения аргументов типов обобщенных классов, структур, интерфейсов, делегатов или методов. 

		Ссылочные типы
	В переменных ссылочных типов хранятся ссылки на их объекты, которые хранятся в управляемой куче, а оператор new возвращает 
адрес в памяти, где размещается сам объект. 	
	Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому операции над одной переменной могут 
затрагивать другугую переменную. 
	Дополнительные члены, подлежат инициализации, незанятые полезной информацией обнуляются.
	Со временем ссылочный тип инициирует сборку мусора.	
	Сылочные типы:	class, interface, delegate, record, dynamic, object, string.
				
		Значимые типы
	Экземпляры значимый типов обычно размещаются в стеке потока, но могут быть встроены и в объект ссылочного тип. 
	Поля экземпляра размещаются в самой переменной, соответственно нет указателя на экземпляр
	Экземпляры значимых типов не обрабатываются уборщиком мусора, что ускоряет работу приложения.
	Значимые типы могут относиться к структурам (structure) и перечислениями (enumeration). Тип структуры, инкапсулирует данные 
и связанные функции, тип перечисления, определяется набором именованных констант. Структуры являются потомками абстрактного типа 
ValueType=>Object, перечисления типа Enum => ValueType => Object.
	Значимый тип является изолированным - он не может наследоваться, соответственно его методы не могут быть абстрактными и неявно
являются запечатанными, то есть их нельзя переопределить. Нельзя создавать в значимом типе новые виртуальные методы, но можно 
вызывать унаследованные виртуальные методы такие, как Equals, GetHashCode или ToString.
	Значимый тип может реализовывать интерфейсы.
	При инициализации всем членам этого типа присваивается 0. 	
	При обращении к значимому типу не может возникнуть исключение NullReferenceException.
	При присвоении переменной значимого типа присваивается другая переменная значимого типа, выполняется копирование всех ее полей
	Каждая переменная значимого типа имеет собственную копию данных «объекта», поэтому операции с одной переменной значимого типа
не влияют на другую переменную.
	Объекты значимого типа существуют в двух формах : неупакованной (unboxed) и упакованной (boxed) т.к. неупакованные значимые
типы не размещаются в куче, отведенная для них память освобождается сразу при возвращении управления методом, в котором описан 
экземпляр этого типа (в отличие от ожидания уборки мусора).
	Приведение неупакованного значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как
интерфейсные переменные являются ссылочными, а также упаковывается, при вызове реализаций методов из базового типа, таких как 
GetType или MemberwiseClone всегда требует упаковки значимого типа.

		Упаковка и распаковка значимых типов
	Упаковка (boxing) - служит для преобразования значимого типа в ссылочный. Для этого в управляемой куче выделяется память. Ее 
объем определяется длиной значимого типа и двумя дополнительными членами — указателем н объект и индексом блока синхронизации. 
	Поля значимого типа копируются в выделенную кучу и возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть
значимый тип превращается в ссылочный.

	Распаковка (unboxing) - копирование полей из упакованного объекта, который находится в куче в неупакованный объект, который 
находится в стеке потока. Для этого сначала извлекается адрес полей упакованного объекта, а далее копирвоание этих полей из кучи в
экземпляр значимого типа, находящийся в стеке. Распаковка гораздо менее ресурсозатратна, чем упаковка.
	Если переменная, содержащая ссылку на упакованный значимый тип, равна null, то генерируется исключение NullReferenceException.
	Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа, генерируется 
исключение InvalidCastException.

		Константы
	Константа является неявно статическими членами типа значение, которой никогда не меняется, и определяться во время компиляции,
а хранится в метаданных модуля. 
	Используется для упрощения чтения и сопровождения кода.
	Можно определять только примитивных типов или если присвоить ей значение null.
Константу следует использовать, только когда точно известно, что ее значение никогда не изменится, а иначе лучше использовать поля

		Поля
	Поле (field) — это член типа, который хранит экземпляр значимого типа или ссылку на ссылочный тип. 
	Поля могут быть для чтения и записи (изменяемые), или только для чтения (неизменяемые).
	Неизменность поля ссылочного типа означает неизменность ссылки, которую этот тип содержит, а вовсе не объекта, на которую 
указывает ссылка, например в массиве можно менять значения элементам.
									Модификаторы применимые к полям: 
	экземплярое	Static readonly							volatile 
					   запись в поле разрешается 		Код, обращающийся к полю, не должен оптимизироваться компилятором, 
					   только из кода конструктора.		CLR или оборудованием с целью обеспечения безопасности потоков. 
	

		Конструкторы
	Конструктор — это метод, у которого не задан тип возвращаемого значени, а сигнатура совпадает с именем типа, и служит для 
инициализации экземпляра типа и его полей.
	Конструкторы бывают двух типов: конструктор по умолчанию, без параметров, и конструктор с параметрами.
	Конструкторы могут быть экземпляров, статические и структур.
	
	Конструкторы экземпляров:
	Любые поля, не инициализированные конструктором явно, будут содержат 0 или null.
	Можно перегружать конструкторы, но количество параметров или их тип должны отличаться.
	this - позволяет явно вызвать один конструктор через другой, а base - позволяет вызывать конструктор из базового типа.
	Нельзя наследовать соответственно нельзя применять модификаторы virtual, new, override, sealed и abstract. 
	Если определить класс без явно заданных конструкторов, то будет создан конструктор по умолчанию, реализация которого просто 
вызывет конструктор без параметров базового класса, но если в базовом классе нет конструктора без параметров, производный класс 
должен явно вызвать конструктор базового класса base(), иначе компилятор вернет ошибку. 
	При вызове конструктора класса сначала выполняются конструкторы базовых классов и только затем конструкторы производных.
	В конечном счете всегда вызывается открытый конструктор объекта System.Object без параметров, который просто возвращает 
управление т.е в System.Object не определено никаких экземплярных полей.
	
	Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область
действия будет открытой (public). 
	Для статических классов (запечатанных и абстрактных) компилятор не создает конструктор по умолчанию.
	
	Cтатические конструкторы, конструкторы классов, типов или инициализаторы типов. 
	Статический конструктор служат для инициализации состояния типа или действия, которое выполняется только один раз. Он
вызывается автоматически перед созданием первого экземпляра или ссылкой на какие-либо статические члены. 
	У статического типа конструктор по умолчанию не зосздается.
	Конструкторы типов можно применять к ссылочным и значимым типам. 
	У типа не может быть более одного конструктора, а также никогда не бывает параметров.
	Конструкторы типов поумолчанию являются закрытыми и нельзя использовать модификаторы доступа.
	Код конструктора типа может обращаться только к статическим полям типа.
		
	Конструкторы структур
	Конструкторы у значимого типа можно не определять, но тогда поля будут инициализированны 0 или null.
	Конструктор экземпляра значимого типа выполняется только при явном вызове.
	Нельзя определять конструкторы для значимого типа без параметров, должен инициализировать все поля этого типа, но зависит от 
версии С# т.к в версияъ после 10+ уже можно создавать конструктор без параметров и инициализировать поля по умолчанию, а так же 
с 11 можно инициализирова не все поля, но им присвоится значение по умолчанию.
	
		Методы перегруженных операторов
	Перегруженные операторы представляют собой метод, который должен что-то сделать с объектом при применении к нему конкретного
опператора.
	Перегруженные операторные методы должны быть открытыми и статическими. 
	Тип, хотябы одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод.
	public sealed class Complex {
		public static Complex operator+(Complex c1, Complex c2) { ... }
	}
	
		Методы операторов преобразования
	Метод операторов преобразования — методы, преобразующий объект одного типа в объект другого типа. 
	Методы преобразования должен быть открытыми и статическими, далее указать implicit или explicit. implicit означает, что не 
требуется применять синтаксис явного приведения, explicit вызывает этот метод тогда, когда происходит явное приведение типов.
	operator - сообщаете компилятору, что данный метод представляет собой оператор преобразования.
	После ключевого слова operator указывается целевой тип, в который преобразуется объект, а в скобках — исходный тип объекта.
	Тип, хотябы одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод. 
		public sealed class Rational {
			public static implicit operator Rational(Int32 num) { Неявно создает Rational из Int32 и возвращает полученный объект
			return new Rational(num); }

		Методы расширения
	Позволяют определить статический метод, который вызывается при помощи синтаксиса экземплярного метода и добавлять новые методы
в уже существующие типы без создания нового производного класса.
	Метод расширения должен быть объявлен в статическом необобщенном классе.  
	Для того чтобы превратить метод в метод расширения нужно добавить ключевое слово this перед первым параметром метода и только
первый параметр может быть отмечен ключевым словом this.
	С# поддерживает только методы расширения, а не например свойства расширения.
	Методами расширениями можно расширять типы, интерфейсные типы, типов-делегатов(Action) и перечислимые типы.
	Для статических классов и структур создавать методы расширения нельзя.
	Во время поиска метода расширения компилятор просматривает все статические классы, определенные в области файла, и сканирует
их статические методы. Если существуют два и более методов расширения, должен применяться синтаксис статического метода с
указанием имени статического класса, чтобы точно сообщить компилятору, какой именно метод нужно вызвать.
	Существует потенциальная проблема с версиями. Если в будущем разработчики Microsoft добавят экземплярный метод к классу 
StringBuilder с тем же прототипом, который совпадает с пртотипом метода расширения, то после компилиляции программы, компилятор 
свяжет с программой экземплярный метод компании Microsoft вместо метода расширения 	
		public static class StringBuilderExtensions {
			public static Int32 IndexOf(this StringBuilder sb, Char value) {//код метода}}

		Частичные методы
	Ключевое слово partial говорит компилятору C#, что исходный код класса, структуры или интерфейса может располагаться в 
нескольких файлах. Компилятор объединяет все частичные файлы класса во время компиляции
	Методы объявляются только внутри частичного класса или структуры.
	Методы должны всегда иметь возвращаемый тип void (в новых версиях C# необязательно и тоже самое про модификаторы доступа).
	Объявление частичного метода и его реализующее объявление должны иметь идентичные сигнатуры.
	Не могут иметь параметров out, но может иметь параметры, помеченные ключевым словом ref, а также универсальные параметры,
экземплярные, статические или unsafe.
	Частичные методы всегда считаются закрытыми и нельзя указать явно ключевое слово private.
	Если не существует реализующего объявления частичного метода, то нельзя создать делегат, ссылающегося на частичный метод. 

		Необязательные и именованные параметры
	Необязательными параметрами являются параметры, которым присвоено значение поумолчанию, после необязательных параметров все
последующие параметры также должны быть необязательными. void M(string name, int age = 1, string company = "Undefined")
	Именованные параметры это параметры у которых указано имя параметра и через двоеточие его значение. ctor(company:"Microsoft")
	Значения по умолчанию указываются для параметров методов, конструкторов и индексаторов и делегатов. 
	Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами, кроме слова params, который должен
располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию.
	Либо если используются в правильном положении. Параметр находится в правильной позиции, но не имеет явно заданного имени.
		PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
	Ключевые слова default и new, можно использовать для параметров, чтобы проинициализировать их в первоначальное состояние.
	Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.

		Неявно типизированные локальные переменные
	Неявно типизированные локальная переменная - переменная помеченная ключевым словом var. 
	Чтобы определить ее тип, компилятор смотрит на тип выражения с правой стороны от оператора присваивания (=).
	var name = "Jeff";

		Передача параметров в метод по ссылке
	По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу
передается ссылка на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если
параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта,
а исходный экземпляр сохраняется неизменным
	Ключевые слова out, ref и in позволяеют передавать параметры по ссылке, а не по значению. 
	Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод, но
вызванный метод должен записать в него знчение, прежде чем вернуть управление. 
	Если параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод
может как читать, так и записывать значение параметра.
	Модификатор in указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение
параметра нельзя будет изменить.
	Использование ключевого слова out со значимыми типами повышает эффективность кода, так как предотвращает копирование
экземплярных полей значимого типа при вызовах методов.
	Со значимыми типами ключевые слова out и ref позволяют методу управлять единственным экземпляром значимого типа. 
	Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью. 
	В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, а вызванный код управляет этим
указателем. Т.е все изменения, выполняемые внутри метода, влияют на исходный объект, в отличии от случая передачи ссылочного типа
по значению можно менять только значения объект, но присвоение новой ссылки не повлияет на исходный объект.

		Передача переменного количества аргументов
	Примененное ключевое слова params позволяет методу принимает одномерный массив значений и может быть помечен только последний
параметр метода. 
	Что бы метод принимающий произвольное количество параметров любого типа, для этого достаточно назначить тип params Object[]. 
	Вызов метода, принимающего переменное число аргументов, снижает производительность. Чтобы уменьшить негативное влияние этих
операций на производительность, лучше определить несколько перегруженных методов, в которые не используется ключевое слово params.
	static Int32 Add(params Int32[] values) {

		Типы параметров и возвращаемых значений					
	Объявляя тип параметров метода, нужно указывать «минимальные» типы, предпочитая интерфейсы базовым классам используя интерфейс
IEnumerable<T> вместо сильного типа, List<T>. 
	В то же время, объявляя тип возвращаемого методом объекта, желательно выбирать самый сильный из доступных вариантов. 
	
		Свойства
	Свойства позволяет получить или установить состояние типа или объекта.
	Свойства могут быть статические, экземплярные, абстрактные и виртуальные. 
	Свойства могут помечаться модификатором доступа и определяться в интерфейсах.
	Свойства должны иметь имя и тип, но не void.
	Не могут быть обобщенными.
	Нельзя перегружать, то есть определять несколько свойств с одинаковыми именами, но разным типом. 
	Свойства нельзя передавать в метод в качестве параметров с ключевым словом out или ref.
	set, определяет, что свойство, доступное только для записи.
	get, определяет, что свойство, доступное только для чтения.
	Свойства могут быть доступны только для чтения/записи, в то время как поля всегда доступны и для чтения, и для записи. 
	Свойство, являясь по сути методом, может выдавать исключения, а при обращениям к полям исключений не бывает.

		Свойства с параметрами
	Индексаторы аналогичны свойствам, но позволяют обращаться к типу по индексу. Фактически позволяют работать с типом как 
с массивом. Параметры индексатора предоставляют индекс к определенным данным в коллекции.
	Для обращения к индексатору используется имя переменной и квадратные скобки. Аргументы индексатора необходимо поместить в 
квадратные скобки: var item = someObject["key"]; someObject["AnotherKey"] = item;
	Для объявления индексаторов вместо имени используется ключевое слово this, а аргументы объявляются в квадратных скобках.	
		public int this[string key]{
			get { return storage.Find(key); }
			set { storage.SetAt(key, value); }}
	У каждого индексатора должен быть хотя бы один параметр, но параметров может быть и больше. 
	У таких свойств методы доступа get получают один или несколько параметров. 	
	Тип параметров и тип возвращаемого значения может быть любым, но не войд.
	В отличие от свойств, тип может поддерживать множество перегруженных индексаторов при условии, что их сигнатуры различны.
	В одном типе можно определять несколько индексаторов при условии, что они получают разные наборы параметров				
	С# не позволяет различать свойства с одинаковыми наборами параметров и разными именами методов доступа.			
		
		Инициализаторы объектов и коллекций
	Инициализаторы объектов позволяют присваивать значения всем доступным полям и свойствам объекта во время создания без вызова
конструктора, за которым следуют строки операторов присваивания. 
		Employee e = new Employee() { Name = "Jeff", Age = 45 };			
	Реальная выгода от синтаксиса инициализатора объекта состоит в том, что он позволяет программировать в контексте выражения,
строя функции, которые улучшают читабельность кода.
		String s = new Employee() { Name = "Jeff", Age = 45 }.ToString().ToUpper();
	При инициализации коллекции можно передать несколько аргументов, для чего используется синтаксис с фигурными скобками:
		var table = new Dictionary<String, Int32> { { "Jeffrey", 1 }, { "Kristin", 2 }, { "Aidan", 3 }, { "Grant", 4 }};

		Анонимные типы
	Анонимные тип это механизм который позволяют инкапсулировать свойства только для чтения в один объект без необходимости
предварительного определения типа.
	Анонимный тип определяется с помощью ключевого слова var, оператора new и инициализатором объектов.
	Свойства анонимного объекта доступны для установки только в инициализаторе объектов.
	Анонимные типы обычно используются в select предложении выражения запроса.
		var o1 = new { Name = "Jeff", Year = 1964 };
	
		Тип System.Tuple и ValueTuple
	Tuple - это обобщенный кортежный тип который наследуется от класса Object. 
	Кортежный тип (tuple) — представляет набор значений, заключенных в круглые скобки: var tuple = (5, 10), к которым мы можем
обращаться через поля с названиями ItemПорядковыйНомер tuple.Item1, но можно дать полям имена через двоеточие.
	Можно возвращать из методов и передавать как параметр метода.
	Основные отличия ValueTuple от Tuple
	ValueTuple это значимый тип, а Tuple это ссылочный тип. Соответственно вызывается уборщих мусора.
	ValueTuple являются изменяемыми типами, а тип Tuple - неизменяемые.
	ValueTuple использет поля, а не свойства.
	
		События	
	События — это члены типа, который имеет два метода, позволяющих типу регистрировать и отменять регистрацию на событие, и 
поле-делегат для управления набором зарегистрированных методов и получения уведомлений типу на которые он подписался. Для 
объявления событие указываем модификатор доступа, ключевое слово event, тип делегата, указывающий на прототип вызываемого метода,
и имя.   public event EventHandler NewMail;  // Этап 2. Определение члена-события
	События позволяет типу отправлять уведомления статическим или экземплярным методам в ответ на изменение состояния типа или
объекта, порождающего событие. 
	Итак при возниконовении события нередко объекту нужно передать обработчику события дополнительную информацию
объектам-получателям. Для этого инкопсулируем новый класс содержащий набор данных, а в соответствии с соглашением тип должнен
наследоваться от типа EventArgs, а имя типа должно заканчиваться словом EventArgs.
	Делегат - делегирует свою работу внешнему коду и может быть параметром в методе или возвращаемым значением, а событие 
оповещает в ответ на изменение состояния типа.
	Событие не может возвращать значения и вызывается только из типа, а так же можно объявить в интерфейсе. 
	
		Обобщения
	Обобщения — механизм, для многократного использования кода, а именно многократного использования алгоритмов. Разработчик
описывает алгоритм, но не указывает типы данных, с которыми тот работает, что позволяет применять алгоритм к объектам разных типов
	Поддерживаются обобщенные: ссылочные и значимые типы, обобщенные интерфейсы, делегаты и методы определенные в ссылочном, 
значимом типе или в интерфейсе, а так же при наследовании.
	Не поддерживается обобщенные: перечислимые типы, свойства, индексаторы, события, конструкторы, деструкторы и опператорные
методы, все кроме первого могут использоваться в обобщенных типах, чтобы в их коде использовать параметры-типы этого типа.
	При определении обобщенного типа или метода переменные, указанные вместо типа T, называются параметрами типа type parameters.
T — это имя переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий тип данных. В
случае обобщенного типа или метода указанные типы данных называют аргументами-типами (type arguments).
	Преимущества обобщений:	
	Защита исходного кода. Разработчику, использующему обобщенный алгоритм, не нужен доступ к исходному тексту алгоритма.
	Безопасность типов. Попытка использования несовместимого объекта приведет к ошибке на этапе компиляции или исключению во 
время выполнения. 
	Более простой и понятный код. Поскольку компилятор обеспечивает безопасность типов, в исходном тексте требуется меньше
операция приведения типов, а такой код проще писать и сопровождать.
	Повышение производительности. До появления обобщений приходилось следить, чтобы все челны типа были совместимы с типом Object,
но тогда значимые типы, приходилось упаковать, перед вызовом членов алгоритма, что приводит к процедурам уборки мусора.
	Поскольку обобщение можно использовать для работы с конкретным значимым типом, экземпляры значимого типа могут передаваться
по значению и CLR не нужно выполнять упаковку. Операции приведения типа также не нужны, поэтому CLR не нужно контролировать
безопасность типов при их преобразовании, что также ускоряет работу кода.
	Результаты тестирования для ссылочного типа не столь впечатляющие: временные показатели и число операций уборки мусора здесь
примерно одинаковы. 

		Верификация и ограничения
	Ограничение сужает перечень типов, которые можно передать в обобщенном аргументе, и расширяет возможности по работе с этими
типами. public static T Min<T>(T o1, T o2) where T : IComparable<T> 
	Маркер where сообщает компилятору, что указанный в T тип должен реализовывать обобщенный интерфейс IComparable того же типа(T)
Благодаря этому ограничению компилятор разрешает методу вызвать метод CompareTo т.к он определен в интерфейсе IComparable<T>.
	Ограничения можно применять к параметрам типа обобщенных типов и обобщенных методов. 
	При переопределении виртуального обобщенного метода в переопределяющем методе должно быть то же число параметров-типов, а они
наследуют ограничения, заданные для них методом базового класса. Переопределяемый метод вообще не вправе задавать ограничения для
своих параметров-типов, а только может переименовывать параметры-типы. Аналогично, при реализации интерфейсного, причем эти 
параметры-типы наследуют ограничения, заданные для них методом интерфейса.
	Не поддерживается перегрузка по именам параметров типа или по именам ограничений, только по арности:
	internal sealed class AType {}
	internal sealed class AType<T> {}
	internal sealed class AType<T1, T2> {}
	К параметру-типу могут применяться следующие ограничения основное (primary), дополнительное (secondary) и/или ограничение 
конструктора (constructor constraint). 

		Основные ограничения
	Основным ограничением может быть незапечатанный ссылочный тип, за исключением Object, Array,ValueType и Void в новых версиях 
языка можно использовать Enum, Delegate, MulticastDelegate. Указывая ограничения ссылочного типа означает, мы говорим компилятору,
что заданный аргумент-тип будет относиться к типу, указанному в ограничении, либо к производному от него.
	По умолчанию, если ограничение не указано, то оно будет типа Objet, но явно задавать этот тип нельзя.
	В параметре-типе может быть только одно основное ограничения.  
	Так же существуют еще два особых основных ограничения: class и struct. сlass гарантирует, что указанный аргумент-тип является
ссылочным типом. К нему относятся все классы, интерфейсы, делегаты и массивы. struct гарантирует, что указанный аргумент-тип будет
иметь значимый тип. К нему относятся все значимые типы, и перечисления, кроме Nullable<T> т.к получилась бы рекурсия.
	
		Дополнительные ограничения 
	К дополнительным ограничениям относятся ограничения интерфейсного типа. Данное ограничение гарантирует, что указанный 
аргумент-тип будет определять тип, реализующий этот интерфейс. Можно задать ноль и более интерфейсных ограничений, соответственно
тип передаваемого параметра должен реализовывать все интерфесные ограничения и все основные ограничения, если они заданы.
	Существуют интерфйесные ограничения и ограничение параметра типа.
	Ограничением параметра типа (type parameter constraint). Позволяет задавать отношение между агрументами типа.
	Преимущество использования интерфейсного ограничения со значимым типом является: Избавляет от упаковки при передаче
экземпляров значимых типов, но, если тип аргумента объявить интерфейсом, то будет выполнена упаковка.

		Ограничения конструктора
	Ограничение конструктора гарантирует компилятору, что указанный аргумент-тип будет иметь неабстрактный тип, имеющий открытый
конструктор без параметров.	Можно задать не более одного ограничения конструктора. 
	Нельзя задавать одновременно struct(значимых типов) и new(), т.к у любой структуры есть обязательный конструктор без
без параметров и такая запись является избыточной.
		internal sealed class ConstructorConstraint<T> where T : new() {}
	
		Наследование в классах
	Наследование является одним из фундаментальных основ ООП. Оно позволяет определить производный класс, который наследует, 
возможности базового классам. В CLR у класса может быть один и только один прямой родитель, который предоставляет набор сигнатур и
реализации его методов. При этом новый класс может стать базовым для другого класса, а новый производный класс унаследует все 
сигнатуры методов и их реализации. С# каждый объект прямо или косвенно наследуется от Object, что позволяет наследовать его методы
	Наследования классов — дает возможность подстановки экземпляров производного типа в любые контексты, в которых выступают 
экземпляры базового типа Upcusting.
	Производный класс может наследовать практически все члены базового типа, кроме статического и экземплярного конструктора - их
нужно определять для каждого класса, а при помощи base() можно вызывать конструктор базового класса. 
	Модификаторы доступа
	private являются видимыми только в производных классах, которые вложены в базовый класс.
	protected члены являются видимыми только в производных классах.
	internal члены являются видимыми только в производных классах, которые находятся в той же сборке, что и базовый класс. 
	Производные классы могут также переопределять унаследованные члены, которые в базовом классе отмечены ключевым словом virtual
	А если член базового класса, отмечен ключевым словом abstract, то он обязательно должн переопределяться в производном классе
	Наследование применяется только для классов и интерфейсов. Другие категории типов (структуры, делегаты и перечисления) не 
поддерживают наследование. Класс может наследовать нольи и более интерфейсов, через указание их имен, но должен реализовать все
унаследованные методы интерфейсов. Интерфесы позволяет реализовать ограниченное множественное наследование. 

		Наследование интерфейсов
	Интерфейс представляет собой тип с набором сигнатур методов и не содержит их реализации до C#8 т.е с помощью интерфейса мы 
определяем поведение которое будет реализовано в каком-то конкртеном классе. В интерфейсах можно определять методы, события, 
свойства и индексаторы, cтатические поля и константы (начиная с версии C# 8.0)
	При определении интерфейсного типа можно указать модификатор доступа поумолчанию internal и ключевое слово interface, а в 
соответствии с соглашением имена интерфейсных типов начинаются с прописной буквы I. 
	Интерфейс может наследовать другие интерфейсы, а наследующий интерфейс класс, должен реализовать все их методы.
	Помимо наследование интерфейсов классами, интерфейсы могут насдоваться от интерфейсов, при этому интерфейсы поддерживают 
множественное насделование.
	Аналогичным образом как и классы наследование от интерфейсов позволяет подставлять экземпляры типа, реализующего интерфейс, во
все контексты, где требуются экземпляры указанного интерфейсного типа, что позволяет создавать слабосвязанные и гибкие приложения,
например DI контейнер, MOCK-тестирование.
	CLR поддерживает обобщенные интерфейсы и интерфейсные методы.
	Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался модификатором public. 
	По умолчанию интерфейсный метод является виртуальным и запечатанным, это не позволяет производному классу переопределять 
интерфейсные методы, но если явно указать метод как виртуальный, компилятор сделает его таковым и оставит незапечатанным, что 
предоставит производному классу возможность переопределять интерфейсные методы.
	Производный класс не в состоянии переопределять интерфейсные методы, объявленные запечатанными, но может повторно унаследовать
тот же интерфейс и предоставить собственную реализацию его методов. При вызове интерфейсного метода объекта вызывается реализация,
связанная с типом самого объекта.		

		Явные и неявные реализации интерфейсных методов
	Иногда нужно определить тип, реализующий несколько интерфейсов с методами, у которых совпадают имена и сигнатуры. Требуется 
определить тип, реализующий оба этих интерфейса. В этом случае нужно реализовать члены типа путем явной реализации методов так как
этот тип должен реализовывать несколько различных методов, нужно сообщить компилятору C#, какой из методов реализацию для
конкретного интерфейса.
	Чтобы создать явную реализацию интерфейсного метода (Explicit Interface Method Implementation, EIMI) нужно перед именем метода
указано имя интерфейса, в котором определен этот метод, например IDisposable.Dispose. При явной реализации интерфейсного метода в
нельзя указывать уровень доступа, по умолчанию он получит закрытый уровень доступа (private), что запрещает любому коду
использовать экземпляр класса простым вызовом интерфейсного метода. Единственный способ вызвать интерфейсный метод — обратиться 
через переменную этого интерфейсного типа.
	EIMI-метод не может быть виртуальным, а значит, его нельзя переопределить.
	Недостатками EIMI являются: также отсутствие IntelliSense-поддержки в Microsoft Visual Studio, при приведении к интерфейсному
типу экземпляры значимого типа упаковываются, EIMI нельзя вызвать из производного типа, явная реализация интерфейсного метода не
может вызываться из производного класса.	
	
		Обобщенные интерфейсы
	Обобщенный интерфейс - это механиз который позволяет не указывать аргумент-тип, а только описать набор сигнатур, а уже в 
ссылочном или значимом типе, который реализуют обобщенный интерфейс указать этот аргументов-типов. Любая попытка работы со
значимым типом через необобщенный интерфейс, будет приводить к необходимости упаковки и потере безопасности типов, cоответственно
	Обеспечивают безопасность типов на стадии компиляции. 
	При работе со значимыми типами требуется меньше операций упаковки. 
	Класс может реализовать один интерфейс многократно, просто используя параметры различного типа.
	Параметры интерфейса обобщенного типа могут быть также помечены как контравариантые или ковариантные, что позволяет более
гибко использовать интерфейсы
			
		Дилемма разработчика: базовый класс или интерфейс?
	Любой тип может наследовать только одну реализацию, но если нужно реализовать подобие множественного наследования или 
слабосвязаное, гибкое приложение, например, DI контейнер или MOCK-объект, а так же значимые типы не могут наследоваться от 
произвольного базового класса, то в этом случае нужно определять интерфейс.
	Иногда проще определить новый тип, производный от базового, чем создать интерфейс. Базовый тип может предоставлять массу
функций, и в производном типе потребуется внести лишь незначительные изменения, чтобы изменить его поведение. При создании
интерфейса в новом типе придется реализовывать все члены.
	Управление версиями. 
	Когда вы добавляете метод к базовому типу, производный тип наследует стандартную реализацию этого метода
без всяких затрат. Пользовательский исходный код даже не нужно перекомпилировать. Добавление нового члена к интерфейсу трребует
изменения пользовательского исходного кода и его перекомпиляции
Для интерфейса придется менять и добавлять реализацию в каждого наследника, а следовательно, и перекомпилировать. Особенно сильно 
это влияет, если меняется интерфейс в библиотеке, которая используется в различных проектах. Для базового класса — такой проблемы
нет. Наследники просто принимают изменения базового типа и их даже не нужно перекомпилировать.

		Абстрактный класс
	Абстрактный класс - это класс с модификатором abstract, который указывает, что класс предназначен только для использования в 
качестве базового класса и не должен быть создан сам по себе, а его члены имеют отсутствующую или неполную реализацию. 
	Абстрактные классы могут быть наследованы от базвого класса и могут переопределять виртуальные методы.
	Абстрактные классы могут быть наследованы от интерфейса и сопоставлять методы интерфейса с абстрактными методами.
	Абстрактные типы могут содержать абстрактные методы, свойства, индексаторы и события
	Абстрактный класс может иметь не абстрактные переменные, методы, конструкторы, свойства.
	При переопределении в производном классе абстрактный метод или свойство объявляются с модификатором override. Если класс имеет
хотя бы одный абстрактный член, то этот класс должен быть определен как абстрактный.

		Дилемма разработчика: абстрактный класс или интерфейс?
	Когда следует использовать абстрактные классы:
	Если надо определить общий функционал для родственных объектов, чтобы все производные классы на всех уровнях наследования
имели некоторую общую реализацию. 
	При использовании абстрактных классов, если мы захотим изменить базовый функционал во всех наследниках, то достаточно поменять
его в абстрактном базовом классе. А в случае с интерфейсом, придется вносить изменения и также во всех классах, которые данный
интерфейс реализуют.
	Когда следует использовать интерфейсы:
	Если нам надо определить функционал для группы разрозненных объектов, которые могут быть никак не связаны между собой.
	Если мы проектируем небольшой функциональный тип.
	Допустим, у нас есть система транспортных средств: легковой автомобиль, автобус, трамвай, поезд. Поскольку данные объекты 
являются родственными, мы можем выделить у них общие признаки, то в данном случае можно использовать абстрактный класс, например,
Vehicle, который определяет абстрактный метод перемещения Move(), а классы-наследники его реализуют, но если объекты малосвязанные
между собой, то для определения общего для всех них функционала лучше определить интерфейс.
	Говоря об использовании абстрактных классов и интерфейсов можно привести еще такую аналогию, как состояние и действие. 
Как правило, абстрактные классы фокусируются на общем состоянии классов-наследников. В то время как интерфейсы строятся вокруг
какого-либо общего действия.
	Абстрактные классы можно комбинировать вместе т.к абстрактный класс может наследоваться от интерфейсов.

		Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах
	Каждый из параметров-типов обобщенного делегата должен быть помечен как ковариантный или контравариантный. Благодаря этому 
можно выполянть приведение экземпляров обобщенного делегата к тому же типу делегата, но с другим параметром-типом. 
	Параметры-типы могут быть:
	Инвариантными - параметр-тип не может изменяться и данныйх подход используется по умолчанию.
	Контравариантными - параметр тип может быть преобразован к производному классу от него и обозначается ключевым словом in и 
может появляться только во входной позиции, например, в качестве параметра метода.
	Ковариантными - параметр-тип может быть преобразован к базовому классу и обозначается ключевым словом out и может появляться 
только в выходной позиции, например, возвращаемого значения метода.
	Нельзя использовать инвариантность с ключевыми словами ref и out
			
		Методы
	Метод это член типа, который содержит ряд инструкий. Сигнатура метода может иметь модификатор доступа, virtual и другие, 
тип возвращаемого значения, имя метода, а так же передаваемые параметры. Тип возврата метода не является частью сигнатуры метода
в целях перегрузки метода, а только для делегата. 
	Метод может быть экземплярным либо статическим, для вызова экземплярного нужно создать объект.
	Метод можно вызывать, используя и позиционные, и именованные аргументы. Позиционные аргументы могут следовать за именованными
аргументами, только если именованные аргументы находятся в правильных позициях.
	Методы помеченные virtual, abstract можно переопределять в наследниках при помощи override.
	При передаче параметров по значению изменение значимого типа в методе не повлияет на исходный объект, а изменения значения 
ссылочного повлияет, кроме изменения ссылки.
	При передаче параметров по ссылке используя ключевые слова ref, out, in ипспользуются, когда нужно изменить значение аргумента
в методе и сохранить это изменение после того, как управление вернется вызывающему методу, кроме in.
	Параметры метода поддержиают: params одномерный массив параметров, default(SomeType) необязательные параметры, new ValType(),
где ValType — это тип значения. Если метод содержит как обязательные, так и необязательные параметры, необязательные параметры
определяются в конце списка параметров после всех обязательных параметров.
	Возвращаемые значения: если указан тип возвращаемого значения, то метод может вернуть его при помощи return, а если тип void,
инструкцию return без значения по-прежнему можно использовать для завершения выполнения метода. Без ключевого слова return этот
метод будет останавливать выполнение при достижении конца блока кода.
	В некоторых случаях нужно, чтобы метод возвращал больше одного значения. Это можно легко сделать, используя типы кортежей и
литералы кортежа.
	Если метод передает массив в качестве аргумента и изменяет значение отдельных элементов, метод не требуется для возврата
массива т.к. C# передает все ссылочные типы по значению, а значением ссылки на массив является указатель на массив.
	Так же есть методы расширения, частичные методы, методы операторов преобразования, методы перегруженных операторов.
	Обобщенные методы: все методы, определенные в обобщенных типах, могут использовать их параметр-тип. Параметр-тип может
использоваться для параметров метода, возвращаемого значения и типа заданной внутри него локальной переменной, а так же метод
может иметь собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных.
Использование обобщенных типов с методами, получающими параметры out и ref, должны быть того же типа, что и параметр метода, чтобы
избежать возможного нарушения безопасности типов.

		Асинхронные методы
	Асинхронные методы - это метод помеченый модификатором async, который означает, что в этом методе можно использовать 
инструкцию await, когда элемент управления достигает выражения await в асинхронном методе, элемент управления возвращается
вызывающему объекту, если ожидающая задача не завершена, то ход выполнения метода с ключевым словом await приостанавливается до
завершения ожидаемой задачи. После завершения задачи можно возобновить выполнение в методе.	Асинхронный метод обычно имеет тип
возвращаемого значения Task<TResult>, Task, IAsyncEnumerable<T> или void, который в основном используется для определения
обработчиков событий, где требуется возвращать тип void, а также вызывающий объект метода не может перехватывать исключения,
которые выдает этот метод.
	Асинхронный метод не может объявлять параметры in, ref или out, но может вызывать методы, имеющие такие параметры.

		Символы
	Символы в .NET Framework всегда представлены 16-разрядными кодами стандарта Юникод и являются экземпляром структуры Char, тип
System.Char содержит два открытых неизменяемых поля: константа MinValue MaxValue.
	Для облегчения работы с типом Char имеется несколько статических методов также несколько собственных экземплярных методов
	Есть три способа преобразования различных числовых типов в экземпляры типа Char, и наоборот: приведение типа, использование 
типа Convert, который содержит несколько статических методов, или использование интерфейса IConvertible, котором определены такие
методы, как ToUInt16 и ToChar.
	 
		Строки
	System.String — представляет неизменяемый упорядоченный набор символов, являясь прямым потомком Object, он является ссылочным
типом, всегда размещаются в куче. String относится к примитивным типам, то есть компилятор разрешает вставлять литеральные строки
непосредственно в исходный код. Компилятор помещает эти литеральные строки в метаданные модуля, откуда они загружаются и
используются во время выполнения.
		String s = "Hi" + " " + "there."; 	// Конкатенация трех литеральных строк образует одну литеральную строку
	Конкатенацию литаральных строк, компилятор выполняет на этапе компиляции, а в метаданных модуля помещается строка "Hi there."
	Конкатенация нелитеральных строк происходит на этапе выполнения, соответственно ее применять нежелательно, так как он создает
в куче несколько строковых объектов. Рекомендуется использовать тип System.Text.StringBuilder.
	Знак доллара перед строкой указывает, что будет осуществляться интерполяция строк. Внутри строки используются плейсхолдеры {},
а внутри фигурных скобок уже можно напрямую писать те выражения, которые мы хотим вывести. $"Имя: {name}  Возраст: {age}"
	буквальные строки (verbatim strings) — используют при задании пути к файлу или каталогу и при работе с регулярными выражениями
		String file = "C:\\Windows\\System32\\Notepad.exe"; 				String file = @"C:\Windows\System32\Notepad.exe";
	Неизменяемые строки - объект String является неизменяем; то есть созданную однажды строку нельзя сделать длиннее или короче,
в ней нельзя изменить ни одного символа. Неизменность строк дает определенные преимущества такие как:
	Для начала можно выполнять операции над строками, не изменяя их.
	Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. 
	В CLR несколько ссылок String могут указывать на один, а не на несколько разных строковых объектов, если строки идентичны. А
значит, можно сократить количество строк в системе и уменьшить расход памяти — это именно то, что непосредственно относится к
интернированию строк (string interning).
	Сравнение строк - операторы равенства == и != по определению сравнивают не ссылки, а значения объектов string.
	Необработанные строковые литералы - доступны начиная C#11 содержат произвольный текст, не требуя escape-последовательностей. 
Необработанные строковые литералы заключены как минимум в три двойные кавычки (""").
	Интернирование строк - если в приложении строки сравниваются часто методом порядкового сравнения с учетом регистра или если в
приложении ожидается появление множества одинаковых строковых объектов, то для повышения производительности надо применить
механизм интернирования строк (string interning). При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами являются
строки, а значениями — ссылки на строковые объекты в управляемой куче. Вначале таблица, разумеется, пуста. В классе String есть
два метода, предоставляющие доступ к внутренней хеш-таблице:
		String Intern(String str);  					 String IsInterned(String str);
	Intern, ищет String во внутренней хеш-таблице. Если строка обнаруживается, возвращается ссылка на соответствующий объект
String. Иначе создается копия строки, она добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию. Если приложение
больше не удерживает ссылку на исходный объект String, уборщик мусора вправе освободить память, занимаемую этой строкой. 
	IsInterned получает параметр String и ищет его во внутренней хеш-таблице. Если поиск удачен, IsInterned возвращает ссылку на
интернированную строку. В противном случае он возвращает null, а саму строку не вставляет в хеш-таблицу.
	Создание пулов строк - чтобы не допустить роста объема кода, многие компиляторы хранят литеральную строку в метаданных модуля
только в одном экземпляре. Все упоминания этой строки в исходном коде компилятор заменяет ссылками на ее экземпляр в метаданных. 
	
		StringBuilder
	Тип StringBuilder в отличие от String представляет изменяемую строку. Это значит, что изменение содержимого экземпляра SB, не 
создает новых объектов, размещаемых в управляемой куче. StringBuilder выделяет память для новых объектов только в двух случаях:
	при динамическом построении строки, размер которой превышает установленную емкость;
	при вызове метода ToString типа StringBuilder.	
	У объекта StringBuilder предусмотрено поле со ссылкой на массив структур Char. Используя члены StringBuilder, можно эффективно
манипулировать этим массивом, сокращая строку и изменяя символы строки. При увеличении строки, представляющей ранее выделенный
массив символов, StringBuilder автоматически выделит память для нового, большего по размеру массива, скопирует символы и приступит
к работе с новым массивом. А прежний массив попадет в сферу действия уборщика мусора. 
	Вызвов метода ToString типа StringBuilder преобразовывает массив символов StringBuilder в объект String. Этот метод возвращает
просто ссылку на строку. Поскольку массив символов здесь не копируется, метод выполняется очень быстро.
	У типа StringBuilder несколько конструкторов. Задача каждого из них — выделять память и инициализировать три внутренних поля,
управляемых любым объектом StringBuilder: 
	Максимальная емкость (maximum capacity) по умолчанию оно равно Int32.MaxValue.
	Емкость (capacity) — поле типа Int32, показывающее размер массива символов StringBuilder. По умолчанию оно равно 16. 
	Массив символов (character array) — массив структур Char, содержащий набор символов «строки». 
	
		Форматирование нескольких объектов в одну строку
	String s = String.Format("On {0}, {1} is {2} years old.", new DateTime(2012, 4, 22, 14, 35, 5), "Aidan", 9); 

		Перечислимые типы
	Перечислимым (enumerated type) называют тип, в котором описан набор пар, состоящих из символьных имен и значений т.е это 
обычная структура, внутри которой описан набор константных полей и одно экземплярное поле. Константные поля попадают в метаданные
сборки. Программу, где используются перечислимые типы, проще написать и понять, а у разработчиков возникает меньше проблем с ее 
сопровождением т.кпрограммист видит осмысленные символьные имена, а не цифры. Перечислимые типы подвергаются строгой проверке 
типов. Например,компилятор сообщит об ошибке, если в качестве значения я попытаюсь передать методу тип Color.Orange, когда метод 
ожидает перечислимый тип Fruit (фрукт).	
	Перечислимые типы относятся к значимым типам и наследуется от типа Enum <= ValueType <= Object.  
	Перечислимого типа не может быть методов, свойств и событий, но методы можно имитировать при помощи методов расширения.
	При компиляции перечислимого типа компилятор C# превращает каждый идентификатор в константное поле типа.
	В основе любого перечисления лежит один из основных типов, например (s)byte, (u)short, int используется по умолчанию и (u)long
	Компилятор C# считает перечислимые типы примитивными, поэтому для операций с их экземплярами можно применять операторы	(==, 
!=, <, >, <=, >=, +, –, ^, &, |, ~, ++ и ––).
	Компилятор C# допускает приведение экземпляров одного перечислимого типа к другому. 
	Также поддерживается явное и неявное приведение к числовому типу.
	Имеющийся экземпляр перечислимого типа можно связать со строковым представлением — для этого следует вызвать ToString, 
унаследованный от System.Enum: 	public static Array GetValues(Type enumType) и 	public Array GetEnumValues(); 
	Этот метод вместе с методом ToString позволяет вывести все идентификаторы и числовые значения перечисления
				
		Битовые флаги	
	Перечиления можно использовать для создании битовых флагов, благадаря этому экземпляр enum может иметь комбинацию значений
констант, определенных в списке. Для создания перечисления с битовым флагом нужно добавить атрибут [Flags] или [FlagsAttribute]
	Определяя перечислимый тип, битовыми флагами, каждому идентификатору следует явно присвоить числовое значение. 
	Стоит добавлять идентификатор None, значение которого определено как 0. 
	Константы должны быть степенями двойки - это гарантирует, что комбинации флагов не будут перекрываться.
	Если есть часто используемые комбинации флагов, то их можно добавить в перечисление.
	Стоит использовать только положительные константы, чтобы не вводить никого в заблуждение.
	Т.к константы должны содержать степень двойки, то можно задавать их несколькими способами: двоичными литералами, 
числовым литераом с операцией сдвига, десятичными числами и шестнадцатиречными.
	Для комбинирования, сброса и проверки флагов используются битовые операции.	Битовые маски широко используются в среде .Net,
в частности для указания привязки объектов к контейнерам и определения уровня доступа к файлам, это лишь малая часть из 
перечислений которые входят в состав .Net Framework.

		Массивы
	Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию. 
	Поддерживает одномерные (single-dimension), многомерные (multidimension) и нерегулярные (jagged) массивы. 
	Базовым для всех массивов является абстрактный класс System.Array, производный от System.Object и являются ссылочным типом и
размещаются в управляемой куче, а переменная в приложении содержит не элементы массива, а ссылку на массив.			
	По возможности нужно ограничиваться одномерными массивами с нулевым начальным индексом, которые называют векторами. 
	Векторы обеспечивают наилучшую производительность, т.к для операций с ними используются команды промежуточного языка (IL).
	Для многомерных массивов характерным есть ранг т.е количество измерений. Двумерный массив – это таблица, трехмерный – куб и тд
	Доступ к элементам осуществляется посредством двух и более индексов
		Double[,] myDoubles = new Double[10, 20]; // Создание двухмерного массива типа Doubles
	Нерегулярные (jagged) массивы — то есть «массивы массивов». Производительность одномерных нерегулярных массивов с нулевым 
начальным индексом такая же, как у обычных векторов. Однако обращение к элементу нерегулярного массива означает обращение к двум
или больше массивам одновременно. Point[][] myPolygons = new Point[3][] // Создание одномерного массива из массивов типа Point
	Чтобы привести массив к другому оба типа массивов должны иметь одинаковую размерность; кроме того, должно иметь место неявное
или явное преобразование из типа элементов исходного массива в целевой тип. 
	CLR не поддерживает преобразование массивов с элементами значимых типов в другие типы, но можно обойти это ограничение при
помощи метода Array.Copy, который создает новый массив и заполняет его элементами.
	В CLR поддерживаются массивы двух типов:
	Доступ к элементам одномерного массива с нулевой нижней границей осуществляется немного быстрее, чем доступ к элементам
многомерных массивов или массивов с ненулевой нижней границей. т.к в этом случае код проверки индекса не выносится за пределы
цикла и проверка осуществляется на каждой итерации. Кроме того, компилятор добавляет код, вычитающий из текущего индекса нижнюю
границу массива.

		Делегаты
	 Делегат (delegates) - функциями обратного вызова, которая обеспечивает безопасность типов при выполнении обратного вызова
методов, а так же позволяют последовательно вызовать нескольо методов.
	Делегаты могут вызывать статическин и экземплярные методоы.	
		internal delegate void Feedback(Int32 value);// Объявление делегата; 
	Делегаты определяются при помощи ключевого слова C# delegate, а оператор new создает экземпляр делегата.
	Сигнатура метода должна быть совместима с сигнатурой делегата - это означает что оба типа должны принимать один и тот же
аргумент и возвращать значение одного и тогоже типа.
	делегаты могут быть параметрами методов, а так же можно возвращать из методов.
	Класс делегата, определенный компилятором, содержит четыре метода: конструктор, а также методы Invoke, BeginInvoke и EndInvoke
	Делегаты можно определять как внутри класса (вложенные в другой класс), так и в глобальной области видимости. По сути, т.к 
делегаты являются классами, их можно определить в любом месте, где может быть определен класс.
	Класс MulticastDelegate является производным от класса Delegate, который, в свою очередь, наследует от класса System.Object.	
	Делегаты поддерживают ковариантность и контравариантность ссылочных типов при привязке метода к делегату. 			
	Обратный вызов нескольких методов (цепочки делегатов) Цепочкой (chaining) называется коллекция делегатов, дающая возможность
вызывать все методы, представленные этими делегатами. Для этого есть перегруженные версии операторов += и -= для экземпляров
делегатов. Эти операторы вызывают методы Delegate.Combine и Delegate.Remove соответственно.
	Если делегат возвращает некоторое значение, то возвращается значение последнего метода из списка вызова, в качестве
альтернативы можно воспользоваться экземплярным методом GetInvocationList класса MulticastDelegate. Этот метод позволяет в
явном виде вызвать любой из делегатов в цепочке:	
	Можно не определяем метод обратного вызова, а подставить реализацию метода обратного вызова непосредственно в код, а не в
отдельный метод. Скажем, наш код можно записать так:  ThreadPool.QueueUserWorkItem( obj => Console.WriteLine(obj ), 5);
							
		Обобщенные делегаты	
	При определении типа делегата с параметрами типа компилятор задает методы класса делегата, а параметры типа применяются ко
всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.		
	В .NET Framework имеются 17 делегатов Action, от не имеющих аргументов вообще до имеющих 16 аргументов. Кроме делегатов 
Action имеется 17 делегатов Func, которые позволяют методу обратного вызова вернуть значение. Но, если нужно передать аргумент по
ссылке, используя ключевые слова ref или out, может потребоваться определение собственного делегата:
	delegate void Bar(ref Int32 z);
	Аналогично нужно действовать в ситуациях, когда требуется передать делегату переменное число параметров при помощи ключевого
слова params
	Поддержка обобщенных делегатов в CLR позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом
безопасность типов. Более того, благодаря обобщенным делегатам экземпляры значимого типа могут передаваться методам обратного
вызова без упаковки. 

		Настраиваемые атрибуты
	Настраиваемые атрибуты представляют собой средство передачи дополнительной информации, которая хранится в метаданных 
управляемого модуля. Атрибуты могут применяться как ко всему типу: классу, интерфейсу и т.д., так и к отдельным его частям:
методу, свойству и т.д. Чтобы применить атрибут для этого нужно имя атрибута поместить в квадратные скобки перед именем класса или
другим членом типа.
	Можно применить один или несколько атрибутов ко всей сборке, к модулю или к более мелким элементам программы, например к
классам и свойствам. Атрибуты могут принимать параметры, также как методы и свойства. Можно явным образом указать target - целевой
объект атрибута, например, что атрибут применяется к методу, параметру или возвращаемому значению. А при помощи отражения можно
получать сведения атрибутов, которые применены к объекту, используя метод GetCustomAttributes.
	Настраиваемый атрибут — это экземпляр класса, который должен прямо или косвенно наследовать от абстрактного класса Attribute и
должен иметь открытый конструктор для создания экземпляров. 
			
		Null-совместимые значимые типы
	Класс System.Nullable<T> - это структура, которая позволяет принимать значимым типам значение null, а ее экземпляры могут
размещаться в стеке потока. Часто используется в связке с БД, т.к переменные, которые она может возвращать, могут быть равны null.
Но следует учесть, что операции с Nullable типом выполняются медленнее аналогичных операций с другими значимыми типами.
	Структура Nullable<T> имеет два свойства: Value - возвращает значение объекта и HasValue: возвращает true или false, если
объект равен null. В качестве параметра T могут использоваться только структуры, но можно использовать упращенный синтаксис
воспользовавшись знаком вопроса: Int32? y = null;
	Можно выполнять преобразования и приведение экземпляров Nullable типов к другим типам.
	Можно применять операторы к экземплярам null-совместимых значимых типов. Но следует учитывать, что если в операции участвует
nullable-тип, то результатом также будет значение nullable-типа и если один из операндов равен null, то результатом операции
также будет null, а в операциях сравнения, если хотя бы один из операндов равен null, то возвращается false.: 
	int? x = 5;		int z = x + 7; - нельзя; int? w = x + 7; - можно; int d = x.Value + 7; - можно
	int? x = null;  int? w = x + 7; // w = null
	Можно использовать is с шаблоном типа, чтобы проверить и получить значение базового типа или свойство HasValue: int? a = 42;
	var str = (a is int valueOfA) ? $"a is {valueOfA}" : "a does not have a value";
	var str = (а.HasValue) ? $"a is {valueOfA}" : "a does not have a value";
	Можно использовать оператор объединения null-совместимых значений ?? и ??= Если левый операнд не равен null, оператор
возвращает его значение. В противном случае возвращается значение правого операнда
	Упаковка null-совместимых значимых типов 
	Если в переменную типа Nullable<Int32> присвоено значение null, то для передачи этой переменной ссылочному типу, ее следует
упаковать и передать ссылку на упакованный тип Nullable<Int32>. При упаковке экземпляра Nullable<T> проверяется его равенство но 
null, но в случае положительного результата вместо упаковки возвращается null. Но если присвоено значение отличное от null,
например 5, то тип Nullable<Int32> упаковывается в тип Int32 с аналогичным значением.
	Распаковка null-совместимых значимых типов
	Упакованный значимый тип T распаковывается в T или в Nullable<T>. Если упакованный значимый тип равен null, то и при
выполннении распаковки в тип Nullable<T> присваивоится значение null, а в T исключение NullReferenceException. 
	При вызове метода GetType для объекта типа Nullable<T> CLR возвращает тип T вместо Nullable<T>, а так же будет произведена 
упаковка. Поэтому для определения int или int? нужно использовать связку Nullable.GetUnderlyingType и оператор typeof
	bool IsNullable(Type type) => Nullable.GetUnderlyingType(typeof(int?)) != null;
								
		Механика обработки исключений
	Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а иногда и вовсе невозможно.При
обработке исключений используются ключевые слова try, catch и finally для действий, которые могут оказаться неудачными. Например,
при передачи файла по сети может неожиданно оборваться сетевое подключение или просто нужно закрыть сетвеое подключение или файл.
private void SomeMethod() {
try { // Код, требующий корректного восстановления или очистки ресурсов}
catch (InvalidOperationException) { // Код восстановления работоспособности после исключения InvalidOperationException}
catch (IOException) { // Код восстановления работоспособностипосле исключения IOException}
catch {Код восстановления работоспособности после остальных исключений - их обычно генерируют повторно.
	throw;}
finally { // Код, выполняющий очистку ресурсов после операций, начатых в блоке try. Он выполняется ВСЕГДА}
	// Код, следующий за блоком finally, выполняется, если в блоке try не генерировалось исключение или если исключение было 
перехвачено блоком catch, а новое не генерировалось
}
	Блок try
	В блок try помещается код, требующий очистки ресурсов или восстановления, после исключения, а сам код очистки содержится в
блоке finally. Так же может располагаться код, приводящий к генерации исключения. Код же восстановления вставляют в один или
несколько блоков catch.
	Блок try должен быть связан хотя бы с одним блоком catch или finally; сам по себе он не имеет смысла иначе будет ошибка.
	Когда внутри такого блока try возникает исключение, поток управления переходит к первому подходящему обработчику исключений в
стеке вызовов. Если для созданного исключения не существует обработчиков, выполнение программы прекращается с сообщением об ошибке
	Один блок try может быть вложен ноль и больше блоков try. Исключение, генерируемое во внутреннем блоке try и не перехваченное
в соответствующем блоке catch, передается во внешний блок try.
	Блок catch
	В блок catch помещают код, который должен выполняться в ответ на исключение. Выражение в скобках после ключевого слова catch
называется типом исключения (catch type). Один блок catch соответствует одному событию, после которого может потребоваться
восстановление приложения. 
	Поиск подходящего блока catch осуществляется сверху вниз, поэтому сначала следуют потомки с наибольшей глубиной наследования,
потом — их базовые классы и, наконец, — класс Exception или блок с неуказанным типом исключений.
	При обнаружении блока catch нужного типа выбирается способ восстановления после исключения. Еще раз сгенерировать то же
исключение для передачи информации о нем коду, расположенному выше в стеке;	Сгенерировать исключение другого типа для передачи
дополнительной информации коду, расположенному выше в стеке; позволить программному потоку выйти из catch естественным образом.
	В последнем же случае происходит переход к блоку finally (если он, конечно, существует). После выполнения всего содержащегося
в нем кода, управление переходит к расположенной после блока finally инструкции. Если блок finally отсутствует, поток переходит к
инструкции, расположенной за последним блоком catch. 
	В C# после типа перехватываемого исключения можно указать имя переменной, которая будет ссылаться на сгенерированный объект,
потомок класса System.Exception. В коде блока catch эту переменную можно использовать для получения информации об исключении .
	Если код в блоке try не порождает исключение, CLR никогда не переходит к выполнению кода блоке catch, а сразу переходя к коду
блока finally, если таковой существует. Выполнив код блока finally, поток переходит к инструкции, следующей за этим блоком.
	Фильтры исключений
	Фильтры исключений позволяют обрабатывать исключения в зависимости от определенных условий. Для их применения после выражения
catch идет выражение when, после которого в скобках указывается условие: catch (DivideByZeroException) when (y == 0) {cw("0");}
	Блок finally
	Код блока finally выполняется всегда. Обычно этот код производит очистку после выполнения блока try. Если в блоке try был
открыт некий файл, блок finally должен содержать закрывающий этот файл код, а если код блока try выполняется без исключений, файл
закрывается. 
	Блок try может существовать и без блока finally его следует поместить после всех блоков catch. Одному блоку try может
соответствовать только один блок finally.
	Явное создание исключений исключение можно вызвать явным образом с помощью C# throw new exceptOb;
	Перехваченное исключение можно вызвать повторно с помощью оператора throw;

		Создание пользовательских исключений
	Можно создавать собственные классы исключений для этого нужно создайть сериализуемый класс, который наследует от Exception, а
имя класса должно заканчиваться на Exception. Классы должн определять три конструктора:
    public InvalidDepartmentException() : base() { } один конструктор без параметров, 
    public InvalidDepartmentException(string message) : base(message) { } свойство сообщения
		и тот, который задает как свойство сообщение так и InnerException свойство.
    public InvalidDepartmentException(string message, Exception inner) : base(message, inner) { }
	Определите любые дополнительные свойства и конструкторы которые бутут хранить дополнительную информацию.
	При добавлении новых свойств в производный класс исключений необходимо переопределить метод ToString() чтобы он возвращал
добавленные сведения.	
	При использовании инструкций lock, using и foreach блоки try/finally создаются автоматически. Компилятор строит эти блоки и
при переопределении деструктора класса метод Finalize.
	При работе с упомянутыми конструкциями написанный вами код помещается в блок try, а код очистки — в блок finally. А именно:
	если вы используете инструкцию lock, то внутри блока finally снимается блокировка;
	если вы используете инструкцию using, то внутри блока finally для объекта вызывается метод Dispose;
	если вы используете инструкцию foreach, то внутри блока finally для объекта IEnumerator вызывается метод Dispose;
	если вы определяете деструктор, то внутри блока finally вызывается метод Finalize базового класса
					
		Корректное восстановление после исключения
	Нужно использовать блоки try/catch/finally для восстановления после ошибок или высвобождения ресурсов.
	Обработка общих условий без выдачи исключений. Для условий, которые могут возникнуть, но способны вызвать исключение,
рекомендуется реализовать обработку таким способом, который позволит избежать исключения. Например, если попытаться закрыть уже
закрытое подключение, вы получите InvalidOperationException. Этого можно избежать, используя оператор if для проверки состояния
подключения перед попыткой закрыть его.	Если вы не проверяете состояние подключения перед закрытием, можно перехватить
InvalidOperationException исключение блоком catch.
	Можно использовать специальные методы или свойства предоставляемые классом, чтобы недопустить возниконовения исключения. 
Например при чтении из файла, определять, достигнут ли конец файла.
	Необработанные исключения - если ни один из блоков catch не отвечает типу исключения, возникает необработанное исключение 
(unhandled exception). Обнаружив в процессе поток с необработанным исключением, CLR немедленно уничтожает этот поток. 
Необработанное исключение указывает на ситуацию, которую не предвидел программист, и должно считаться признаком серьезной ошибки.
		
		Потоки
	Первые операционные системы не поддерживали концепцию потоков. Соответственно задачи которые выполнялись длительное время
приостанавливали выполнение других задач, либо приводили к ошибки и проходилось перезагружать систему. Поэтому для решения этих
проблем были придуманы потоки и процессы. Каждому процессу выделяется собственный поток исполнения, который работает как
виртуальный процессор. Если код приложения войдет в бесконечный цикл, то блокируется только связанный с этим кодом процесс, 
а остальные процессы продолжают функционировать.
	Процесс - набор ресурсов, используемый отдельным экземпляром приложения и имеет собственно виртуальное адресное пространство,
что гарантирует, что код и данные одного процесса будут изолированы для другого
	Различие между процессом и потоком: поток и процесс служать для разделения работы, но поток стоит выбирать для легковесных
операций, в то время как процесс для тяжелых операций. Каждый процесс имеет собственное виртуальное пространство с набором
ресурсов, а инициализированный поток использует эти ресурсы. Обменн даных между потоками в рамках одного процесса быстрее, чем у
отдельных процессов.
	Переключения контекста (context switching) - механизм который позволяет распределять физический процессор между всеми своими
потоками путем переключения контекста на другой поток. После переключения контекста процессор исполняет выбранный поток, пока не
истечет выделенное потоку время, после этого снова происходит переключение контекста. Переключение контекста повышает надежность
системы и скорость реагирования на действия конечных пользователей, хотя за это приходится платить снижением производительности.
Если поток какого-то приложения зацикливается, то Windows его периодически выгружает и передает процессору другой поток для
исполнения. Процесс в результате прекращает свою работу, теряя несохраненные данные, но остальные процессы в системе продолжают
функционировать, как ни в чем не бывало. 
	Приоритет потоков - лучше снизить приоритет одного потока, чем повысить приоритет другого. Повышать приоритет имеет смысл,
если поток должен быстро отреагировать на какое-то событие, запуститься на короткий промежуток времени и вернуться в состояние
ожидания.				
	Фоновые и активные потоки -	в CLR все потоки делятся на активные (foreground) и фоновые (background). При завершении активных
потоков в процессе CLR принудительно завершает также все запущенные фоновые потоки. Следовательно, активные потоки
имеет смысл использовать для исполнения заданий, которые обязательно требуется завершить. Фоновые же потоки можно оставить для
некритичных задач, как пересчет ячеек электронных таблиц или индексирование записей. Поток можно превращать из активного в фоновый
и обратно. Основной поток приложения и все потоки, в явном виде созданные путем конструирования объекта Thread, по умолчанию
являются активными. А вот потоки из пула по умолчанию являются фоновыми.

		Способы создания потоков.
	Первый способ используя явное создание потока при помощи Thread, для создания которого следует передать конструктору имя
метода, а для запуска потока нужно вызвать метод Start. Сигнатура метода должна совпадать с сигнатурой делегата с параметром 
либо без:	delegate void ParameterizedThreadStart(Object obj);
	Потоки, созданные путем конструирования объекта Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию
являются фоновыми. 
	Недостатком является то, что для каждого отдельного задания нужно создавать новый поток и нельзя переопределить для потока 
новое задание, что приводит к проблеме производительности.
	Второй способ использовать пул потоков.
	Среда CLR способна управлять собственным пулом потоков.	Если в один процесс загружаются несколько экземпляров CLR, для каждого
из них формируется собственный пул. Итак, при инициализации CLR пул потоков пуст, пока не появится запрос, который помещается в 
очередь пула потоков. Далее код пула извлекает запросы из очереди и распределяет их среди потоков из пула. Если у пула нет потока,
то создается новый поток, а при завершении исполнения своего задания поток не уничтожается, а возвращается в пул в ожидание 
следующего запроса это позволяет повысить производительность, но если приложение отправляет пулу много запросов, которые он не 
успевает обслужить с помощью одного потока, то создаются дополнительные потоки, которые через некоторое время бездействия, после
уменьшения нагрузки пробуждаются и самоуничтожается, освобождая ресурсы.
	Для добавления в очередь пула потоков асинхронных вычислительных операций обычно вызывают следующиq метод класса ThreadPool:
ThreadPool.QueueUserWorkItem(new WaitCallback(SomeMethod)); и соответствующий делегат delegate void WaitCallback(Object state);
	Преимущества: нет необходимости создавать новый поток на каждое задание, что повышает производительность приложения.
	Самой большой проблемой является отсутствие встроенного механизма, позволяющего узнать о завершении операции и получить
возвращаемое значение. 
	
	Третий способ - задания Task, данный класс описывает отдельную задачу, которая запускается асинхронно в одном из потоков из
пула потоков, но так же ее можно запустить синхронно. 
	Способы создания тасков:
	Создать экземпляр Task, передав в качестве параметра делегат Action или лямбда-выражение. А для операций, возвращающие 
значения используется Task<TResult> класс и метод Result, которые позволяет получить итоговое значение.
		Task task = new Task(() => CW("Hello")); и вызвать метод task.Start(); для запуска задания.
		Task<Int32> t = new Task<Int32>(n => Sum((Int32)n), 1000000000); t.Result позволяет получить итоговое значение.
	Использовать статический метод Run, который ставит в очередь заданную работу для запуска в пуле потоков
		Task task = Task.Run(() => CW("Hello"));
	Фабрика заданий TaskFactory используется для создания группы заданий, а TaskFactory<TResult> если эти задания должны
возвращать некое значение, а метод StartNew сразу запускает задачу.
		Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
	Можно создать и запустить массив задач при помощи Task или двумя другими способами, а метод Task.WaitAll(tasks) позволит 
дождаться выполнение всех задач.
		Task<Int32>[] parent = new Task<Int32>[](() => {много тасков}
	Существует способ узнать о завершении задания и запустить следующе при помощи метода ContinueWith, чтобы избежать блокировки
потоков:
		Task<Int32> t = Task.Run(() => Sum(CancellationToken.None, 10000)); 
		Task cwt = t.ContinueWith(task => Console.WriteLine("The sum is: " + task.Result));
	
	t.Wait() - метод позволяет дождаться завершения задания и после этого получить результат его выполнения. 
	t.Result - получаем результат выполнения, возвращаемого вычислительной операцией.
	Метод WaitAny позволяет ожидать завершения не только одного задания, но и массива объектов Task. Метод возвращает значение
true после завершения всех объектов и значение false, если истекает время ожидания, а так же блокирует вызывающий поток до
завершения всех объектов Task в массиве.
	t.ContinueWith - метод,который, создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи
Task. Во внутренней реализации объект Task содержит коллекцию ContinueWith. Это дает возможность несколько раз вызвать метод
ContinueWith при помощи единственного объекта Task. Когда это задание завершится, все задания из коллекции ContinueWith окажутся в
очереди в пуле потоков.
	При вызове потоком метода Wait система проверяет, началось ли выполнение задания Task, которого ожидает поток. В случае
положительного результата проверки поток, вызывающий метод Wait, блокируется до завершения задания. Но если задание еще не начало
выполняться, система может выполнить его при помощи потока, вызывающего метод Wait. В этом случае данный поток не блокируется. Он
выполняет задание Task и немедленно возвращает управление. Это снижает затраты ресурсов, повышает производительность. Однако и это
может быть не очень хорошо. Например, если перед вызовом метода Wait в рамках синхронизации потока происходит его блокирование, а
затем задание пытается получить доступ к тем же запертым ресурсам, возникает взаимная блокировка (deadlock)!
	Если вычислительное задание генерирует необработанное исключение, оно поглощается и сохраняется в коллекции, а потоку пула
разрешается вернуться в пул. Затем при вызове метода Wait или свойства Result эти члены вбросят исключение AggregateException.
	Для написания масштабируемого программного обеспечения следует избегать блокировки потоков. Вызов метода Wait или запрос
свойства Result при незавершенном задании приведет, скорее всего, к появлению в пуле нового потока, что увеличит расход ресурсов и
отрицательно скажется на расширяемости. 
	
		Асинхронные функции C#
	Когда метод помечается ключевым словом async, компилятор преобразует код метода в тип, реализующий конечный автомат. Это
позволяет потоку выполнить часть кода в конечном автомате, а затем вернуть управление без выполнения всего метода до завершения.
Также стоит отметить, что слово async, которое указывается в определении метода, НЕ делает метод асинхронным. Оно лишь указывает,
что данный метод может содержать одно или несколько выражений await. Ключевое слово await позволяет обойтись без блокировки для
запуска задачи, а затем продолжить выполнение, когда задача завершается. Оператор await заставляет компилятор сгенерировать код,
который запрашивает свойство Result объекта Task<TResult> и присваивает результат локальной переменной, или выдает исключение в
случае ошибки, а затем выполняется оставшаяся часть кода.
	Асинхронный метод обладает следующими признаками: В заголовке метода используется модификатор async, метод содержит одно или
несколько выражений await. В качестве возвращаемого типа используется один из следующих: void, Task, Task<T> или ValueTask<T>
	Асинхронная функция не может иметь параметры out, ref или in.
	Оператор await не может использоваться в блоке catch, finally или unsafe.	
	
		Виды синхронизации потоков при многопоточном программировании
	lock - оператор lock определяет блок кода, для блокировки которого используется объект-заглушка, когда выполнение доходит до
оператора lock, объект блокируется и весь код становится недоступным для других потоков до завершения работы текущего потока.
Остальные потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода, а после окончания работы
блока кода, объект освобождается и становится доступным для других потоков.
	Не используйте один и тот же экземпляр объекта блокировки для разных общих ресурсов: это может привести к взаимоблокировке или
состязанию при блокировке.
	Удерживайте блокировку в течение максимально короткого времени, чтобы сократить число конфликтов при блокировке.
	lock это упращенный синтаксис класса Monitor.
	Monitor - метод Monitor.Enter принимает два параметра: объект блокировки и значение типа bool, которое указывает на результат
блокировки, если он равен true, то блокировка успешно выполнена. Рекомендуется поместить этот код в try блок, а вызов Exit метода, 
в котором происходит освобождение объекта, поместить в finally блок. Это гарантирует снятие блокировки даже при возникновении 
исключения, если блокировка осуществлена успешно он становится доступным для других потоков. Но есть опасность, что в случаше
ошибки следующий поток может работать с поврежденными данными.
	lock и monitor - одно и то же. lock - синтаксический сахар - вызывает методы Monitor.Enter и Monitor.Exit. lock работает на
порядки быстрее чем Mutex, но к нему невозможно получить доступ из другого процесса, а вот к Mutex - можно.

		Конструкции режима ядра:
	Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в
одном экземпляре. Они работают намного медленнее конструкций пользовательского режима, так как требуют координации со стороны
операционной системы. К примитивным конструкциям синхронизации потоков в режиме ядра относятся события (events) и семафоры
(semaphores). На их основе строятся более сложные конструкции аналогичного назначения, например мьютексы
	В пространстве имен System.Threading существует абстрактный базовый класс WaitHandle. 
	Вот как выглядит иерархия этих классов:
		WaitHandle
			EventWaitHandle
				AutoResetEvent
				ManualResetEvent
			Semaphore
			Mutex
			
	Mutex — это примитив синхронизации, является производными от класса WaitHandle, предоставляющий монопольный доступ к общему
ресурсу только одному потоку. Если поток получает мьютекс, второй поток, который хочет получить этот мьютекс, приостанавливается
до тех пор, пока первый поток не выпустит мьютекс т.е к критической секции может получить доступ только один поток.
	Класс Mutex обеспечивает идентификацию потоков, поэтому мьютекс может быть освобожден только потоком, который его приобрел. В
отличии от Semaphore у которого нет идентификации потоков. Мьютекс также можно передавать через границы домена приложения.
	К Mutex можно получить доступ из другого процесса в отличии lock, но работает он намного медленнее.
	Сначала создаем объект мьютекса: 	Mutex mutexObj = new Mutex()
	Основную работу по синхронизации выполняют методы WaitOne() и ReleaseMutex(). 
	Метод mutexObj.WaitOne() приостанавливает выполнение потока до тех пор, пока не будет получен мьютекс mutexObj. Изначально
мьютекс свободен, поэтому его получает один из потоков, а после выполнения всех действий, поток освобождает его с помощью метода
mutexObj.ReleaseMutex(). Далее мьютекс получает следующий ожидающий поток. Таким образом, когда выполнение дойдет до вызова
mutexObj.WaitOne(), поток будет ожидать, пока не освободится мьютекс. И после его получения продолжит выполнять свою работу.

	Semaphore - работает подобно Mutex, но позволяет определить несолько потоков, чтобы получить доступ к критической секции, а в 
конструкторе указывается колличестов потоков. Количество семафоров уменьшается каждый раз, когда поток входит в семафор, и
увеличивается, когда поток освобождает семафор. Если счетчик равен нулю, последующие запросы блокируются до тех пор, пока другие
потоки не отпустят семафор.
	Семафоры бывают двух типов: локальные и именованные системные семафоры. 
	Если создается объект Semaphore, принимающи имя в конструкторе, он связывается с семафором операционной системы с таким именем
Именованные системные семафоры видны всей операционной системе и могут использоваться для синхронизации действий процессов. Можно
создать несколько Semaphore объектов, представляющих один и тот же именованный системный семафор, и использовать OpenExisting
метод для открытия существующего именованного системного семафора.
	Локальный семафор существует только внутри процесса. Его может использовать любой поток в вашем процессе, имеющий ссылку на
локальный объект Semaphore. Каждый Semaphore объект является отдельным локальным семафором.
	Для работы с потоками класс Semaphore имеет два основных метода:
	WaitOne(): ожидает получения свободного места в семафоре
	Release(): освобождает место в семафоре
	Семафоры (semaphores) также представляют собой обычные переменные типа Int32, управляемые ядром. Ожидающий семафора поток
блокируется при значении 0 и освобождается при значениях больше 0. При снятии блокировки с ожидающего семафора потока ядро
автоматически вычитает единицу из счетчика. С семафорами связано максимальное значение типа Int32, которое ни при каких 
обстоятельствах не могут превысить текущие показания счетчика иначе будет вызвано исключение SemaphoreFullException.

	События (events) представляют собой переменные типа Boolean, находящиеся под управлением ядра. Ожидающий события поток
блокируется, если оно имеет значение false, и освобождается в случае значения true. 
	EventWaitHandle представляет событие синхронизации потока и может находиться в сигнальном или несигнальном состоянии. Если
состояние события несигнальное, поток, который вызывает перегрузку события WaitOne, будет заблокирован, пока состояние события не
станет сигнальным. Метод EventWaitHandle.Set задает сигнальное состояние события. Поведение EventWaitHandle после получения
сигнала зависит от его режима сброса:
- EventWaitHandle, созданный с помощью флага EventResetMode.AutoReset, автоматически сбрасывается после освобождения одного потока
в состоянии ожидания. Это похоже на турникет, пропускающий только один поток каждый раз, когда он переводится в сигнальное
состояние. Такое поведение характерно для класса System.Threading.AutoResetEvent, наследующего EventWaitHandle.
- EventWaitHandle, созданный с помощью флага EventResetMode.ManualReset, находится в сигнальном состоянии, пока не будет вызван
его метод Reset. Это как ворота, которые закрыты до получения сигнала и остающиеся затем открытыми, пока кто-нибудь их не закроет.
Такое поведение характерно для класса System.Threading.ManualResetEvent, наследующего EventWaitHandle. 
- Класс System.Threading.ManualResetEventSlim является упрощенной альтернативой ManualResetEvent.
	AutoResetEvent - этот класс представляет событие синхронизации потоков, который позволяет при получении сигнала переключить
данный объект-событие из сигнального в несигнальное состояние. Для этого создаем переменную типа AutoResetEvent. Передавая в
конструктор значение true, указывая, что создаваемый объект изначально будет в сигнальном состоянии.
	Когда начинает работать поток, то первым делом срабатывает вызов waitHandler.WaitOne(). Метод WaitOne указывает, что текущий
поток переводится в состояние ожидания, пока объект waitHandler не будет переведен в сигнальное состояние. После завершения работы
вызывается метод waitHandler.Set, который уведомляет все ожидающие потоки, что объект waitHandler снова находится в сигнальном
состоянии, теперь следующий ожидающий поток, переводит waitHandler в несигнальное состояние и выполняет свой код. А остальные
потоки снова ожидают.
	Если у нас в программе используются несколько объектов AutoResetEvent, то мы можем использовать для отслеживания состояния
этих объектов статические методы WaitAll и WaitAny, которые в качестве параметра принимают массив объектов класса WaitHandle - 
базового класса для AutoResetEvent.	
	Итак, что происходит при выполнении программы:
	1. AutoResetEvent waitHandler = new AutoResetEvent(true) - подал сигнал
	2. Первый поток в очереди к нему 
	3. waitHandler.WaitOne(); - поймал сигнал, и погасил текущий поток - главный т.е ввёл остальыне потоки в режим ожидания.
	4. Выполнился блок кода
	5. waitHandler.Set(); - отдал-включил сигнал. - включил главный поток(вывел главный поток из режима ожидания)
	6. Второй поток в очереди: пункты 3,4,5 - поймал сигнал, погасил, выполнился, отдал-включил
	7. И так далее
	ManualResetEvent - основное отличие от AutoResetEvent заключается в том, что при установке одного set работу начинают от
одного и более потоков, а не одиному.
	
		Deadlock, livelock, starvation.
	Deadlock - взаимоблокировкой (deadlock) называется ситуация, когда как минимум два потока останавливаются и ожидают друг от
друга снятия блокировки. Поскольку оба потока ожидают друг от друга выполнения соответствующего действия, получается, что они
блокируют друг друга, из-за чего их ожидание может длиться бесконечно.
	livelock - если поток, использующий в данный момент конструкцию, не освободит ее, ожидающий конструкции поток может оказаться
заблокированным навсегда. В этом случае в пользовательском режиме поток бесконечно исполняется процессором; этот вариант
блокировки называется активной (живой) блокировкой (livelock) или зависанием.
	starvation - во время включения потока Б эксклюзывный ресурс всегда занят другим потоком, из-за чего поток Б прекращает свою
работу не может выполнить свои опперации.

		Подробнее об операторе foreach
	Цикл foreach является универсальным инструментом для обработки коллекций/последовательностей. Способ его преобразования
компилятором зависит от типа перебираемой коллекции (обобщенная/необобщенная) и представляет собой простой цикл while. Пример
обхода необобщенной коллекции выглядит следующим образом (листинг 4.5).
public static void ForEachIEnumerable(IEnumerable sequence)
{
	// foreach(var e in sequence) {Console.WriteLine(e);}
	IEnumerator enumerator = sequence.GetEnumerator();
	object current = null;	
	try
	{
		while (enumerator.MoveNext())
		{
			current = enumerator.Current;
			Console.WriteLine(current);
		}
	}
	finally
	{
		IDisposable disposable = enumerator as IDisposable;
		if (disposable != null)
		{
			disposable.Dispose();
		}
	}
}	
	
		Классы коллекций для параллельного доступа
	В FCL существует четыре безопасных в отношении потоков класса коллекций, принадлежащих пространству имен System.Collections.Concurrent: 
	ConcurrentQueue, ConcurrentStack, ConcurrentDictionary и ConcurrentBag	
	
	Атрибут [ThreadStatick]
		Автоматическое управление памятью (уборка мусора)
		Хостинг CLR и домены приложений
						Глава 23. Загрузка сборок и отражение
						Глава 24. Сериализация
						Глава 25. Взаимодействие с компонентами WinRT
		
	объекты должны наследоваться от IEnumerable и реализовывать GetEnumerator
		Тип record
		Полиморфизм
		Parse, TryParse
		Асинхронные методы
		IEnumerable vs IQueryable
		
https://www.youtube.com/watch?v=nFEkZXD2wFI&ab_channel=loftblog
https://www.youtube.com/watch?v=jBvkN8_c7t8&ab_channel=loftblog


@davidkoperfild53
10 месяцев назад
Alt+enter+создать конструктор=конструктор с инициализоаанными полями ))