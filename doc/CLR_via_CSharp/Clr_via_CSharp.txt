Глава 1. Модель выполнения кода в среде CLR
	Название среды — общеязыковая среда выполнения (Common Language Runtime, CLR) — это среда выполнения, которая подходит для разных языков программирования. 
Основные возможности CLR: управление памятью, загрузка сборок, безопасность, обработка исключений, синхронизация, которые доступны в любых языках программирования, использующих CLR. 

		Процесс компиляции файлов с исходным кодом.
	Исходный код программы может быть написан на любом языке, поддерживающем среду выполнения CLR. Затем соответствующий компилятор проверяет синтаксис и анализирует исходный
код программы. Результатом компиляции будет являться managed module.
	managed module — стандартный переносимый исполняемый (portable executable, PE) файл 32-разрядной (PE32) или 64-разрядной Windows (PE32+), который требует для своего
выполнения CLR. 
	Компиляторы машинного кода производят код, ориентированный на конкретную процессорную архитектуру, например x86, х64 или ARM. В отличие от этого, все 
CLR-совместимые компиляторы генерируют IL-код. IL-код иногда называют управляемым (managed code), потому что CLR управляет его выполнением.
Составные части управляемого модуля: 
	- Заголовок PE32/PE32+  - файл с заголовком в формате PE32 может выполняться в 32 и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64-разрядной. 
Заголовок обозначает тип файла, временную метку, показывающую, когда файл был собран. 
	- Заголовок CLR - содержит информацию, которая превращает этот модуль в управляемый. Заголовок включает нужную версию CLR, флаги, метку метаданных MethodDef точки входа в 
управляемый модуль (метод Main), а также месторасположение, размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр;
	- Метаданные - Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены, определенные в исходном коде, и таблицы, описывающие типы данных и их члены, 
на которые имеются ссылки в исходном коде;
	- Код Intermediate Language (IL) - код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды.

	Каждый компилятор, предназначенный для CLR, помимо генерирования IL-кода, должен также создавать полные метаданные (metadata) для каждого управляемого модуля. 
Метаданные — это набор таблиц данных, описывающих то, что определено в управляемом модуле, например типы и их члены. В метаданных также есть таблицы, указывающие, на что 
ссылается управляемый модуль, например на импортируемые типы и их члены, которые всегда связаны с файлом, содержащим IL-код. Благодаря тому что компилятор генерирует метаданные и код 
одновременно и привязывает их к конечному управляемому модулю, возможность рассинхронизации метаданных и описываемого ими IL-кода исключена.

	Метаданные находят много применений. Перечислим лишь некоторые из них.
	Метаданные устраняют необходимость в заголовочных и библиотечных файлах при компиляции, так как все сведения об упоминаемых типах/членах содержатся 
в файле с реализующим их IL-кодом. Компиляторы могут читать метаданные прямо из управляемых модулей.
	Среда Microsoft Visual Studio использует метаданные для облегчения написания кода. Ее функция IntelliSense анализирует метаданные и сообщает, какие методы, свойства, 
события и поля предпочтительны в данном случае и какие именно параметры требуются конкретным методам.
	В процессе верификации кода CLR использует метаданные, чтобы убедиться, что код совершает только «безопасные по отношению к типам» операции.
	Метаданные позволяют сериализовать поля объекта, а затем передать эти данные по сети на удаленный компьютер и там провести процесс десериализации, 
восстановив объект и его состояние на удаленном компьютере.
	Метаданные позволяют сборщику мусора отслеживать жизненный цикл объектов. При помощи метаданных сборщик мусора может определить тип объектов 
и узнать, какие именно поля в них ссылаются на другие объекты


			Объединение управляемых модулей в сборку
Среда CLR работает не с модулями, а со сборками (assembly) — это абстрактное понятие. Во-первых, сборка обеспечивает логическую группировку одного или нескольких 
управляемых модулей или файлов ресурсов. Во-вторых, это наименьшая единица многократного использования, безопасности и управления версиями. Сборка может состоять из одного 
или нескольких файлов — все зависит от выбранных средств и компиляторов. В контексте среды CLR сборкой называется то, что мы обычно называем компонентом.
	На этом рисунке изображены некоторые управляемые модули и файлы ресурсов (или данных), с которыми работает некоторая программа. Эта программа создает единственный файл PE32(+), 
который обеспечивает логическую группировку файлов. При этом в файл PE32(+) включаетсяч блок данных, называемый манифестом (manifest). Манифест представляет 
собой обычный набор таблиц метаданных. Эти таблицы описывают файлы, которые входят в сборку, общедоступные экспортируемые типы, реализованные в файлах сборки, а также 
относящиеся к сборке файлы ресурсов или данных. По умолчанию компиляторы сами выполняют работу по преобразованию созданного управляемого модуля в сборку, то есть компилятор C# 
создает управляемый модуль с манифестом, указывающим, что сборка состоит только из одного файла. 
Таким образом, в проектах, где есть только один управляемый модуль и нет файлов ресурсов (или файлов данных), сборка и является управляемым модулем, поэтому выполнять 
дополнительные действия по компоновке приложения не нужно. В случае если необходимо сгруппировать несколько файлов в сборку, потребуются дополнительные инструменты 
(например, компоновщик сборок AL.exe) со своими параметрами командной строки. 
Сборка позволяет разделить логическое и физическое представления компонента, поддерживающего многократное использование, безопасность и управление 
версиями. Разбиение программного кода и ресурсов на разные файлы полностью определяется желаниями разработчика. Например, редко используемые типы 
и ресурсы можно вынести в отдельные файлы сборки. Отдельные файлы могут загружаться по запросу из Интернета по мере необходимости в процессе выполнения 
программы. Если некоторые файлы не потребуются, то они не будут загружаться, что сохранит место на жестком диске и сократит время установки программы. 
Сборки позволяют разбить на части процесс развертывания файлов, при этом все файлы будут рассматриваться как единый набор.
Модули сборки также содержат сведения о других сборках, на которые они ссылаются (в том числе номера их версий). Эти данные делают сборку самоописываемой (self-describing). 
Другими словами, среда CLR может определить все прямые зависимости данной сборки, необходимые для ее выполнения. Не нужно размещать никакой дополнительной информации ни в с
истемном реестре, ни в доменной службе AD DS (Active Directory Domain Services). Вследствие этого развертывать сборки гораздо проще, чем неуправляемые компоненты

									Загрузка CLR
	При запуске исполняемого файла Windows:
	анализирует заголовок EXE-файла для определения того, какое именно адресное пространство необходимо для его работы — 32- или 64-разрядное. Файл с заголовком PE32 может 
выполняться в адресном пространстве любого из указанных двух типов, а файлу с заголовком PE32+ требуется 64-разрядное пространство. 
	Windows также проверяет информацию о процессорной архитектуре на совместимость с заданной конфигурацией. Наконец, 64-разрядные версии Windows поддерживают технологию 
выполнения 32-разрядных приложений в 64-разрядной среде, которая называется WoW64.
	После анализа заголовка EXE-файла — Windows загружает в адресноепространство процесса соответствующую версию библиотеки MSCorEE.dll (x86, x64 или ARM).
	Далее основной поток вызывает определенный в библиотеке MSCorEE.dll метод, который инициализирует CLR, загружает сборку EXE, а затем вызывает ее метод Main, 
в котором содержится точка входа. На этом процедура запуска управляемого приложения считается завершенной

								Исполнение кода сборки
	Как говорилось ранее, управляемые модули содержат метаданные и программный код IL. Для выполнения какого-либо метода его IL-код должен быть преобразован в 
машинные команды. Этим занимается JIT-компилятор (Just-In-Time) среды CLR.
Непосредственно перед исполнением метода Main среда CLR находит все типы данных, на которые ссылается программный код метода Main. При этом CLR выделяет внутренние структуры данных, 
используемые для управления доступом к типам, на которые есть ссылки. На рис. 1.4 метод Main ссылается на единственный тип — Console, и среда CLR выделяет единственную 
внутреннюю структуру. Эта внутренняя структура данных содержит по одной записи для каждого метода, определенного в типе Console. Каждая запись содержит адрес, по которому 
можно найти реализацию метода. При инициализации этой структуры CLR заносит в каждую запись адрес внутренней недокументированной функции, содержащейся 
в самой среде CLR. Я обозначаю эту функцию JITCompiler
Когда метод Main первый раз обращается к методу WriteLine, вызывается функция JITCompiler. Она отвечает за компиляцию IL-кода вызываемого метода в собственные команды процессора. 
Поскольку IL-код компилируется непосредственно перед выполнением («just in time»), этот компонент CLR часто называют JIT-компилятором
Рассмотрим повторное обращение метода Main к методу WriteLine. К этому моменту код метода WriteLine уже проверен и скомпилирован, так что обращение 
к блоку памяти производится напрямую, без вызова JITCompiler. Отработав, метод WriteLine возвращает управление методу Main.
Снижение производительности наблюдается только при первом вызове метода. Все последующие обращения выполняются «на максимальной скорости», потому 
что повторная верификация и компиляция не производятся. JIT-компилятор хранит машинные команды в динамической памяти. Это значит, что скомпилированный код уничтожается 
по завершении работы приложения. Для повторного вызова приложения или для параллельного запуска его второго экземпляра (в другом процессе операционной системы) 
JIT-компилятору придется заново скомпилировать IL-код в машинные команды

								IL-код и верификация
IL является стековым языком; это означает, что все его инструкции заносят операнды в исполнительный стек и извлекают результаты из стека. IL не содержит инструкций 
для работы с регистрами, и это упрощает создание новых языков и компиляторов, генерирующих код для CLR.
Однако, на мой взгляд, самое большое преимущество IL-кода состоит даже не в том, что он абстрагирует разработчика от конкретного процессора. IL-код обеспечивает безопасность 
приложения и его устойчивость перед ошибками. В процессе компиляции IL в машинные инструкции CLR выполняется процедура, называемая 
верификацией — анализ высокоуровневого кода IL и проверка безопасности всех операций. Например, верификация убеждается в том, что каждый метод вызывается с правильным 
количеством параметров, что все передаваемые параметры имеют правильный тип, что возвращаемое значение каждого метода используется правильно, что каждый метод 
содержит инструкцию return и т. д. Вся информация о методах и типах, используемая в процессе верификации, хранится в метаданных управляемого модуля
В системе Windows каждый процесс обладает собственным виртуальным адресным пространством. Необходимость разделения адресных пространств объясняется 
тем, что код приложения в принципе ненадежен. Ничто не мешает приложению выполнить операцию чтения или записи по недопустимому адресу памяти (и к сожалению, это часто 
происходит на практике). Размещение процессов Windows в изолированных адресных пространствах обеспечивает защищенность и стабильность 
системы; один процесс не может повредить другому процессу. Однако верификация управляемого кода гарантирует, что код не будет некорректно обращаться к памяти и не сможет 
повредить выполнению кода другого приложения. Это означает, что вы можете запустить несколько управляемых приложений в одном виртуальном адресном пространстве Windows.
Сокращение количества процессов за счет запуска нескольких приложений в одном процессе операционной системы улучшает производительность, снижает затраты ресурсов и 
обеспечивает такой же уровень защиты, как если бы каждое приложение располагало собственным процессом. Это еще одно преимущество управляемого кода по сравнению с неуправляемым.
Итак, CLR предоставляет возможность выполнения нескольких управляемых приложений в одном процессе операционной системы. Каждое управляемое приложение выполняется в 
домене приложений (AppDomain). По умолчанию каждый управляемый EXE-файл работает в отдельном адресном пространстве, состоящем из одного домена. 
Тем не менее процесс, обеспечивающий размещение (хостинг) CLR — например, IIS (Internet Information Services) или Microsoft SQL Server, — 
может запустить несколько доменов приложений в одном процессе операционной системы. Обсуждению доменов приложений посвящена одна из частей главы 22.
								
								Небезопасный код
По умолчанию компилятор C# компании Microsoft генерирует безопасный код. 
Под этим термином понимается код, безопасность которого подтверждается в процессе верификации. Тем не менее компилятор Microsoft C# также позволяет разработчикам писать 
небезопасный код, способный напрямую работать с адресами памяти и манипулировать с байтами по этим адресам. 
Однако использование небезопасного кода создает значительный риск: небезопасный код может повредить структуры данных и использовать (или даже создавать) 
уязвимости в системе безопасности. По этой причине компилятор C# требует, чтобы все методы, содержащие небезопасный код, помечались ключевым словом unsafe, 
а при компиляции исходного кода использовался параметр компилятора /unsafe.

								Библиотека FCL
	FCL (Framework Class Library) - одним из компонентов .NET Framework, который содержит набор сборок в формате DLL, содержащих несколько тысяч определений типов.
Так как FCL содержит буквально тысячи типов, взаимосвязанные типы объединяются в одно пространство имен. 
Чтобы использовать возможности FCL, необходимо знать, какое пространство имен содержит типы, предоставляющие нужную функциональность. Многие типы 
поддерживают настройку своего поведения; для этого тип просто объявляется производным от нужного типа FCL.

								CTS
Поскольку типы занимают центральное место в CLR, компания Microsoft разработала формальную спецификацию CTS (Common Type System), которая описывает способ 
определения и поведение типов
Компания Microsoft предоставляет CTS вместе с другими частями .NET Framework в органкомитет ECMA с целью стандартизации. Стандарт называется CLI (Common Language Infrastructure) 
и определяется спецификацией ECMA-335. Кроме того, компания Microsoft предоставила отдельные части FCL, язык программирования C# (ECMA334) и язык программирования C++/CLI. 
Информация об этих отраслевых стандартах доступна на сайте ECMA по адресу http://www.ecma-international.org. Вы также можете обратиться на сайт Microsoft: 
http://msdn.microsoft.com/en-us/netframework/aa569283.aspx

Согласно спецификации CTS, тип может содержать нуль и более членов. Подробные описания всех возможных членов типов приведены в части II книги, а пока 
я ограничусь краткими вводными описаниями:
 Поле — переменная, являющаяся частью состояния объекта. Поля идентифицируются именем и типом.
 Метод — функция, выполняющая операцию с объектом, часто с изменением его состояния. Метод обладает именем, сигнатурой и модификаторами. Сигнатура 
определяет количество параметров (и порядок их следования), типы параметров, наличие возвращаемого значения, и если оно имеется — тип значения, возвращаемого методом.
 Свойство — с точки зрения вызывающей стороны выглядит как поле, но в реализации типа представляет собой метод (или два). Свойства позволяют организовать проверку 
параметров или состояния объекта перед обращением к значению и/или вычислять его значение только при необходимости. Кроме того, они упрощают синтаксис работы с данными 
и позволяют создавать «поля», доступные только для чтения или записи.
 Событие — используется для создания механизма оповещения между объектом и другими заинтересованными объектами. Например, кнопка может поддерживать событие, 
оповещающее другие объекты о щелчке на ней

CTS также задает правила видимости типов и доступа к членам типа. Например, помечая тип как открытый (ключевое слово public), вы тем самым экспортируете 
этот тип, делая его видимым и доступным для любой сборки. С другой стороны, пометка типа на уровне сборки (ключевое слово internal в C#) делает его видимым 
и доступным для кода той же сборки. Таким образом, CTS устанавливает правила, по которым сборки формируют границу видимости типа, а CLR обеспечивает выполнение правил видимости.
Тип, видимый для вызывающей стороны, может установить дополнительные ограничения на возможность обращения к своим членам. Ниже перечислены варианты ограничения доступа к членам типа:
 Закрытый (приватный) доступ — член типа доступен только для других членов того же типа.
 Доступ в семействе — член типа доступен для производных типов независимо от того, принадлежат ли они той же сборке или нет. 
Обратите внимание: во многих языках (таких, как C# и C++) доступ в семействе обозначается ключевым словом protected.
 Доступ в семействе и сборке — член типа доступен для производных типов, но только в том случае, если они определяются в той же сборке. 
Многие языки (например, C# и Visual Basic) не поддерживают этот уровень доступа. Разумеется, в IL-коде он поддерживается.
 Доступ в сборке — член типа доступен для любого кода, входящего в ту же сборку. Во многих языках доступ в сборке обозначается ключевым словом internal.
 Доступ в семействе или сборке — член типа доступен для производных типов из любой сборки, а также для любых типов в той же сборке. В C# этот вариант 
доступа обозначается ключевыми словами protected internal.
 Открытый доступ — член типа доступен для любого кода в любой сборке.

Кроме того, CTS определяет правила, управляющие наследованием, работой виртуальных методов, сроком жизни объектов и т. д. Эти правила разрабатывались 
для выражения семантики, выражаемой средствами современных языков программирования. Собственно, вам вообще не придется изучать правила CTS как таковые, 
потому что выбранный вами язык предоставляет собственный синтаксис и правила работы с типами. Синтаксис конкретного языка преобразуется в IL, «язык» CLR, 
в процессе генерирования сборки на стадии компиляции.

А вот еще одно правило CTS: все типы должны быть производными (прямо или опосредованно) от предопределенного типа System.Object (то есть от типа 
Object из пространства имен System). Тип Object является корнем иерархии типов, а следовательно, гарантирует, что каждый экземпляр типа обладает минимальным 
набором аспектов поведения. А если говорить конкретнее, тип System.Object позволяет сделать следующее:
 сравнить два экземпляра на равенство;
 получить хеш-код экземпляра;
 запросить фактический тип экземпляра;
 выполнить поверхностное (поразрядное) копирование экземпляра;
 получить строковое представление текущего состояния экземпляра

										CLS									
Для упрощения этой задачи компания Microsoft определила спецификацию CLS (Common Language Speciication); в ней перечислен минимальный набор возможностей, 
которые должны поддерживаться компилятором для генерирования типов, совместимых с другими компонентами, написанными на других CLS-совместимых 
языках на базе CLR.
Возможности CLR/CTS выходят далеко за рамки подмножества, определяемого CLS. Если вас не беспокоит межъязыковая совместимость, вы можете разрабатывать 
типы с широкой функциональностью, ограничиваемой только возможностями языка. А если говорить конкретнее, CLS определяет правила, которым должны 
соответствовать типы и методы с внешней видимостью, для того чтобы они могли использоваться в любом CLS-совместимом языке программирования. Обратите 
внимание: правила CLS не распространяются на код, доступный только в определяющей сборке. На рис. 1.6 наглядно представлены концепции, выраженные в этом абзаце.

атрибут [assembly:CLSCompliant(true)] применяется к сборке. 
Этот атрибут приказывает компилятору следить за тем, чтобы тип с открытым уровнем доступа не содержал конструкций, препятствующих его использованию 
в другом языке программирования. 

								Глава 2. Компоновка, упаковка, развертывание и администрирование приложений и типов
							Задачи развертывания в .NET Framework								
Во-первых, все приложения используют динамически подключаемые библиотеки (Dynamic Link Library, DLL), созданные Microsoft 
и другими производителями. Поскольку приложение исполняет код, написанный разными производителями, ни один разработчик какой-либо части программы не 
может быть на 100 % уверен в том, что точно знает, как другие собираются применять созданный им код. 

							Несколько слов о метаданных
Что же именно находится в файле Program.exe? Управляемый PE-файл состоит из 4-х частей: заголовка PE32(+), заголовка CLR, метаданных и кода на промежуточном языке 
(intermediate language, IL). Заголовок PE32(+) хранит стандартную информацию, ожидаемую Windows. 
Заголовок CLR — это небольшой блок информации, специфичной для модулей, требующих CLR (управляемых модулей). 
В него входит старший и младший номера версии CLR, для которой скомпонован модуль, ряд флагов и маркер MethodDef (о нем — чуть позже), указывающий метод 
точки входа в модуль, если это исполняемый файл CUI, GUI или Windows Store, а также необязательную сигнатуру строгого имени (она рассмотрена в главе 3). 
Наконец, заголовок содержит размер и смещение некоторых таблиц метаданных, расположенных в модуле. 
Метаданные — это блок двоичных данных, состоящий из нескольких таблиц.  Существуют три категории таблиц: определений, ссылок и манифестов.

Для каждой сущности, определяемой в компилируемом исходном тексте, компилятор генерирует строку в одной из таблиц, перечисленных в табл. 2.1. В ходе 
компиляции исходного текста компилятор также обнаруживает типы, поля, методы, свойства и события, на которые имеются ссылки в исходном тексте. Все сведения 
о найденных сущностях регистрируются в нескольких таблицах ссылок, составляющих метаданные. 

важно запомнить, что Program.exe содержит в таблице TypeDef описание типа Program. Этот тип идентифицирует открытый запечатанный (sealed) класс, производный 
от System.Object (то есть это ссылка на тип из другой сборки). Тип Program также определяет два метода: Main и .ctor (конструктор).

Метод Main — это статический открытый метод, чей программный код представлен на языке IL (а не в машинных кодах процессора, например x86). Main
возвращает void и не получает аргументов. Метод-конструктор (всегда отображаемый под именем .ctor) является открытым, его код также записан на языке IL. 
Тип возвращаемого значения конструктора — void, у него нет аргументов, но есть указатель this, ссылающийся на область памяти, в которой должен создаваться 
экземпляр объекта при вызове конструктора.

									Объединение модулей для создания сборки
Файл Program.exe — это не просто PE-файл с метаданными, а еще и сборка (assembly), то есть совокупность одного или нескольких файлов с определениями типов и файлов ресурсов. 
Один из файлов сборки выбирается для хранения ее манифеста. Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном 
содержат имена файлов, составляющих сборку. Кроме того, эти таблицы описывают версию и региональные стандарты сборки, ее издателя, общедоступные экспортируемые типы, 
а также все составляющие сборку файлы.
CLR работает со сборками, то есть сначала CLR всегда загружает файл с таблицами метаданных манифеста, а затем получает из манифеста имена остальных 
файлов сборки. Некоторые характеристики сборки стоит запомнить:
	- в сборке определены многократно используемые типы;
	- сборке назначается номер версии;
	- со сборкой может быть связана информация безопасности.
У отдельных файлов сборки, кроме файла с таблицами метаданных манифеста, таких атрибутов нет. Чтобы упаковать типы, а также обеспечить безопасность типов и управление 
их версиями, нужно поместить типы в модули, объединенные в сборку. Чаще всего сборка состоит из одного файла, как приложение Program.exe в рассмотренном примере, 
но могут быть и сборки из нескольких файлов: PE-файлов с метаданными. Компоновка, упаковка, развертывание и администрирование приложений
и файлов ресурсов, например GIF- или JPG-файлов. Наверное, проще представлять себе сборку как «логический» EXE- или DLL-файл

Подводя итог, можно сказать, что сборка — это единица многократного использования, управления версиями и безопасности типов. Она позволяет распределять
типы и ресурсы по отдельным файлам, чтобы ее пользователи могли решить, какие файлы упаковывать и развертывать вместе. Загрузив файл с манифестом, среда
CLR может определить, какие файлы сборки содержат типы и ресурсы, на которые ссылается приложение. Любому потребителю сборки достаточно знать лишь имя
файла, содержащего манифест, после чего он сможет, не нарушая работы приложения, абстрагироваться от особенностей распределения содержимого сборки по
файлам, которое со временем может меняться.


									Глава 3. Совместно используемые сборки и сборки со строгим именем
										Глобальный кэш сборок
	Если сборка предназначена для совместного использования несколькими приложениями, ее нужно поместить в общеизвестный каталог, который среда CLR 
должна автоматически проверять при обнаружении ссылки на сборку. Место, где располагаются совместно используемые сборки, называют глобальным кэшем 
сборок (global assembly cache, GAC).
Зачем «регистрировать» сборку в каталоге GAC? Представьте себе, что две компании сделали каждая свою сборку OurLibrary, состоящую из единственного файла: 
OurLibrary.dll. Очевидно, эти файлы нельзя записывать в один каталог, поскольку файл, копируемый последним, перезапишет первый и тем самым нарушит работу 
какого-нибудь приложения. Если для установки в GAC использовать специальный инструмент, он создаст в каталоге %SystemRoot%\Microsoft.NET\Assembly отдельные 
папки для каждой из этих сборок и скопирует каждую сборку в свою папку.

Допустим, в результате компиляции и построения этого кода получилась сборка Program.exe. При запуске приложения происходит загрузка и инициализация CLR. 
Затем CLR сканирует CLR-заголовок сборки в поисках атрибута MethodDefToken, идентифицирующего метод Main, представляющий точку входа в приложение. 
CLR находит в таблице метаданных MethodDef смещение, по которому в файле находится IL-код этого метода, и компилирует его в машинный код процессора при 
помощи JIT-компилятора. Этот процесс включает в себя проверку безопасности типов в компилируемом коде, после чего начинается исполнение полученного машинного кода.
Во время JIT-компиляции этого кода CLR обнаруживает все ссылки на типы и члены и загружает сборки, в которых они определены (если они еще не загружены). Как видите, 
показанный код содержит ссылку на метод System.Console.Write-Line: команда Call ссылается на маркер метаданных 0A000003. Этот маркер 
идентифицирует запись 3 таблицы метаданных MemberRef (таблица 0A). Просматривая эту запись, CLR видит, что одно из ее полей ссылается на элемент таблицы 
TypeRef (описывающий тип System.Console). Запись таблицы TypeRef направляет CLR к следующей записи в таблице AssemblyRef:
MSCorLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089

На этом этапе CLR уже знает, какая сборка нужна, и ей остается лишь найти и загрузить эту сборку.
В предыдущем примере среда CLR обнаруживала, что тип System.Console реализован в файле другой сборки. CLR должна найти эту сборку и загрузить PE-файл, 
содержащий ее манифест. После этого манифест сканируется в поисках сведений о PE-файле, в котором реализован искомый тип. Если необходимый тип содержится 
в том же файле, что и манифест, все замечательно, а если в другом файле, то CLR загружает этот файл и просматривает его метаданные в поисках нужного типа. 
После этого CLR создает свою внутреннюю структуру данных для представления типа и JIT-компилятор завершает компиляцию метода Main. В завершение процесса 
начинается исполнение метода Main
Если какая-либо операция заканчивается неудачей, то выдается соответствующее исключение.
Есть еще один нюанс: CLR идентифицирует все сборки по имени, версии, региональному стандарту и открытому ключу. Однако GAC различает сборки по имени, 
версии, региональному стандарту, открытому ключу и процессорной архитектуре. 
При поиске сборки в GAC среда CLR выясняет, в каком процессе выполняется приложение — 32-разрядном x86 (возможно, с использованием технологии WoW64), 
64-разрядном x64 или 64-разрядном ARM. Сначала выполняется поиск сборки в GAC с учетом процессорной архитектуры. В случае неудачи происходит поиск 
сборки без учета процессорной архитектуры.


											Глава 4. Основы типов
В CLR каждый объект прямо или косвенно является производным от System.Object.
Благодаря тому, что все типы, в конечном счете, являются производными от System.Object, любой объект любого типа гарантированно имеет минимальный набор методов.
 - Equals - возвращает true, если два объекта имеют одинаковые значения. 
 - GetHashCode - возвращает хеш-код для значения данного объекта. 
 - ToString - по умолчанию возвращает полное имя типа (this.GetType().FullName). На практике этот метод переопределяют, чтобы он возвращал объект String, 
 содержащий состояние объекта в виде строки. 
 - GetType - возвращает экземпляр объекта, производного от Type, который идентифицирует тип объекта, вызвавшего GetType. Возвращаемый объект Type может использоваться 
с классами, реализующими отражение для получения информации о типе в виде метаданных. Метод GetType невиртуальный, его нельзя переопределить, поэтому классу не удастся 
исказить сведения о своем типе; таким образом обеспечивается безопасность типов
	
	Кроме того, типам, производным от System.Object, доступны некоторые защищенные методы
 - MemberwiseClone этот невиртуальный метод создает новый экземпляр типа и присваивает полям нового объекта соответствующие значения объекта this. Возвращается 
ссылка на созданный экземпляр
 - Finalize - этот виртуальный метод вызывается, когда уборщик мусора определяет, что объект является мусором, но до возвращения занятой объектом памяти в кучу. 
В типах, требующих очистки при сборке мусора, следует переопределить этот метод. 

CLR требует, чтобы все объекты создавались оператором new. Например, объект Employee создается следующим образом: Employee e = new Employee("ConstructorParam1");

		Оператор new выполняет следующие действия:
	Вычисляет количества байт, необходимых для хранения всех экземплярных полей типа и всех его базовых типов.
	Для каждого объекта в кучи добавляет дополнительные члены, указатель на объект-тип (type object pointer) и индекс блока синхронизации (sync block index).
Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого объекта.
	Выдялет и резервирует необходимое количество памяти в управляемой куче. Выделенные байты инициализируются нулями (0).
	Инициализация указателя на объект-тип и индекса блока синхронизации.
	Вызов конструктора экземпляра типа с параметрами, указанными при вызове new.
	А так же вызывается конструктор System.Object, но он ничего не делает и просто возвращает управление.
	В итоге new возвращает ссылку на вновь созданный объект.

					Приведение типов
	CLR разрешает привести тип объекта к его собственному типу или любому из его базовых типов. В C# нет специального синтаксиса для приведения типа объекта к его базовому типу, 
поскольку такое приведение считается безопасным неявным преобразованием
Однако для приведения типа к производному от него типу разработчик должен ввести операцию явного приведения типов — неявное преобразование приведет к ошибке. 
Следующий пример демонстрирует приведение к базовому и производному типам:
Object o = new Employee();
Employee e = (Employee) o;

InvalidCastException - в период выполнения

					Приведение типов в C# с помощью операторов is и as
Оператор is проверяет совместимость объекта с данным типом и возвращает true или false. Оператор is никогда не генерирует исключение.  Взгляните на следующий код:
Object o = new Object(); 
Boolean b1 = (o is Object); // b1 равно true
Boolean b2 = (o is Employee); // b2 равно false

Для null-ссылок оператор is всегда возвращает false, так как объекта, тип которого нужно проверить, не существует.
Обычно оператор is используется следующим образом:
	if (o is Employee) { 
		Employee e = (Employee) o; 
		// Используем e внутри инструкции if
	}
	Поскольку такая схема встречается в программировании часто, в C# предложен механизм, повышающий эффективность кода с помощью оператора as:
	Employee e = o as Employee; 
	if (e != null) { 
		// Используем e внутри инструкции if
	} 
	as возвращает ненулевой указатель на этот объект, а если нет — оператор as возвращает null. При этом верифицирует тип объекта только один раз, 
а if лишь сравнивает e с null — такая проверка намного эффективнее, чем определение типа объекта. Если не сравнить полученный оператором результат 
с null и попытаться работать с пустой ссылкой, возникнет исключение System.NullReferenceException.

					Пространства имен и сборки
Пространства имен используются для логической группировки родственных типов, чтобы разработчику было проще найти нужный тип. 
директива using. 
псевдоним
В C# директива namespace заставляет компилятор добавлять к каждому имени типа определенную приставку — это избавляет программиста от необходимости писать массу лишнего кода
Для компилятора пространство имен — простое средство, позволяющее удлинить имя типа и сделать его уникальным за счет добавления к началу имени групп 
символов, разделенных точками.

					Как разные компоненты взаимодействуют во время выполнения - не поняль
После создания потоку выделяется стек размером в 1 Мбайт. Выделенная память используется для передачи параметров в методы и хранения определенных в пределах методов 
локальных переменных. Стеки заполняются от области верхней памяти к области нижней памяти (то есть от 
старших к младшим адресам)

При выполнении входного кода M3 в стеке потока выделяется память для локальных переменных (рис. 4.8). В частности, CLR автоматически инициализирует все локальные переменные 
значением null или 0 (нулем) — это делается в рамках выполнения входного кода метода. Однако при попытке обращения к локальной переменной, неявно инициализированной 
в вашем коде, компилятор С# выдаст сообщение об ошибке Use of unassigned local variable (использование неинициализированной локальной переменной).


						Глава 5. Примитивные, ссылочные и значимые типы
						
Типы данных, которые поддерживаются компилятором напрямую, называются примитивными (primitive types); у них существуют прямые аналоги в библиотеке 
классов .NET Framework Class Library (FCL). Например, типу int языка C# соответствует System.Int32

C# разрешает неявное приведение типа, если это преобразование «безопасно», то есть не сопряжено с потерей данных; пример — преобразование из Int32 в Int64.
Однако для преобразования с риском потери данных C# требует явного приведения типа. Для числовых типов «небезопасное» преобразование означает «связанное с потерей 
точности или величины числа». Например, преобразование из Int32 в Byte требует явного приведения к типу, так как при больших величинах Int32 теряется точность; 
требует приведения и преобразование из Single в Int16, поскольку число Single может оказаться больше, чем допустимо для Int16

Помимо приведения, компилятор «знает» и о другой особенности примитивных типов: к ним применима литеральная форма записи. Литералы сами по себе считаются экземплярами типа, 
поэтому можно вызывать экземплярные методы, например, следующим образом:
Console.WriteLine(123.ToString() + 456.ToString()); // "123456"
Кроме того, благодаря тому, что выражения, состоящие из литералов, вычисляются на этапе компиляции, возрастает скорость выполнения приложения.

						Проверяемые и непроверяемые операции для примитивных типов
Программистам должно быть хорошо известно, что многие арифметические операции над примитивными типами могут привести к переполнению:
Byte b = 100;
b = (Byte) (b + 200);// После этого b равно 44 (2C в шестнадцатеричной записи)

И C# предлагает такой механизм гибкого управления проверкой в виде операторов checked и unchecked. Например (предполагается, что компилятор по умолчанию создает код без проверки):
UInt32 invalid = unchecked((UInt32) -1); // OK

А вот пример с использованием оператора checked:
Byte b = 100; // Выдается исключение
b = checked((Byte) (b + 200)); // OverflowException
Здесь b и 200 преобразуются в 32-разрядные числа и суммируются; результат равен 300. Затем при преобразовании 300 в Byte генерируется исключение OverflowException

						Ссылочные и значимые типы
CLR поддерживает две разновидности типов: ссылочные (reference types) и значимые (value types). Большинство типов в FCL — ссылочные, но программисты чаще 
всего используют значимые. Память для ссылочных типов всегда выделяется из управляемой кучи, а оператор C# new возвращает адрес в памяти, где размещается 
сам объект. При работе со ссылочными типами необходимо учитывать следующие обстоятельства, относящиеся к производительности приложения:
	память для ссылочных типов всегда выделяется из управляемой кучи;
	каждый объект, размещаемый в куче, содержит дополнительные члены, подлежащие инициализации;
	незанятые полезной информацией байты объекта обнуляются (это касается полей);
	размещение объекта в управляемой куче со временем инициирует сборку мусора.

Если бы все типы были ссылочными, эффективность приложения резко упала бы. Чтобы ускорить обработку простых, часто используемых типов CLR предлагает «облегченные» 
типы — значимые. Экземпляры этих типов обычно размещаются в стеке потока (хотя они могут быть встроены и в объект ссылочного типа). В представляющей 
экземпляр переменной нет указателя на экземпляр; поля экземпляра размещаются в самой переменной. Поскольку переменная содержит поля экземпляра, то для работы с 
экземпляром не нужно выполнять разыменование (dereference) экземпляра. Благодаря тому, что экземпляры значимых типов не обрабатываются уборщиком 
мусора, уменьшается интенсивность работы с управляемой кучей и сокращается количество сеансов уборки мусора, необходимых приложению на протяжении его существования

В свою очередь, значимые типы в документации называются структурами (structure) и перечислениями (enumeration). Все структуры являются прямыми потомками 
абстрактного типа System.ValueType, который, в свою очередь, является производным от типа System.Object. По умолчанию все значимые типы должны быть производными от System.ValueType. 
Все перечисления являются производными от типа System.Enum, производного от System.ValueType.
Значимый тип может реализовать один или несколько выбранных вами интерфейсов. Кроме того, в CLR значимый тип является изолированным, то есть он не может служить 
базовым типом для какого-либо другого ссылочного или значимого типа. Поэтому, например, нельзя в описании нового типа указывать в качестве базовых типы

SomeRef r1 = new SomeRef(); // Размещается в куче
 SomeVal v1 = new SomeVal(); // Размещается в стеке
 r1.x = 5; // Разыменовывание указателя
 v1.x = 5; // Изменение в стеке
 
 SomeRef r2 = r1; // Копируется только ссылка (указатель)
 SomeVal v2 = v1; // Помещаем в стек и копируем члены
 r1.x = 8; // Изменяются r1.x и r2.x
 v1.x = 9; // Изменяется v1.x, но не v2.x
 
Может показаться, что экземпляр SomeVal будет помещен в управляемую кучу. Однако поскольку компилятор C# «знает», что SomeVal является значимым типом, 
в сгенерированном им коде экземпляр SomeVal будет помещен в стек потока. C# также обеспечивает обнуление всех полей экземпляра значимого типа

Основное достоинство значимых типов в том, что они не размещаются в управляемой куче. Конечно, в сравнении со ссылочными типами у значимых типов есть недостатки. 
Важнейшие отличия между значимыми и ссылочными типы:

	Объекты значимого типа существуют в двух формах : неупакованной (unboxed) и упакованной (boxed). Ссылочные типы бывают только в упакованной форме.
	Значимые типы являются производными от System.ValueType. Этот тип имеет те же методы, что и System.Object. Однако System.ValueType переопределяет метод Equals, который 
возвращает true, если значения полей в обоих объектах совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode, который создает хеш-код по алгоритму, 
учитывающему значения полей экземпляра объекта. Из-за проблем с производительностью в реализации по умолчанию, определяя собственные значимые типы значений, надо переопределить 
и написать свою реализацию методов Equals и GetHashCode.
	Поскольку в объявлении нового значимого или ссылочного типа нельзя указывать значимый тип в качестве базового класса, создавать в значимом типе новые виртуальные методы нельзя. 
Методы не могут быть абстрактными и неявно являются запечатанными (то есть их нельзя переопределить).
	Переменные ссылочного типа содержат адреса объектов в куче. Когда переменная ссылочного типа создается, ей по умолчанию присваивается null. Попытка задействовать переменную 
с таким значением приведет к генерации исключения NullReferenceException. В то же время в переменной значимого типа всегда содержится некое значение соответствующего типа, 
а при инициализации всем членам этого типа присваивается 0. Поскольку переменная значимого типа не является указателем, при обращении к значимому типу 
исключение NullReferenceException возникнуть не может. 
	Когда переменной значимого типа присваивается другая переменная значимого типа, выполняется копирование всех ее полей. Когда переменной ссылочного типа присваивается 
переменная ссылочного типа, копируется только ее адрес.
	Вследствие сказанного в предыдущем пункте несколько переменных ссылочного типа могут ссылаться на один объект в куче, благодаря чему, работая с одной 
переменной, можно изменить объект, на который ссылается другая переменная. В то же время каждая переменная значимого типа имеет собственную копию данных «объекта», 
поэтому операции с одной переменной значимого типа не влияют на другую переменную.
	Так как неупакованные значимые типы не размещаются в куче, отведенная для них память освобождается сразу при возвращении управления методом, в котором описан экземпляр 
этого типа (в отличие от ожидания уборки мусора).

						Упаковка и распаковка значимых типов
Для преобразования значимого типа в ссылочный служит упаковка (boxing). 
При упаковке экземпляра значимого типа происходит следующее.
1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя дополнительными членами — указателем на типовой объект и индексом блока синхронизации. 
2. Поля значимого типа копируются в память, только что выделенную в куче.
3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть значимый тип превращается в ссылочный.

Познакомившись с упаковкой, перейдем к распаковке. Допустим, в другом месте кода нужно извлечь первый элемент массива ArrayList:
Point p = (Point) a[0]; 

Здесь ссылка (или указатель), содержащаяся в элементе с номером 0 массива ArrayList, помещается в переменную p значимого типа Point. Для этого все поля, 
содержащиеся в упакованном объекте Point, надо скопировать в переменную p значимого типа, находящуюся в стеке потока. CLR выполняет эту процедуру в два 
этапа. Сначала извлекается адрес полей Point из упакованного объекта Point. Этот процесс называют распаковкой (unboxing). Затем значения полей копируются из 
кучи в экземпляр значимого типа, находящийся в стеке. Распаковка не является точной противоположностью упаковки. Она гораздо менее ресурсозатратна, чем упаковка, и 
состоит только в получении указателя на исходный значимый тип (поля данных), содержащийся в объекте. В сущности, указатель ссылается на неупакованную часть упакованного 
экземпляра, и никакого копирования при распаковке (в отличие от упаковки) не требуется. Однако вслед за распаковкой обычно выполняется копирование полей

При распаковке упакованного значимого типа происходит следующее.
1. Если переменная, содержащая ссылку на упакованный значимый тип, равна null, генерируется исключение NullReferenceException.
2. Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа, генерируется исключение InvalidCastException1

Из второго пункта следует, что приведенный ниже код не работает так, как 
хотелось бы:
public static void Main() { 
 Int32 x = 5; 
 Object o = x; // Упаковка x; o указывает на упакованный объект
 Int16 y = (Int16) o; // Генерируется InvalidCastException
} 

Казалось бы, можно взять упакованный экземпляр Int32, на который указывает o, и привести к типу Int16. Однако при распаковке объекта должно быть выполнено приведение к неупакованному типу
(в нашем случае — к Int32). Вот как выглядит правильный вариант:
public static void Main() { 
 Int32 x = 5; 
 Object o = x; // Упаковка x; o указывает на упакованный объект
 Int16 y = (Int16)(Int32) o; // Распаковка, а затем приведение типа
}

Обычно упаковка выполняется, когда надо передать значимый тип методу, требующему ссылочный тип. Однако могут быть и другие ситуации, когда требуется упаковать 
экземпляр значимого типа. Помните, мы говорили, что неупакованные значимые типы «легче» ссылочных, поскольку:
	память в управляемой куче им не выделяется;
	у них нет дополнительных членов, присущих каждому объекту в куче: указателя на типовой объект и индекса блока синхронизации.
Поскольку неупакованные значимые типы не имеют индекса блока синхронизации, то не может быть и нескольких потоков, синхронизирующих свой доступ 
к экземпляру через методы типа System.Threading.Monitor (или инструкция lock языка C#).

Хотя неупакованные значимые типы не имеют указателя на типовой объект, вы все равно можете вызывать виртуальные методы (такие, как Equals, GetHashCode
или ToString), унаследованные или прееопределенные этим типом. Если ваш значимый тип переопределяет один из этих виртуальных методов, CLR может вызвать 
метод невиртуально, потому что значимые типы неявно запечатываются и поэтому не могут выступать базовыми классами других типов. Кроме того, экземпляр значимого типа, 
используемый для вызова виртуального метода, не упаковывается. 
Но если ваше переопределение виртуального метода вызывает реализацию этого метода из базового типа, экземпляр значимого типа упаковывается при вызове реализации базового типа, 
чтобы в указателе this базового метода передавалась ссылка на объект в куче.
Вместе с тем вызов невиртуального унаследованного метода (такого, как GetType или MemberwiseClone) всегда требует упаковки значимого типа, так как эти методы 
определены в System.Object, поэтому методы ожидают, что в аргументе this передается указатель на объект в куче.
Кроме того, приведение неупакованного экземпляра значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как интерфейсные переменные 
всегда должны содержать ссылку на объект в куче

							Равенство и тождество объектов
Для проверки на тождественность нужно всегда вызывать ReferenceEquals (то есть проверять на предмет того, относятся ли две ссылки к одному объекту). Не 
нужно использовать оператор == языка C# (если только перед этим оба операнда не приводятся к типу Object), так как тип одного из операндов может перегружать 
этот оператор, в результате чего его семантика перестает соответствовать понятию «тождественность»

Определяя собственный тип и приняв решение переопределить Equals, обеспечьте поддержку четырех характеристик, присущих равенству:
	Рефлексивность: x.Equals(x) должно возвращать true.
	Симметричность: x.Equals(y) и y.Equals(x) должны возвращать одно и то же значение.
	Транзитивность: если x.Equals(y) возвращает true и y.Equals(z) возвращает true, то x.Equals(z) также должно возвращать true.
	Постоянство: если в двух сравниваемых значениях не произошло изменений, результат сравнения тоже не должен измениться.

							Хеш-коды объектов
Разработчики FCL решили, что было бы чрезвычайно полезно иметь возможность добавления в хеш-таблицы любых экземпляров любых типов. С этой целью 
в System.Object включен виртуальный метод GetHashCode, позволяющий вычислить для любого объекта целочисленный (Int32) хеш-код.
Если вы определяете тип и переопределяете метод Equals, вы должны переопределить и метод GetHashCode. Если при определении типа переопределить 
только один из этих методов, компилятор C# выдаст предупреждение. 
Причина, по которой в типе должны быть определены оба метода — Equals и GetHashCode, — состоит в том, что реализация типов System.Collections.Hashtable, 
System.Collections.Generic.Dictionary и любых других коллекций требует, чтобы два равных объекта имели одинаковые значения хеш-кодов. Поэтому, переопределяя Equals, 
нужно переопределить GetHashCode и обеспечить соответствие алгоритма, применяемого для вычисления равенства, алгоритму, используемому для вычисления хеш-кода объекта.
Выбирая алгоритм вычисления хеш-кодов для экземпляров своего типа, старайтесь следовать определенным правилам:
	Используйте алгоритм, который дает случайное распределение, повышающее производительность хеш-таблицы.
	Алгоритм может вызывать метод GetHashCode базового типа и использовать возвращаемое им значение, однако в общем случае лучше отказаться от вызова 
встроенного метода GetHashCode для типа Object или ValueType, так как эти реализации обладают низкой производительностью алгоритмов хеширования.
	В алгоритме должно использоваться как минимум одно экземплярное поле.
	Поля, используемые в алгоритме, в идеале не должны изменяться, то есть они должны инициализироваться при создании объекта и сохранять значение в течение всей его жизни.
	Алгоритм должен быть максимально быстрым.
	Объекты с одинаковым значением должны возвращать одинаковые коды. Например, два объекта String, содержащие одинаковый текст, должны возвращать одно значение хеш-кода

							Примитивный тип данных dynamic
	Тип dynamic можно использовать для определения аргументов типов обобщенных классов (ссылочный тип), структур (значимый тип), интерфейсов, делегатов или методов. 
Когда вы это делаете, компилятор конвертирует тип dynamic в Object и применяет DynamicAttribute к различным частям метаданных, где это необходимо. Обратите внимание, 
что обобщенный код, который вы используете, уже скомпилирован в соответствии с типом Object, и динамическая отправка не осуществляется, поскольку компилятор не производит 
код полезной нагрузки в обобщенном коде.
Любое выражение может быть явно приведено к dynamic, поскольку все выражения дают в результате тип, производный от Object1. В общем случае компилятор не позволит вам написать код 
с неявным приведением выражения от типа Object к другому типу, вы должны использовать явное приведение типов. Однако компилятор разрешит выполнить приведение типа dynamic к 
другому типу с использованием синтаксиса неявного приведения.

Object o1 = 123; // OK: Неявное приведение Int32 к Object (упаковка)
Int32 n1 = o1; // Ошибка: Нет неявного приведения Object к Int32
Int32 n2 = (Int32) o1; // OK: Явное приведение Object к Int32 (распаковка)
dynamic d1 = 123; // OK: Неявное приведение Int32 к dynamic (упаковка)
Int32 n3 = d; // OK: Неявное приведение dynamic к Int32 (распаковка)

Пока компилятор позволяет пренебрегать явным приведением динамического типа к другому типу данных, среда CLR на этапе выполнения проверяет правильность приведения с целью 
обеспечения безопасности типов. Если тип объекта несовместим с приведением, CLR выдает исключение InvalidCastException.
Обратите внимание на следующий код:
dynamic d = 123;
var result = M(d); // 'var result' - то же, что 'dynamic result'

Здесь компилятор позволяет коду компилироваться, потому что на этапе компиляции он не знает, какой из методов M будет вызван
						
						Глава 6. Основные сведения о членах и типах
Члены типа
В типе можно определить следующие члены.
	Константа — идентификатор, определяющий некую постоянную величину. Эти идентификаторы обычно используют, чтобы упростить чтение кода, а также 
для удобства сопровождения и поддержки. Константы всегда связаны с типом, а не с экземпляром типа, а на логическом уровне константы всегда являются 
статическими членами. Подробнее о константах см. главу 7.
	Поле представляет собой значение данных, доступное только для чтения или для чтения/записи. Поле может быть статическим — тогда оно является частью 
состояния типа. Поле может быть экземплярным (нестатическим) — тогда оно является частью состояния конкретного объекта. Я настоятельно рекомендую 
ограничивать доступ к полям, чтобы внешний код не мог нарушить состояние типа или объекта. Подробнее о полях см. главу 7.
	Конструктор экземпляров — метод, служащий для инициализации полей экземпляра при его создании. Подробнее о конструкторах экземпляров см. главу 8.
	Конструктор типа — метод, используемый для инициализации статических полей типа. Подробнее о конструкторах типа см. главу 8.
	Метод представляет собой функцию, выполняющую операции, которые изменяют или запрашивают состояние типа (статический метод) или объекта (экземплярный метод). 
Методы обычно осуществляют чтение и запись полей типов или объектов. Подробнее о методах см. главу 8.
	Перегруженный оператор определяет, что нужно проделать с объектом при применении к нему конкретного оператора. Перегрузка операторов не входит 
в общеязыковую спецификацию CLS, поскольку не все языки программирования ее поддерживают. Подробнее о перегруженных операторах см. главу 8.
	Оператор преобразования — метод, задающий порядок явного или неявного преобразования объекта из одного типа в другой. Операторы преобразования 
не входят в спецификацию CLS по той же причине, что и перегруженные операторы. Подробнее об операторах преобразования см. главу 8.
	Свойство представляет собой механизм, позволяющий применить простой синтаксис (напоминающий обращение к полям) для установки или получения 
части логического состояния типа или объекта с контролем логической целостности этого состояния. Свойства бывают необобщенными (распространенный 
случай) и обобщенными (встречаются редко, в основном в классах коллекций). Подробнее о свойствах см. главу 10.
	Событие — механизм статических событий позволяет типу отправлять уведомления статическим или экземплярным методам. Механизм экземплярных 
(нестатических) событий позволяет объекту посылать уведомление статическому или экземплярному методу. События обычно инициируются в ответ на 
изменение состояния типа или объекта, порождающего событие. Событие состоит из двух методов, позволяющих статическим или экземплярным методам 
регистрировать и отменять регистрацию (подписку) на событие. Помимо этих двух методов, в событиях обычно используется поле-делегат для управления 
набором зарегистрированных методов. Подробнее о событиях см. главу 11.
	Тип позволяет определять другие вложенные в него типы. Обычно этот подход применяется для разбиения большого, сложного типа на небольшие блоки 
с целью упростить его реализацию

							Видимость типа
При определении типа с видимостью в рамках файла, а не другого типа его можно сделать открытым (public) или внутренним (internal). Открытый тип доступен 
любому коду любой сборки. Внутренний тип доступен только в той сборке, где он определен. По умолчанию компилятор C# делает тип внутренним (с более ограниченной видимостью).
						
							Дружественные сборки
и C# предусмотрен механизм дружественных сборок (friend assemblies).
В процессе создания сборки можно указать другие сборки, которые она будет считать «друзьями», — для этого служит атрибут InternalsVisibleTo, определенный в пространстве 
имен System.Runtime.CompilerServices. У атрибута есть строковый параметр, определяющий имя дружественной сборки и ее открытый ключ (передаваемая атрибуту строка не должна 
содержать информацию о версии, региональных стандартах или архитектуре процессора). Заметьте, что дружественные сборки получают доступ ко всем внутренним типам сборки, 
а также к внутренним членам этих типов.

							Доступ к членам типов
При определении члена типа (в том числе вложенного) можно указать модификатор доступа к члену. Модификаторы определяют, на какие члены можно ссылаться из кода.
private Доступен только методам в определяющем типе и вложенных в него типах
protected Доступен только методам в определяющем типе (и вложенных в него типах) или в одном из его производных типов независимо от сборки
internal Доступен только методам в определяющей сборке
protected internal Доступен только методам вложенного типа, производного типа (независимо от сборки) и любым методам определяющей сборки
public Доступен всем методам во всех сборках

Если в производном типе переопределяется член базового типа, компилятор C# требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. 
То есть если член базового класса является защищенным, то и член производного класса должен быть защищенным. Однако это ограничение языка C#, а не CLR. При наследовании 
от базового класса CLR позволяет снижать, но не повышать ограничения доступа к члену. Например, защищенный метод базового класса можно переопределить в производном классе в открытый, 
но не в закрытый. Дело в том, что пользователь производного класса всегда может получить доступ к методу базового класса путем приведения к базовому типу

							Статические класс
У этих классов есть только статические методы. В сущности, такие классы существуют лишь для группировки логически связанных членов. Например, класс Math объединяет методы, 
выполняющие математические операции. В C# такие классы определяются с ключевым словом static. Его разрешается применять только к классам, но не к структурам (значимым типам), 
поскольку CLR всегда разрешает создавать экземпляры значимых типов, и нет способа обойти это ограничение.
Компилятор налагает на статический класс ряд ограничений.
	Класс должен быть прямым потомком System.Object — наследование любому другому базовому классу лишено смысла, поскольку наследование применимо 
только к объектам, а создать экземпляр статического класса невозможно.
	Класс не должен реализовывать никаких интерфейсов, поскольку методы интерфейса можно вызывать только через экземпляры класса.
	В классе можно определять только статические члены (поля, методы, свойства и события). Любые экземплярные члены вызовут ошибку компиляции.
	Класс нельзя использовать в качестве поля, параметра метода или локальной переменной, поскольку это подразумевает существование переменной, ссылающейся на экземпляр, что запрещено
Обнаружив подобное обращение со статическим классом, компилятор вернет сообщение об ошибке

C# сделать этот класс абстрактным (abstract) и запечатанным (sealed). Более того, компилятор не создает в классе метод конструктора экземпляров (.ctor)

							Частичные классы, структуры и интерфейсы
Ключевое слово partial говорит компилятору C#, что исходный код класса, структуры или интерфейса может располагаться в нескольких файлах.
Есть три основные причины, по которым исходный код разбивается на несколько файлов.
	Управление версиями. Представьте, что определение типа содержит большой объем исходного кода. Если этот тип будут одновременно редактировать два 
программиста, по завершении работы им придется каким-то образом объединять свои результаты, что весьма неудобно. Ключевое слово partial позволяет разбить исходный код типа на 
несколько файлов, чтобы один и тот же тип могли одновременно редактировать несколько программистов.
	Разделение файла или структуры на логические модули внутри файла. Иногда требуется создать один тип для решения разных задач. Для упрощения реализации я иногда 
объявляю одинаковые типы повторно внутри одного файла. Затем в каждой части такого типа я реализую по одному функциональному аспекту типа со всеми его полями, методами, 
свойствами, событиями и т. д. Это позволяет мне упростить наблюдение за членами, обеспечивающими единую функциональность и объединенными в группу. 
Я также могу легко закомментировать частичный тип с целью удаления всей функциональности из класса или замены ее другой (путем использования новой части частичного типа).
	Разделители кода. При создании в Microsoft Visual Studio нового проекта Windows Forms или Web Forms некоторые файлы с исходным кодом создаются 
автоматически. Они называются шаблонными. При использовании конструкторов форм Visual Studio в процессе создания и редактирования элементов управления формы автоматически 
генерирует весь необходимый код и помещает его в отдельные файлы. Это значительно повышает продуктивность работы. Раньше автоматически генерируемый код попадал в тот же файл, где 
программист писал свой исходный код. Однако при случайном изменении сгенерированного кода конструктор форм переставал корректно работать. Начиная с Visual Studio 2005, 
при создании нового проекта Visual Studio создает два исходных файла: один предназначен для программиста, а в другой помещается код, создаваемый редактором форм. В результате 
вероятность случайного изменения генерируемого кода существенно снижается

	Компоненты, полиморфизм и версии
В .NET номер версии состоит из четырех частей: основного (major) и дополнительного (minor) номеров версии, номера построения (build) и номера редакции (revision). 
Например, у сборки с номером 1.2.3.4 основной номер версии — 1, дополнительный номер версии — 2, номер построения — 3 и номер редакции — 4. 
В то же время, если компания выпустит новую версию сборки, в которую внесены значительные изменения, а обратная совместимость не гарантируется, нужно 
изменить основной и/или дополнительный номер версии (например, 3.0.0.0).
Проблемы управления версиями возникают, когда тип, определенный в одном компоненте (сборке), используется в качестве базового класса для типа другого 
компонента (сборки). Ясно, что изменения в базовом классе могут повлиять на поведение производного класса. Эти проблемы особенно характерны для полиморфизма, когда в 
производном типе переопределяются виртуальные методы базового типа.

							Вызов виртуальных методов, свойств и событий в CLR
В этом разделе речь идет только о методах, но все сказанное относится и к виртуальным свойствам и событиям, поскольку они, как показано далее, на самом деле реализуются методами.
Методы содержат код, выполняющий некоторые действия над типом (статические методы) или экземпляром типа (нестатические). 
	У каждого метода есть имя, сигнатура и возвращаемый тип, который может быть пустым (void). 
	У типа может быть несколько методов с одним именем, но с разным числом параметров или разными возвращаемыми значениями. 
	Можно также определить два метода с одним и тем же именем и параметрами, но с разными типами возвращаемого значения.
	
При проектировании типа следует стремиться свести к минимуму количество виртуальных методов. 
Во-первых, виртуальный метод вызывается медленнее невиртуального. 
Во-вторых, JIT-компилятор не может подставлять (inline) виртуальные методы, что также ухудшает производительность. 
В-третьих, как показано далее, виртуальные методы затрудняют управление версиями компонентов. 
В-четвертых, при определении базового типа часто создается набор перегруженных методов. Чтобы сделать их полиморфными, лучше всего сделать наиболее сложный метод 
виртуальным, оставив другие методы невиртуальными. Кстати, соблюдение этого правила поможет управлять версиями компонентов, не нарушая работу производных типов.

							Работа с виртуальными методами при управлении версиями типов
new, virtual, override

							Глава 7. Константы и поля

Константа (constant) — это идентификатор, значение которого никогда не меняется. Значение, связанное с именем константы, должно определяться во время 
компиляции. Затем компилятор сохраняет значение константы в метаданных модуля. Это значит, что константы можно определять только для таких типов, 
которые компилятор считает примитивными. 
	В C# следующие типы считаются примитивными и могут использоваться для определения констант: 
	Boolean, Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal и String. 
Тем не менее C# позволяет определить константную переменную, не относящуюся к элементарному типу, если присвоить ей значение null:

Так как значение констант никогда не меняется, константы всегда считаются частью типа. Иначе говоря, константы считаются статическими, а не экземплярными членами. 
Определение константы приводит в конечном итоге к созданию метаданных. Кроме того, нельзя получать адрес константы и передавать ее по ссылке. Эти ограничения также означают, что 
изменять значения константы в разных версиях модуля нельзя, поэтому константу надо использовать, только когда точно известно, что ее значение никогда не изменится
если модуль должен задействовать значение, определенное в другом модуле. В этом случае вместо констант следует использовать предназначенные только для чтения поля
							
							Поля
Поле (field) — это член данных, который хранит экземпляр значимого типа или ссылку на ссылочный тип. 
Ниже приведены модификаторы, применяемые по отношению к полям:
	Static - поле является частью состояния типа, а не объекта. 
	По умолчанию - поле связано с экземпляром типа, а не самим типом 
	readonly - запись в поле разрешается только из кода конструктора
	volatile - Код, обращающийся к полю, не должен оптимизироваться компилятором, CLR или оборудованием с целью обеспечения безопасности потоков. Неустойчивыми (volatile) 
могут объявляться только следующие типы: все ссылочные типы, Single, Boolean, Byte, SByte, Int16, UInt16, Int32, UInt32, Char, 
а также все перечислимые типы, основанные на типе Byte, SByte, Int16, UInt16, Int32 или  UInt32. Неустойчивые поля рассматриваются в главе 2
 
Поскольку поля хранятся в динамической памяти, их значения можно получить лишь в период выполнения. Динамическая память для хранения экземплярных полей выделяется при 
создании экземпляра данного типа.
CLR поддерживает поля, предназначенные для чтения и записи (изменяемые), а также поля, предназначенные только для чтения (неизменяемые). Большинство 
полей изменяемые. Это значит, что во время исполнения кода значение таких полей может многократно меняться. Данные же в неизменяемые поля можно записывать 
только при исполнении конструктора (который вызывается лишь раз — при создании объекта). 

Неизменность поля ссылочного типа означает неизменность ссылки, которую этот тип содержит, а вовсе не объекта, на которую указывает ссылка
// InvalidChars всегда ссылается на один объект массива
 public static readonly Char[] InvalidChars = new Char[] { 'А', 'В', 'C'}
 // Следующие строки кода вполне корректны, компилируютсяи успешно изменяют символы в массиве InvalidChars
 АТуре.InvalidChars[0] = 'X'
 // Следующая строка некорректна и не скомпилируется, так как ссылка InvalidChars изменяться не может
 АТуре.InvalidChars = new Char[] { 'X', 'Y', 'Z' }
 
							Глава 8. Метод
						Конструкторы экземпляров и классы
Конструкторы — это специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений, входящих в метаданные, методы-конструкторы всегда 
отмечают сочетанием .ctor (от constructor). При создании экземпляра объекта ссылочного типа выделяется память для полей данных экземпляра и инициализируются 
служебные поля (указатель на объект-тип и индекс блока синхронизации), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.
При конструировании объекта ссылочного типа выделяемая для него память всегда обнуляется до вызова конструктора экземпляра типа. Любые поля, не задаваемые конструктором явно, 
гарантированно содержат 0 или null.
В отличие от других методов конструкторы экземпляров не наследуются. Иначе говоря, у класса есть только те конструкторы экземпляров, которые определены 
в этом классе. Невозможность наследования означает, что к конструктору экземпляров нельзя применять модификаторы virtual, new, override, sealed и abstract. 

	Если определить класс без явно заданных конструкторов, многие компиляторы (в том числе компилятор C#) создадут конструктор по умолчанию (без параметров), реализация которого 
просто вызывает конструктор без параметров базового класса.
	Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой (public). 
Если в базовом классе нет конструктора без параметров, производный класс должен явно вызвать конструктор базового класса, иначе компилятор вернет ошибку. 
	Для статических классов (запечатанных и абстрактных) компилятор не создает конструктор по умолчанию.
	В типе может определяться несколько конструкторов, при этом сигнатуры и уровни доступа к конструкторам обязательно должны отличаться. 
	В случае верифицируемого кода конструктор экземпляров должен вызывать конструктор базового класса до обращения к какому-либо из унаследованных от него полей. 
	В конечном счете всегда вызывается открытый конструктор объекта System.Object без параметров. Этот конструктор ничего не делает — просто возвращает управление 
по той простой причине, что в System.Object не определено никаких экземплярных полей данных, поэтому конструктору просто нечего делать

 Следующий пример иллюстрирует использование способности C# явно заставлять один конструктор вызывать другой конструктор посредством зарезервированного слова this:

							Конструкторы экземпляров и структуры (значимые типы)
Конструкторы значимых типов (struct) работают иначе, чем ссылочных (class). 
CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому, по большому счету, конструкторы у значимого типа можно не определять.
Вообще говоря, CLR позволяет программистам определять конструкторы для значимых типов, но эти конструкторы выполняются лишь при наличии кода, явно вызывающего один из них, 
Конструктор экземпляра значимого типа выполняется только при явном вызове. Так что если конструктор объекта Rectangle не инициализировал его поля m_topLeft и m_bottomRight 
вызовом с помощью оператора new конструктора Point, поля m_x и m_y у обеих структур Point будут содержать 0.

internal sealed class Rectangle {
 public Point m_topLeft, m_bottomRight;
 public Rectangle() {
 }
}
Но я же предупредил, что мой первый вопрос был с подвохом. Подвох в том, что C# не позволяет определять для значимого типа конструкторы без параметров. 
Поэтому показанный код на самом деле даже не компилируется. Кроме того, поскольку верифицируемый код перед чтением любого поля значимого типа требует записывать в него какое-либо 
значение, любой конструктор, определенный для значимого типа, должен инициализировать все поля этого типа. 

							Конструкторы типов
Помимо конструкторов экземпляров, CLR поддерживает конструкторы типов (также известные как статические конструкторы, конструкторы классов и инициализаторы типов). 
	Конструкторы типов можно применять и к ссылочным и значимым типам. 
	Конструкторы типов служат для установки первоначального состояния типа. По умолчанию у типа не определено конструктора. 
	У типа не может быть более одного конструктора; 
	кроме того, у конструкторов типов никогда не бывает параметров
	Кроме того, конструкторы типов всегда должны быть закрытыми (C# делает их закрытыми автоматически). Однако если явно пометить в исходном тексте программы конструктор типа 
как закрытый (или как-то иначе), компилятор C# выведет сообщение об ошибке в статических конструкторах нельзя использовать модификаторы доступа)
	Код конструктора типа может обращаться только к статическим полям типа; обычно это делается, чтобы их инициализировать. Как и в случае экземплярных полей, 

							Методы перегруженных операторов

С точки зрения CLR перегруженные операторы представляют собой просто методы. Спецификация CLR требует, чтобы перегруженные операторные методы были открытыми и статическими. 
Дополнительно C# требует, чтобы у операторного метода тип, по крайней мере, одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод.
	Пример метода перегруженного оператора, заданного в определении класса C#:
	public sealed class Complex {
		public static Complex operator+(Complex c1, Complex c2) { ... }
	}
	
							Методы операторов преобразования
	Если ни один из типов не является примитивным, компилятор генерирует код, заставляющий CLR выполнить преобразование (приведение типов). В этом случае CLR просто проверяет, 
совпадает ли тип исходного объекта с целевым типом (или является производным от целевого). Однако иногда требуется преобразовать объект одного типа в совершенно другой тип.

Для выполнения этих преобразований в типе Rational должны определяться открытые конструкторы, принимающие в качестве единственного параметра экземпляр преобразуемого типа. 
Кроме того, нужно определить открытый экземплярный метод ToXxx, не принимающий параметров (как популярный метод ToString). Каждый такой метод преобразует экземпляр типа, 
в котором определен этот метод, в экземпляр типа Xxx. Вот как правильно определить соответствующие конструкторы и методы для типа Rational:

public sealed class Rational {
 // Создает Rational из Int32
 public Rational(Int32 num) { ... }
 // Создает Rational из Single
 public Rational(Single num) { ... }
 // Преобразует Rational в Int32
 public Int32 ToInt32() { ... }
 // Преобразует Rational в Single
 public Single ToSingle() { ... }
}

Вызывая эти конструкторы и методы, разработчик, используя любой язык, может преобразовать объект типа Int32 или Single в Rational и обратно

Ранее мы обсуждали способы поддержки перегрузки операторов в разных языках. 
Некоторые (например, C#) наряду с этим поддерживают перегрузку операторов преобразования — методы, преобразующие объекты одного типа в объекты другого типа. 
Методы операторов преобразования определяются при помощи специального синтаксиса. 
Спецификация CLR требует, чтобы перегруженные методы преобразования были открытыми и статическими. Кроме того, C# требуют, чтобы у метода преобразования тип, по крайней мере, 
одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод. Причина этого ограничения в том, что оно позволяет компилятору C# 
в разумное время находить кандидатуры операторных методов для привязки. Следующий код добавляет в тип Rational четыре метода операторов преобразования:

public sealed class Rational {
 // Создает Rational из Int32
 public Rational(Int32 num) { ... }
 // Создает Rational из Single
 public Rational(Single num) { ... }
 // Преобразует Rational в Int32
 public Int32 ToInt32() { ... }
 // Преобразует Rational в Single
 public Single ToSingle() { ... }
 // Неявно создает Rational из Int32 и возвращает полученный объект
 public static implicit operator Rational(Int32 num) {
 return new Rational(num); }
 // Неявно создает Rational из Single и возвращает полученный объект
 public static implicit operator Rational(Single num) {
 return new Rational(num); }
 // Явно возвращает объект типа Int32, полученный из Rational
 public static explicit operator Int32(Rational r) {
 return r.ToInt32(); }
 // Явно возвращает объект типа Single, полученный из Rational
 public static explicit operator Single(Rational r) {
 return r.ToSingle();
 }
}

При определении методов для операторов преобразования следует указать, должен ли компилятор генерировать код для их неявного вызова автоматически или лишь при наличии 
явного указания в исходном тексте. Ключевое слово implicit указывает компилятору C#, что наличие в исходном тексте явного приведения типов не обязательно для генерации кода, 
вызывающего метод оператора преобразования. 
Ключевое слово explicit позволяет компилятору вызывать метод только тогда, когда в исходном тексте происходит явное приведение типов.
После ключевого слова implicit или explicit вы сообщаете компилятору, что данный метод представляет собой оператор преобразования (ключевое слово operator). После ключевого 
слова operator указывается целевой тип, в который преобразуется объект, а в скобках — исходный тип объекта.


						Методы расширения
	А сейчас я попробую объяснить, что именно делают методы расширения. Они позволяют вам определить статический метод, который вызывается посредством синтаксиса 
экземплярного метода. Иначе говоря, мы можем определить собственный метод IndexOf — и три проблемы, упомянутые выше, исчезнут. Для того чтобы превратить метод IndexOf в метод 
расширения, мы просто добавим ключевое слово this перед первым аргументом:

public static class StringBuilderExtensions {
 public static Int32 IndexOf(this StringBuilder sb, Char value) {
 for (Int32 index = 0; index < sb.Length; index++)
 if (sb[index] == value) return index;
 return -1;
 }
}

Компилятор увидит следующий код:
Int32 index = sb.IndexOf('X');
Сначала он проверит класс StringBuilder или все его базовые классы, предоставляющие экземплярные методы с именем IndexOf и единственным параметром Char. Если они не существуют, 
тогда компилятор будет искать любой статический класс с определенным методом IndexOf, у которого первый параметр соответствует типу выражения, используемого при вызове метода. 
Этот тип должен быть отмечен при помощи ключевого слова this. В этом случае компилятор ищет метод IndexOf с двумя параметрами: StringBuilder (отмеченное словом this) и Char. 
Компилятор найдет наш метод IndexOf и сгенерирует IL-код для вызова нашего статического метода.

Приведу несколько правил и фактов, которые необходимо знать о методах расширения.
	Язык С# поддерживает только методы расширения, он не поддерживает свойств расширения, событий расширения, операторов расширения и т. д.
	Методы расширения (методы со словом this перед первым аргументом) должны быть объявлены в статическом необобщенном классе. Конечно, метод расширения должен иметь, 
по крайней мере, один параметр, и только первый параметр может быть отмечен ключевым словом this.
	Компилятор C# ищет методы расширения, заданные только в статических классах, определенных в области видимости файла. Другими словами, если вы 
определили статический класс, унаследованный от другого класса, компилятор C# выдаст следующее сообщение (ошибка CS1109: метод расширения должен 
быть определен в статическом классе первого уровня, StringBuilderExtensions является вложенным классом):
 error CS1109: Extension method must be defined in a top-level static
 class; StringBuilderExtensions is a nested class
	Так как статическим классам можно давать любые имена по вашему желанию, компилятору С# необходимо какое-то время для того, чтобы найти методы расширения; он просматривает 
все статические классы, определенные в области файла, и сканирует их статические методы. Для повышения производительности и для того, чтобы не рассматривать лишние в данных 
обстоятельствах методы  расширения, компилятор C# требует «импортирования» методов расширения. 
Например, пусть кто-нибудь определил класс StringBuilderExtensions в пространстве имен Wintellect, тогда другой программист, которому нужно иметь 
доступ к методу расширения данного класса, в начале файла программного кода должен указать команду using Wintellect.
	Существует возможность определения в нескольких статических классах одинаковых методов расширения. Если компилятор выяснит, что существуют два и более методов расширения, 
то тогда он выдает следующее сообщение 
(ошибка CS0121: неоднозначный вызов следующих методов или свойств 
'StringBuilderExtensions.IndexOf(string, char)' и 'AnotherStringBuild
erExtensions.IndexOf(string, char)):
 error CS0121: The call is ambiguous between the following methods
 or properties: 'StringBuilderExtensions.IndexOf(string, char)'
 and 'AnotherStringBuilderExtensions.IndexOf(string, char)'.
Для того чтобы исправить эту ошибку, вы должны модифицировать программный код. Нельзя использовать синтаксис экземплярного метода для вызова статического метода, вместо этого 
должен применяться синтаксис статического метода с указанием имени статического класса, чтобы точно сообщить компилятору, какой именно метод нужно вызвать.
	Прибегать к этому механизму следует не слишком часто, так как он известен не всем разработчикам. Например, когда вы расширяете тип с методом расширения, 
вы действительно расширяете унаследованные типы с этим методом. Следовательно, вы не должны определять метод выражения, чей первый параметр — System.Object, так как этот метод 
будет вызываться для всех типов выражений, и соответствующие ссылки только будут загромождать окно IntelliSense.
	Существует потенциальная проблема с версиями. Если в будущем разработчики Microsoft добавят экземплярный метод IndexOf к классу StringBuilder с тем же прототипом, 
что и в моем примере, то когда я перекомпилирую свой программный код, компилятор свяжет с программой экземплярный метод IndexOf компании Microsoft вместо моего статического 
метода IndexOf. Из-за этого моя программа начнет себя по-другому. Эта проблема версий — еще одна причина, по которой этот механизм следует использовать осмотрительно

							Частичные методы

	Большое преимущество такого решения заключается в том, что вы можете перезапустить программу и сгенерировать новый код в новом файле, а ваш программный код по-прежнему 
останется нетронутым в отдельном файле.  Кроме того, этот подход работает для изолированных классов, статических классов и значимых типов

Несколько дополнительных правил и рекомендаций, касающихся частичных методов.
	Частичные методы могут объявляться только внутри частичного класса или структуры.
	Частичные методы должны всегда иметь возвращаемый тип void и не могут иметь параметров, помеченных ключевым словом out, но может иметь параметры, 
помеченные ключевым словом ref, а также универсальные параметры, экземплярные или статические, или даже параметры, помеченные как unsafe.
	Естественно, определяющее объявление частичного метода и его реализующее объявление должны иметь идентичные сигнатуры. И оба должны иметь настраивающиеся атрибуты, 
применяющиеся к ним, когда компилятор объединяет атрибуты обоих методов вместе. Все атрибуты, применяемые к параметрам, тоже объединяются.
	Если не существует реализующего объявления частичного метода, в вашем коде не может быть попыток создания делегата, ссылающегося на частичный метод. 
Это причина, по которой метод не существует во время выполнения программы. 
Компилятор выдаст следующее сообщение (ошибка CS0762: не могу создать делегата из метода 'Base.OnNameChanging(string)', потому что это частичный 
метод без реализующего объявления):
 "error CS0762: Cannot create delegate from method
 'Base.OnNameChanging(string)' because it is a partial method
 without an implementing declaration
	Хотя частичные методы всегда считаются закрытыми, компилятор C# запрещает писать ключевое слово private перед объявлением частичного метода


							Глава 9. Параметры
						
						Необязательные и именованные параметры
						
						Правила использования параметров
						
Определяя метод, задающий для части своих параметров значения по умолчанию, следует руководствоваться следующими правилами:
	Значения по умолчанию указываются для параметров методов, конструкторов методов и параметрических свойств (индексаторов C#). Также их можно указывать для параметров, 
являющихся частью определения делегатов. В результате при вызове этого типа делегата аргументы можно опускать, используя их значения по умолчанию.
	Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами. Другими словами, если указан параметр со значением по умолчанию, 
значения по умолчанию должны иметь и все параметры, расположенные справа от него. Существует только одно исключение из правил — параметр массива, помеченный ключевым 
словом params. Он должен располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию. При этом сам массив значения по умолчанию иметь не может.
	Во время компиляции значения по умолчанию должны оставаться неизменными. То есть задавать значения по умолчанию можно для параметров примитивных 
типов, перечисленных в табл. 5.1 главы 5. Сюда относятся также перечислимые типы и ссылочные типы, допускающие присвоение значения null. Для параметров произвольного значимого 
типа значение по умолчанию задается как экземпляр этого типа с полями, содержащими нули. Можно использовать 
как ключевое слово default, так и ключевое слово new, в обоих случаях генерируется одинаковый IL-код. С примерами обоих вариантов синтаксиса мы уже 
встречались в методе M при задании значений по умолчанию для параметров dt и guid соответственно.
	При вызове метода извне модуля изменение значения параметров по умолчанию является потенциально опасным. Вызывающая сторона использует значение по умолчанию в процессе работы. 
Если изменить его и не перекомпилировать код, содержащий вызов, в вызываемый метод будет передано прежнее значение. В качестве индикатора поведения можно использовать 
значение по умолчанию 0 или null. В результате исчезает необходимость повторной компиляции кода вызывающей стороны.
	Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.

	Аргументы можно передавать в произвольном порядке; но именованные аргументы должны находиться в конце списка.
	Передача аргумента по имени возможна для параметров, не имеющих значения по умолчанию, но при этом компилятору должны быть переданы все аргументы, 
необходимые для компиляции (c указанием их позиции или имени).
	Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out
	// Объявление метода:
 private static void M(ref Int32 x) { ... }
 // Вызов метода:
 Int32 a = 5;
 M(x: ref a);		

								Неявно типизированные локальные переменные
	В C# поддерживается возможность определения типа используемых в методе локальных переменных по типу используемого при их инициализации выражение
	var name = "Jeff";
Первая строка кода метода ImplicitlyTypedLocalVariables вводит новую локальную переменную при помощи ключевого слова var. Чтобы определить ее тип, компилятор смотрит на тип 
выражения с правой стороны от оператора присваивания (=). Так как "Jeff" — это строка, компилятор присваивает переменной name тип String

							Передача параметров в метод по ссылке
	По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передается ссылка на этот объект. То есть метод 
может изменить переданный объект, влияя на состояние вызывающего кода. Если параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод 
получает собственную копию объекта, а исходный экземпляр сохраняется неизменным

CLR также позволяет передавать параметры по ссылке, а не по значению. В C# это делается с помощью ключевых слов out и ref. 
С точки зрения CLR, ключевые слова out и ref не различаются, то есть для них генерируются одинаковый IL-код, а метаданные отличаются всего одним битом, указывающим, какое 
ключевое слово было использовано при объявлении метода. 
	Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод. В этом случае вызванный метод 
не может прочитать значение параметра и должен записать его, прежде чем вернуть управление. 
	Если же параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод может как читать, так и записывать значение 
параметра.

Поведение ссылочных и значимых типов при использовании ключевых слов outи ref различается значительно. Вот как это выглядит в случае значимого типа:

public sealed class Program {
 public static void Main() {
 Int32 x; // Инициализация x
 GetVal(out x); // Инициализация x не обязательна
 Console.WriteLine(x); // Выводится 10
 }
 private static void GetVal(out Int32 v) {
 v = 10; // Этот метод должен инициализировать переменную V
 }
}

Использование ключевого слова out со значимыми типами повышает эффективность кода, так как предотвращает копирование экземплярных полей значимого типа при вызовах методов.
А теперь рассмотрим аналогичный пример с ключевым словом ref:

public sealed class Program {
 public static void Main() {
 Int32 x = 5; // Инициализация x
 AddVal(ref x); // x требуется инициализировать
 Console.WriteLine(x); // Выводится 15
 }
 private static void AddVal(ref Int32 v) {
 v += 10; // Этот метод может использовать инициализированный параметр v
 }
}


Со значимыми типами ключевые слова out и ref дают тот же результат, что и передача ссылочного типа по значению. Они позволяют методу управлять единственным экземпляром 
значимого типа. Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью. В случае ссылочных типов вызывающий код выделяет 
память для указателя на передаваемый объект, а вызванный код управляет этим указателем. В силу этих особенностей использование ключевых слов out и ref со ссылочными типами полезно, 
лишь когда метод собирается «вернуть» ссылку на известный ему объект. 


						Передача переменного количества аргументов
	Метод, принимающий переменное число аргументов, объявляют так:
	
static Int32 Add(params Int32[] values) {
 // ПРИМЕЧАНИЕ: при необходимости этот массив можно передать другим методам
 Int32 sum = 0;
 if (values != null) {
 for (Int32 x = 0; x < values.Length; x++)
 sum += values[x];
 }
 return sum;
}

Незнакомым в этом методе является только ключевое слово params, примененное к последнему параметру в сигнатуре метода. Если не обращать на него внимания, 
станет ясно, что метод принимает массив значений типа Int32, складывает все элементы этого массива и возвращает полученную сумму.
	Такая форма вызова возможна благодаря ключевому слову params. Именно оно заставляет компилятор рассматривать параметр как экземпляр настраиваемого 
атрибута System.ParamArrayAttribute
	Ключевым словом params может быть помечен только последний параметр метода. Он должен указывать на одномерный массив произвольного типа. В последнем параметре метода 
допустимо передавать значение null или ссылку на массив, состоящий из нуля элементов.

Все показанные до сих пор примеры демонстрировали методы, принимающие произвольное количество параметров типа Int32. А как написать метод, принимающий произвольное 
количество параметров любого типа? Ответ прост: достаточно отредактировать прототип метода, заставив его вместо Int32[] принимать Object[]. 
Следующий метод выводит значения Type всех переданных ему объектов:

public sealed class Program {
 public static void Main() {
 DisplayTypes(new Object(), new Random(), "Jeff", 5);
 }
 private static void DisplayTypes(params Object[] objects) {
 if (objects != null) {
 foreach (Object o in objects)
 Console.WriteLine(o.GetType());
 }
 }
}
Внимание
Вызов метода, принимающего переменное число аргументов, снижает производительность, если, конечно, не передавать в явном виде значение null. В любом случае
всем объектам массива нужно выделить место в куче и инициализировать элементы массива, а по завершении работы занятая массивом память должна быть очищена
сборщиком мусора. Чтобы уменьшить негативное влияние этих операций на производительность, можно определить несколько перегруженных методов, в которых
не используется ключевое слово params.

							Типы параметров и возвращаемых значений
							
	Объявляя тип параметров метода, нужно по возможности указывать «минимальные» типы, предпочитая интерфейсы базовым классам. Например, при написании метода, 
работающего с набором элементов, лучше всего объявить параметр метода, используя интерфейс IEnumerable<T> вместо сильного типа данных, например List<T>, 
или еще более сильного интерфейсного типа ICollection<T> или IList<T>:
// Рекомендуется в этом методе использовать параметр слабого типа
public void ManipulateItems<T>(IEnumerable<T> collection) { ... }

Причина, конечно же, в том, что первый метод можно вызывать, передав в него массив, объект List<T>, объект String и т. п., то есть любой объект, тип которого 
реализует интерфейс IEnumerable<T>. Второй метод принимает только объекты List<T>, с массивами или объектами String он работать уже не может. Ясно, что 
первый метод предпочтительнее, так как он гибче и может использоваться в более разнообразных ситуациях.
Естественно, при создании метода, получающего список (а не просто любой перечислимый объект), нужно объявлять тип параметра как IList<T>, в то время 
как типа List<T> лучше избегать.
	В то же время, объявляя тип возвращаемого методом объекта, желательно выбирать самый сильный из доступных вариантов.
коду передавать массивы и другие объекты, тип которых реализует IList<T>.
Однако для метода, возвращающего объект List<String>, вполне возможно изменение реализации, после которого он начнет возвращать тип String[]. 
В подобных случаях следует выбирать более слабый тип возвращаемого объекта. 
Например:

// Гибкий вариант: в этом методе используется мягкий тип возвращаемого объекта
public IList<String> GetStringCollection() { ... }
// Негибкий вариант: в этом методе используется сильный тип возвращаемого объекта
public List<String> GetStringCollection() { ... }

Хотя в коде метода GetStringCollection используется и возвращается объект List<String>, в прототипе метода лучше указать в качестве возвращаемого 
объекта IList<String>. Даже если в будущем указанная в коде метода коллекция изменит свой тип на String[], вызывающий код не потребуется ни редактировать, 
ни даже перекомпилировать. Обратите внимание, что в этом примере я выбрал самый «сильный» из самых «слабых» типов. К примеру, я не воспользовался типом 
IEnumerable<String> или ICollection<String>.

						Константность

						Глава 10. Свойства
												
	Свойства позволяют обратиться к методу в исходном тексте программы с использованием упрощенного синтаксиса. CLR поддерживает два вида свойств: без параметров, их называют	
просто — свойства, и с параметрами — индексаторами;
				
						Свойства без параметров
	Одним из краеугольных камней объектно-ориентированного программирования и разработки является инкапсуляция данных. Инкапсуляция данных означает, что 
поля типа ни в коем случае не следует открывать для общего доступа, так как в этом случае слишком просто написать код, способный испортить сведения о состоянии 
объекта путем ненадлежащего использования полей. 			
	Есть и другие причины для инкапсуляции доступа к полям данных типа. Допустим, вам нужен доступ к полю, чтобы что-то сделать, разместить в кэше некоторое значение или 
создать какой-то внутренний объект, создание которого было отложено, причем обращение к полю не должно нарушать безопасность потоков. Или поле является логическим и его 
значение представлено не байтами в памяти, а вычисляется по некоторому алгоритму.
Каждая из этих причин заставляет при разработке типов, во-первых, помечать все поля как закрытые (private), во-вторых, давать пользователю вашего типа 
возможность получения и задания сведений о состоянии через специальные методы, предназначенные исключительно для этого. 
Методы, выполняющие функции оболочки для доступа к полю, обычно называют методами доступа (accessor). 
Методы доступа могут выполнять дополнительные проверки, гарантируя, что сведения о состоянии объекта никогда не будут искажены.		

	Можно считать свойства «умными» полями, то есть полями с дополнительной логикой. 
	CLR поддерживает статические, экземплярные, абстрактные и виртуальные свойства. Кроме того, свойства могут помечаться модификатором доступа и определяться в интерфейсах.
У каждого свойства есть имя и тип (но не void). Нельзя перегружать свойства (то есть определять несколько свойств с одинаковыми именами, но разным типом). 
	Определяя свойство, обычно описывают пару методов: get и set. Однако опустив метод set, можно определить свойство, доступное только для чтения, а опуская 
только метод get, мы получим свойство, доступное только для записи.

	Свойства могут быть доступны только для чтения или только для записи, в то время как поля всегда доступны и для чтения, и для записи. Определяя свойство, 
лучше всего создавать для него оба метода доступа (get и set).
	Свойство, являясь по сути методом, может выдавать исключения, а при обращениям к полям исключений не бывает.
	Свойства нельзя передавать в метод в качестве параметров с ключевым словом out или ref
	Свойство-метод может выполняться довольно долго, в то время как обращения к полям выполняются моментально. Часто свойства применяют для синхронизации потоков, но это 
может привести к приостановке потока на неопределенное время, поэтому свойства не следует использовать для этих целей — в такой ситуации лучше задействовать метод. 
Кроме того, если предусмотрен удаленный доступ к классу (например, если он наследует от System.MarshalByRefObject), вызов свойства-метода выполняется очень медленно, 
поэтому предпочтение следует отдать методу. Я считаю, что в классах, производных от MarshalByRefObject, никогда не следует использовать свойства.
	При нескольких вызовах подряд свойство-метод может возвращать разные значения, а поле возвращает одно и то же значение. В классе System.DateTime есть неизменяемое свойство Now, 
которое возвращает текущие дату и время. При каждом последующем вызове свойство возвращает новое значение. Это ошибка, и в компании Microsoft охотно исправили бы этот класс, 
превратив Now в метод. Другой пример подобной ошибки — свойство Environment.TickCount.
	Свойство-метод может порождать видимые побочные эффекты, невозможные при доступе к полю. Иначе говоря, порядок определения значений различных свойств типа никак не должен 
влиять на поведение типа, однако в действительности часто бывает не так.
	Свойству-методу может требоваться дополнительная память или ссылка на объект, не являющийся частью состояния объекта, поэтому изменение возвращаемого объекта никак не 
сказывается на исходном объекте; при запросе поля всегда возвращается ссылка на объект, который гарантированно относится к состоянию исходного объекта. Свойство, возвращающее 
копию, — источник путаницы для разработчиков, причем об этом часто забывают упомянуть в документации

					Инициализаторы объектов и коллекций			
Создание объекта с заданием некоторых открытых свойств (или полей) — чрезвычайно распространенная операция. Для ее упрощения в C# предусмотрен специальный синтаксис 
инициализации объекта, например:
	Employee e = new Employee() { Name = "Jeff", Age = 45 };			
	Реальная выгода от синтаксиса инициализатора объекта состоит в том, что он позволяет программировать в контексте выражения, строя функции, которые 
улучшают читабельность кода. Например, можно написать:
String s = new Employee() { Name = "Jeff", Age = 45 }.ToString().ToUpper();

При инициализации коллекции методу Add можно передать несколько аргументов, для чего используется синтаксис с фигурными скобками:
var table = new Dictionary<String, Int32> {
 { "Jeffrey", 1 }, { "Kristin", 2 }, { "Aidan", 3 }, { "Grant", 4 }
};

					Анонимные типы
	Механизм анонимных типов в С# позволяет автоматически объявить кортежный тип при помощи простого синтаксиса. Кортежный тип (tuple type)1 — это тип, 
который содержит коллекцию свойств, каким-то образом связанных друг с другом. В первой строке следующего программного кода я определяю класс с двумя 
свойствами (Name типа String и Year типа Int32), создаю экземпляр этого типа и назначаю свойству Name значение Jeff, а свойству Year — значение 1964.

// Определение типа, создание сущности и инициализация свойств
var o1 = new { Name = "Jeff", Year = 1964 };

Здесь создается анонимный тип, потому что не был определен тип имени после слова new, таким образом, компилятор автоматически создает имя типа, но не сообщает какое 
оно (поэтому тип и назван анонимным). Использование синтаксиса инициализации объекта обсуждалось в предыдущем разделе. Итак, я, как разработчик, не имею понятия об имени 
типа на этапе компиляции и не знаю, с каким типом была объявлена переменная o1. Однако проблемы здесь нет — я могу использовать 
механизм неявной типизации локальной переменной, о котором говорится в главе 9, чтобы компилятор определил тип по выражению в правой части оператора присваивания (=)

Компилятор поддерживает два дополнительных варианта синтаксиса объявления свойства внутри анонимного типа, где на основании переменных определяются 
имена и типы свойств:

	String Name = "Grant";
	DateTime dt = DateTime.Now;
// Анонимный тип с двумя свойствами
// 1. Строковому свойству Name назначено значение Grant
// 2. Свойству Year типа Int32 Year назначен год из dt
var o2 = new { Name, dt.Year };

	В данном примере компилятор определяет, что первое свойство должно называться Name. Так как Name — это имя локальной переменной, то компилятор устанавливает значение типа 
свойства аналогичного типу локальной переменной, то есть String. Для второго свойства компилятор использует имя поля/свойства: 
Year. Year — свойство класса DateTime с типом Int32, а следовательно, свойство Year в анонимном типе будет относиться к типу Int32. Когда компилятор создает 
экземпляр анонимного типа, он назначает экземпляру Name свойство с тем же значением, что и у локальной переменной Name, так что свойство Name будет связано 
со строкой Grant. Компилятор назначит свойству экземпляра Year то же значение, что и возвращаемое значение из dt свойства Year.	

					Тип System.Tuple
В пространстве имен System определено несколько обобщенных кортежных типов 
(все они наследуются от класса Object), которые отличаются количеством обобщенных параметров. Приведу наиболее простую и наиболее сложную формы записи

					Свойства с параметрами
	Помимо таких «полеобразных» свойств, языки программирования поддерживают то, что я называю свойствами с параметрами (parameterful properties). У таких 
свойств методы доступа get получают один или несколько параметров. 	
	В C# синтаксис свойств с параметрами (индексаторов) напоминает синтаксис массивов. Иначе говоря, индексатор можно представить как средство, позволяющее разработчику 
на C# перегружать оператор [].
	В типе BitArray индексатор принимает один параметр bitPos типа Int32. У каждого индексатора должен быть хотя бы один параметр, но параметров может 
быть и больше. Тип параметров (как и тип возвращаемого значения) может быть любым. В отличие от свойств без параметров, тип может поддерживать множество перегруженных 
индексаторов при условии, что их сигнатуры различны.
Подобно методу доступа set свойства без параметров, метод доступа set индексатора содержит скрытый параметр (в C# его называют value), который указывает 
новое значение «индексируемого элемента»				
	CLR не различает свойства без параметров и с параметрами. Для среды любое свойство — это всего лишь пара методов, определенных внутри типа. Использование для индексатора 
в C# конструкции this[...] — всего лишь решение, принятое создателями языка, означающее, что в C# индексаторы могут определяться только для экземпляров объектов. 
В C# нет синтаксиса, позволяющего разработчику определять статистическое свойство-индексатор напрямую, хотя на самом деле CLR поддерживает статические свойства с параметрами.				
	В C# в одном типе можно определять несколько индексаторов при условии, что они получают разные наборы параметров				
	Как видите, C# рассматривает индексаторы как механизм перегрузки оператора [], и этот оператор не позволяет различать свойства с одинаковыми наборами 
параметров и разными именами методов доступа.				
					
					Глава 11. События		
	Тип, в котором определено событие (или экземпляры этого типа), может уведомлять другие объекты о некоторых особых ситуациях, которые могут случиться. 
Например, если в классе Button (кнопка) определить событие Click (щелчок), то в приложение можно использовать объекты, которые 
будут получать уведомление о щелчке объекта Button, а получив такое уведомление — исполнять некоторые действия. 
	События — это члены типа, обеспечивающие такого рода взаимодействие. А именно определения события в типе означает, что тип поддерживает следующие возможности:
	Регистрация своей заинтересованности в событии;
	Отмена регистрации своей заинтересованности в событии;
	Оповещение зарегистрированных методов о произошедшем событии.				
	
	Модель событий CLR основана на делегатах (delegate). Делегаты обеспечивают реализацию механизма обратного вызова, безопасную по отношению к типам. 
Методы обратного вызова (callback methods) позволяют объекту получать уведомления, на которые он подписался.
	В соответствии с соглашением, классы, содержащие информацию о событиях, передаваемую обработчику события, должны наследовать от типа System.EventArgs, а имя типа 
должно заканчиваться словом EventArgs. 				
	В C# событие объявляется с ключевым словом event. Каждому члену-событию назначаются область действия (практически всегда он открытый, поэтому доступен из любого кода), 
тип делегата, указывающий на прототип вызываемого метода (или методов), и имя (любой допустимый идентификатор). Вот как выглядит член событие нашего класса NewMail:

internal class MailManager {
 // Этап 2. Определение члена-события
 public event EventHandler<NewMailEventArgs> NewMail;
 ...
}

	Здесь NewMail — имя события, а типом события является EventHandler <NewMailEventArgs>. Это означает, что получатели уведомления о событии должны предоставлять метод 
обратного вызова, прототип которого соответствует типуделегату EventHandler<NewMailEventArgs>				
	В соответствии с соглашением в классе должен быть виртуальный защищенный метод, вызываемый из кода класса и его потомков при возникновении события. 
Этот метод принимает один параметр, объект MailMsgEventArgs, содержащий дополнительные сведения о событии. Реализация по умолчанию этого метода просто проверяет, есть ли объекты, 
зарегистрировавшиеся для получения уведомления о событии, и при положительном результате проверки сообщает зарегистрированным методам о возникновении события. 
Вот как выглядит этот метод в нашем классе MailManager:

internal class MailManager { 
 ...
 // Этап 3. Определение метода, ответственного за уведомление зарегистрированных объектов о событии. Если этот класс изолированный, нужно сделать метод закрытым или невиртуальным
 protected virtual void OnNewMail(NewMailEventArgs e) {
 // Сохранить ссылку на делегата во временной переменной для обеспечения безопасности потоков
 EventHandler<NewMailEventArgs> temp = Volatile.Read (ref NewMail);
 // Если есть объекты, зарегистрированные для получения уведомления о событии, уведомляем их
 if (temp != null) temp(this, e);
 }
 ... 
}
	Этап 4. Определение метода, преобразующего входную информацию в желаемое событие
У класса должен быть метод, принимающий некоторую входную информацию и в ответ генерирующий событие. В примере с типом MailManager метод SimulateNewMail вызывается для 
оповещения о получении нового сообщения в MailManager:
internal class MailManager {
 // Этап 4. Определение метода, преобразующего входную информацию в желаемое событие
 public void SimulateNewMail(String from, String to, String subject) {
 // Создать объект для хранения информации, которую нужно передать получателям уведомления
 NewMailEventArgs e = new NewMailEventArgs(from, to, subject);
 // Вызвать виртуальный метод, уведомляющий объект о событии Если ни один из производных типов не переопределяет этот метод,
 // объект уведомит всех зарегистрированных получателей уведомления
 OnNewMail(e); 
 } 
}

	Метод SimulateNewMail принимает информацию о сообщении и создает новый объект NewMailEventArgs, передавая его конструктору данные сообщения. Затем 
вызывается OnNewMail — собственный виртуальный метод объекта MailManager, чтобы формально уведомить объект MailManager о новом почтовом сообщении. 
Обычно это вызывает инициирование события, в результате уведомляются все зарегистрированные объекты. (Как уже отмечалось, тип, производный от MailManager, 
может переопределять это действие.)
	Метод SimulateNewMail принимает информацию о сообщении и создает новый объект NewMailEventArgs, передавая его конструктору данные сообщения. Затем 
вызывается OnNewMail — собственный виртуальный метод объекта MailManager, чтобы формально уведомить объект MailManager о новом почтовом сообщении. 
Обычно это вызывает инициирование события, в результате уведомляются все зарегистрированные объекты. (Как уже отмечалось, тип, производный от MailManager, 
может переопределять это действие.)
	Членысобытия также могут объявляться статическими и виртуальными; в этом случае сгенерированные компилятором методы add и remove также будут статическими 
или виртуальными соответственно

				Создание типа, отслеживающего событие (НАДО ПЕРЕЧИТЫВАТЬ)

					Глава 12. Обобщения
	Разработчикам хорошо известны достоинства объектно-ориентированного программирования. Одно из ключевых преимуществ — возможность многократного 
использования кода за счет создания производных классов, наследующих все возможности базового класса. В производном классе можно просто переопределить 
виртуальные методы или добавить новые методы, чтобы изменить унаследованные от базового класса характеристики для решения новых задач. Обобщения (generics) — 
еще один механизм, поддерживаемый средой CLR и языками программирования для другой разновидности многократного использования кода — а именно многократного использования алгоритмов.
	По сути, разработчик описывает алгоритм, например, сортировки, поиска, замены, сравнения или преобразования, но не указывает типы данных, с которыми тот 
работает, что позволяет применять алгоритм к объектам разных типов. Применяя готовый алгоритм, другой разработчик должен указать конкретные типы данных
	Большинство алгоритмов инкапсулировано в типе. CLR поддерживает создание как обобщенных ссылочных, так и обобщенных значимых типов, однако обобщенные перечислимые типы 
не поддерживаются. Кроме того, CLR позволяет создавать обобщенные интерфейсы и делегатов. Иногда полезный алгоритм инкапсулирован в одном методе, поэтому CLR поддерживает 
создание обобщенных методов, определенных в ссылочном типе, в значимом типе или в интерфейсе
	При определении обобщенного типа или метода переменные, указанные вместо типа (например, T), называются параметрами типа (type parameters). 
T — это имя переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий тип данных
	В случае обобщенного типа или метода указанные типы данных называют аргументами-типами (type arguments). Например, разработчик может использовать алгоритм List, указав 
тип DateTime в качестве аргумента-типа

	На примере этого кода видны главные преимущества обобщений для разработчиков:	
	Защита исходного кода. Разработчику, использующему обобщенный алгоритм, не нужен доступ к исходному тексту алгоритма.
	Безопасность типов. Когда обобщенный алгоритм применяется с конкретным типом, компилятор и CLR понимают это и следят за тем, чтобы в алгоритме 
использовались лишь объекты, совместимые с этим типом данных. Попытка использования несовместимого объекта приведет к ошибке на этапе компиляции 
или исключению во время выполнения. 
	Более простой и понятный код. Поскольку компилятор обеспечивает безопасность типов, в исходном тексте требуется меньше операция приведения типов, а такой код проще 
писать и сопровождать.
	Повышение производительности. До появления обобщений один из способов определения обобщенного алгоритма заключался в таком определении всех его членов, чтобы они «умели» 
работать с типом данных Object. Чтобы алгоритм работал с экземплярами значимого типа, перед вызовом членов алгоритма среда CLR должна была упаковать этот экземпляр. 
Как показано в главе 5, упаковка требует выделения памяти в управляемой куче, что приводит к более частым процедурам уборки мусора, а это, в свою очередь, снижает 
производительность приложения. Поскольку обобщенный алгоритм можно создать для работы с конкретным значимым типом, экземпляры значимого типа могут передаваться 
по значению и CLR не нужно выполнять упаковку. Операции приведения типа также не нужны (см. предыдущий пункт), поэтому CLR не нужно контролировать безопасность типов при 
их преобразовании, что также ускоряет работу кода.
	Результаты тестирования для ссылочного типа не столь впечатляющие: временные показатели и число операций уборки мусора здесь примерно одинаковы. 
Поэтому в данном случае у обобщенного алгоритма List реальных преимуществ нет. Тем не менее помните, что применение обобщенного алгоритма значительно 
упрощает код и контроль типов при компиляции. Таким образом, хотя выигрыша в производительности практически нет, обобщенный алгоритм обычно имеет и другие преимущества

				Обобщения в библиотеке FCL

	Microsoft рекомендует программистам отказаться от необобщенных классов коллекций в пользу их обобщенных аналогов по нескольким причинам. 
	Во-первых, необобщенные классы коллекций, в отличие от обобщенных, не обеспечивают безопасность типов, простоту и понятность кода и повышение производительности. 
	Во-вторых, объектная модель у обобщенных классов лучше, чем у необобщенных. Например, у них меньше виртуальных методов, что повышает производительность, а новые члены, 
добавленные в обобщенные коллекции, добавляют новую функциональность.
Классы коллекций реализуют множество интерфейсов, а объекты, добавляемые в коллекции, могут реализовывать интерфейсы, используемые классами коллекций для таких операций, 
как сортировка и поиск. В составе FCL поставляется множество определений обобщенных интерфейсов, поэтому при работе с интерфейсами также доступны преимущества обобщений. 
Большинство используемых интерфейсов содержится в пространстве имен System.Collections.Generic.
Новые обобщенные интерфейсы не заменяют необобщенные: во многих ситуациях приходится задействовать оба вида интерфейсов. Причина — необходимость сохранения обратной совместимости. 
Например, если бы класс List<T> реализовывал только интерфейс IList<T>, в коде нельзя было бы рассматривать объект List< DateTime> как IList.
Также отмечу, что класс System.Array, базовый для всех типов массивов, поддерживает множество статических обобщенных методов, в том числе AsReadOnly, BinarySearch, ConvertAll, 
Exists, Find, FindAll, FindIndex, FindLast, FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort и TrueForAll. 

					Обобщенные типы и наследование
				
					Обобщенные интерфейсы
	Без них любая попытка работы со значимым типом через необобщенный интерфейс (например, IComparable) всякий раз будет приводить к необходимости упаковки и потере 
безопасности типов в процессе компиляции, что сильно сузило бы область применения обобщенных типов. Вот почему CLR поддерживает обобщенные интерфейсы. Ссылочный и значимый типы 
реализуют обобщенный интерфейс путем задания аргументов-типов, или же любой тип реализует обобщенный интерфейс, не задавая аргументы-типы. 
				
					Обобщенные делегаты
	Поддержка обобщенных делегатов в CLR позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом безопасность типов. Более того, благодаря 
обобщенным делегатам экземпляры значимого типа могут передаваться методам обратного вызова без упаковки. Как уже отмечалось в главе 17, делегат — это просто определение 
класса с помощью четырех методов: конструктора и методов Invoke, BeginInvoke и EndInvoke. При определении типа делегата с параметрами типа компилятор задает методы класса 
делегата, а параметры типа применяются ко всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.
	
				Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах  (ПЕРЕЧИТАТЬ)
				
	Каждый из параметров-типов обобщенного делегата должен быть помечен как ковариантный или контравариантный. Это позволяет вам осуществлять приведение типа переменной 
обобщенного делегата к тому же типу делегата с другим параметром-типом. Параметры-типы могут быть:
	Инвариантными. Параметр-тип не может изменяться. 
	Контравариантными. Параметр-тип может быть преобразован от класса к классу, производному от него. В языке C# контравариантный тип обозначается ключевым словом in. 
Контравариантный параметр-тип может появляться только во входной позиции, например, в качестве аргументов метода.
	Ковариантными. Аргумент-тип может быть преобразован от класса к одному из его базовых классов. В языке С# ковариантный тип обозначается ключевым словом out. Ковариантный 
параметр обобщенного типа может появляться только в выходной позиции, например, в качестве возвращаемого значения метода.
								
					Обобщенные методы
	При определении обобщенного ссылочного и значимого типа или интерфейса все методы, определенные в этих типах, могут использовать их параметр-тип. 
Параметр-тип может использоваться для параметров метода, возвращаемого значения метода или типа заданной внутри него локальной переменной. Но CLR также позволяет методу иметь 
собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных
	Использование обобщенных типов с методами, получающими параметры out и ref, особенно интересно тем, что переменные, передаваемые в качестве аргумента out/ref, должны быть 
того же типа, что и параметр метода, чтобы избежать возможного нарушения безопасности типов. Эта особенность параметров out/ref обсуждается в главе 9. В сущности, именно 
поэтому методы Exchange и CompareExchange класса Interlocked поддерживают обобщенную перегрузку.

					Обобщения и другие члены
	В языке C# у свойств, индексаторов, событий, операторных методов, конструкторов и деструкторов не может быть параметров-типов. Однако их можно определить 
в обобщенном типе с тем, чтобы в их коде использовать параметры-типы этого типа.
				
					Верификация и ограничения
	Ограничение сужает перечень типов, которые можно передать в обобщенном аргументе, и расширяет возможности по работе с этими типами. Вот новый вариант 
метода Min, который задает ограничение (выделено полужирным шрифтом):

public static T Min<T>(T o1, T o2) where T : IComparable<T> {
 if (o1.CompareTo(o2) < 0) return o1;
 return o2;
}

	Маркер where в C# сообщает компилятору, что указанный в T тип должен реализовывать обобщенный интерфейс IComparable того же типа (T). Благодаря этому 
ограничению компилятор разрешает методу вызвать метод CompareTo, потому что последний определен в интерфейсе IComparable<T>.
	Ограничения можно применять к параметрам типа как обобщенных типов, так и обобщенных методов (как показано в методе Min). Среда CLR не поддерживает 
перегрузку по именам параметров типа или по именам ограничений. Перегрузка типов и методов выполняется только по арности. Покажу это на примере:

	// Можно определить следующие типы:
	internal sealed class AType {}
	internal sealed class AType<T> {}
	internal sealed class AType<T1, T2> {}

	При переопределении виртуального обобщенного метода в переопределяющем методе должно быть задано то же число параметров-типов, а они, в свою очередь, 
наследуют ограничения, заданные для них методом базового класса. Собственно, переопределяемый метод вообще не вправе задавать ограничения для своих параметров-типов, но 
может переименовывать параметры-типы. Аналогично, при реализации интерфейсного метода в нем должно задаваться то же число параметров-типов, что и в интерфейсном методе, 
причем эти параметры-типы наследуют ограничения, заданные для них методом интерфейса
	Теперь поговорим о различных типах ограничений, которые компилятор и CLR позволяют применять к параметрам типа. К параметру-типу могут применяться следующие ограничения: 
	основное (primary), дополнительное (secondary) и/или ограничение конструктора (constructor constraint). 

					Основные ограничения
	В параметре-типе можно задать не более одного основного ограничения. Основным ограничением может быть ссылочный тип, указывающий на незапечатанный класс. 
Нельзя использовать для этой цели следующие ссылочные типы: System.Object, System.Array, System.Delegate, System.MulticastDelegate, System.ValueType, System.Enum и System.Void.
	При задании ограничения ссылочного типа вы гарантируете компилятору, что заданный аргумент-тип будет относиться либо к типу, указанному в ограничении, либо к производному от 
него типу. Для примера возьмем следующий обобщенный класс:

internal sealed class PrimaryConstraintOfStream<T> where T : Stream {
 public void M(T stream) {
 stream.Close();// OK
 }
}

	В этом определении класса для параметра-типа T установлено основное ограничение Stream, сообщающее компилятору, что код, использующий PrimaryConstraintOfStream, должен 
задавать аргумент типа Stream или производного от него типа (например, FileStream). Если параметр-тип не задает основное ограничение, автоматически задается тип System.Object. 
Однако если в исходном тексте явно указать System.Object, компилятор C# выдаст ошибку 
	Есть два особых основных ограничения: class и struct. Ограничение classгарантирует компилятору, что указанный аргумент-тип будет иметь ссылочный тип. Этому ограничению 
удовлетворяют все типы-классы, типы-интерфейсы, типыделегаты и типы-массивы, как в следующем обобщенном классе:

internal sealed class PrimaryConstraintOfClass<T> where T : class {
 public void M() {
 T temp = null;// Допустимо, потому что тип T должен быть ссылочным
 }
}

	Ограничение struct гарантирует компилятору, что указанный аргумент типа будет иметь значимый тип. Этому ограничению удовлетворяют все значимые типы, а также перечисления. 
Однако компилятор и CLR рассматривают любой значимый тип System.Nullable<T> как особый, и значимые типы с поддержкой null не подходят под это ограничение. Это объясняется тем, 
что для параметра типа Nullable<T> действует ограничение struct, а среда CLR запрещает такие рекурсивные типы, как Nullable<Nullable<T>>. 
Пример класса, в котором параметр-тип ограничивается ключевым словом struct:

internal sealed class PrimaryConstraintOfStruct<T> where T : struct {
 public static T Factory() {
 // Допускается, потому что у каждого значимого типа неявно есть открытый конструктор без параметров
 return new T();
 }
}

В этом примере применение к T оператора new правомерно, потому что известно, что T имеет значимый тип, а у всех значимых типов неявно есть открытый конструктор без параметров. 
Если бы тип T был неограниченным, ограниченным ссылочным типом или ограниченным классом, этот код не скомпилировался бы, потому что у некоторых ссылочных типов нет открытых 
конструкторов без параметров

					Дополнительные ограничения ( НЕ ПОНЯЛ)
Для параметра-типа могут быть заданы нуль или более дополнительных ограничений. При задании ограничения интерфейсного типа вы гарантируете компилятору, что указанный аргумент-тип 
будет определять тип, реализующий этот интерфейс. А так как можно задать несколько интерфейсных ограничений, в аргументе типа должен указываться тип, реализующий все 
интерфейсные ограничения (и все основные ограничения, если они заданы). 
Другой тип дополнительных ограничений называют ограничением параметратипа (type parameter constraint). Оно используется гораздо реже, чем интерфейсные ограничения интерфейса, 
и позволяет обобщенному типу или методу указать, что аргументы-типы должны быть связаны определенными отношениями. К параметрутипу может быть применено нуль и более ограничений

					Ограничения конструктора
	Для параметра-типа можно задать не более одного ограничения конструктора. Ограничение конструктора гарантирует компилятору, что указанный аргумент-тип 
будет иметь неабстрактный тип, имеющий открытый конструктор без параметров. Учтите, что компилятор С# считает ошибкой одновременное задание ограничения конструктора и ограничения 
struct, потому что это избыточно. У всех значимых типов неявно присутствует открытый конструктор без параметров. В следующем классе для параметра-типа использовано ограничение 
конструктора:
internal sealed class ConstructorConstraint<T> where T : new() {
 public static T Factory() {
 // Допустимо, потому что у всех значимых типов неявно есть открытый конструктор без параметров, и потому что это ограничение требует, чтобы у всех указанных ссылочных типов
 // также был открытый конструктор без параметров
 return new T();
 }
}

	В этом примере применение оператора new к T допустимо, потому что известно, что T — это тип с открытым конструктором без параметров. Разумеется, это справедливо для всех 
значимых типов, а ограничение конструктора требует, чтобы это условие выполнялось и для всех ссылочных типов, заданных в аргументе-типе.
Иногда разработчики предпочитают объявлять параметр типа через ограничение конструктора, при котором сам конструктор принимает различные параметры. На сегодняшний день CLR 
(и, как следствие, компилятор C#) поддерживает только конструкторы без параметров. По мнению специалистов Microsoft, в большинстве 
случаев этого вполне достаточно, и я с ними полностью согласен

						Глава 13. Интерфейсы
	Любой производный от Object класс наследует:
	Сигнатуры методов. Это позволяет коду считать, что он оперирует экземпляром класса Object, тогда как на самом деле он работает с экземпляром какого-либо 
другого класса.
	Реализацию этих методов. Разработчик может определить класс, производный от Object, не реализуя методы класса Object вручную.
В CLR у класса может быть один и только один прямой «родитель» (который прямо или опосредованно наследует от класса Object). Базовый класс предоставляет набор сигнатур и 
реализации этих методов. При этом новый класс может стать базовым для другого класса, который будет определен другим разработчиком, и при этом новый производный класс 
унаследует все сигнатуры методов и их реализации			
	CLR также позволяет определить интерфейс, который, в сущности, представляет собой средство назначения имени набору сигнатур методов. Интерфейс не содержит реализаций методов. 
Класс наследует интерфейс через указание имени последнего, причем этот класс должен явно содержать реализации интерфейсных методов — иначе CLR посчитает определение 
типа недействительным. 			
	Компилятор C# и CLR позволяют классу наследовать от нескольких интерфейсов, и, конечно же, класс при этом должен реализовать все унаследованные методы интерфейсов.
Одна из замечательных особенностей наследования классов — возможность подстановки экземпляров производного типа в любые контексты, в которых выступают 
экземпляры базового типа. Аналогичным образом наследование от интерфейсов позволяет подставлять экземпляры типа, реализующего интерфейс, во все контексты, 
где требуются экземпляры указанного интерфейсного типа.			
				
						Определение интерфейсов
	Как упоминалось ранее, интерфейс представляет собой именованный набор сигнатур методов. Обратите внимание, что в интерфейсах можно также определять события, 
свойства — без параметров или с индексаторами, поскольку все это просто упрощенные средства синтаксиса, которые в конечном итоге все равно соответствуют методам.			
	В C# для определения интерфейса, назначения ему имени и набора сигнатур экземплярных методов используется ключевое слово interface.			
	С точки зрения CLR, определение интерфейса — почти то же, что и определение типа. То есть CLR определяет внутреннюю структуру данных для объекта интерфейсного типа, а 
для обращения к различным членам интерфейса может использовать отражение. Как и типы, интерфейс может определяться на уровне файлов или быть вложенным в другой тип. 
При определении интерфейсного типа можно указать требуемую область видимости и доступа (public, protected, internal и т. п.).			
	В соответствии с соглашением имена интерфейсных типов начинаются с прописной буквы I, что облегчает их поиск в исходном коде. CLR поддерживает обобщенные интерфейсы 
и интерфейсные методы.			
	Определение интерфейса может «наследовать» другие интерфейсы. Однако слово «наследовать» не совсем точное, поскольку в интерфейсах наследование работает 
иначе, чем в классах. Я предпочитаю рассматривать наследование интерфейсов как включение контрактов других интерфейсов. Например, определение интерфейса TCollection<T> 
включает контракт интерфейсов TEnumerable<T> и IEnumerable. Это означает следующее:
	любой класс, наследующий интерфейс ICollection<T>, должен реализовать все методы, определенные в интерфейсах ICollection<T>, IEnumerable<T> и IEnumerable;
	любой код, ожидающий объект, тип которого реализует интерфейс ICollection<T>, может быть уверен в том, что тип объекта также реализует методы интерфейсов 
IEnumerable<T> и IEnumerable.	
		
					Наследование интерфейсов		
	Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не 
определен в коде как виртуальный, компилятор сделает его таковым и, вдобавок, запечатанным. Это не позволяет производному классу переопределять интерфейсные методы. 
Если явно задать метод как виртуальный, компилятор сделает его таковым и оставит незапечатанным, что предоставит производному классу возможность переопределять интерфейсные методы.
Производный класс не в состоянии переопределять интерфейсные методы, объявленные запечатанными, но может повторно унаследовать тот же интерфейс и предоставить собственную 
реализацию его методов. При вызове интерфейсного метода объекта вызывается реализация, связанная с типом самого объекта.			
	Подробнее о вызовах интерфейсных методов
Тип System.String из библиотеки FCL наследует сигнатуры и реализации методов System.Object. Кроме того, тип String реализует несколько интерфейсов: 
IComparable, ICloneable, IConvertible, IEnumerable, IComparable<String>, IEnumerable<Char> и IEquatable<String>. Это значит, что типу String не требуется реализовывать методы, 
имеющиеся в его базовом типе Object. Однако тип String должен реализовывать методы, объявленные во всех интерфейсах. CLR допускает определение полей, параметров или локальных 
переменных, имеющих интерфейсный тип. Используя переменную интерфейсного типа, можно вызывать методы, определенные этим интерфейсом. К тому же CLR позволяет вызывать методы, 
определенные в типе Object, поскольку все классы наследуют его методы, как продемонстрировано в следующем коде:			
				
					Явные и неявные реализации интерфейсных методов (что происходит за кулисами)
	Когда тип загружается в CLR, для него создается и инициализируется таблица методов. Она содержит по одной записи для каждого нового, представляемого только этим типом метода, 
а также записи для всех виртуальных методов, унаследованных типом. Унаследованные виртуальные методы включают методы, определенные в базовых типах иерархии наследования, 
а также все методы, определенные интерфейсными типами. Допустим, имеется простое определение типа:
	internal sealed class SimpleType : IDisposable {
 public void Dispose() { Console.WriteLine("Dispose"); }
}

Тогда таблица методов типа содержит записи, в которых представлены:
	все экземплярные методы, определенные в типе Object и неявно унаследованные от этого базового класса;
	все интерфейсные методы, определенные в явно унаследованном интерфейсе IDisposable (в нашем примере в интерфейсе IDisposable определен только один метод — Dispose);
	новый метод, Dispose, появившийся в типе SimpleType.

	Чтобы упростить жизнь программиста, компилятор C# считает, что появившийся в типе SimpleType метод Dispose является реализацией метода Dispose из интерфейса IDisposable. 
Компилятор C# вправе сделать такое предположение, потому что метод открытый, а сигнатуры интерфейсного метода и нового метода совпадают. Значит, методы принимают и возвращают 
одинаковые типы. Кстати, если бы новый метод Dispose был помечен как виртуальный, компилятор C# все равно сопоставил бы этот метод с одноименным интерфейсным методом.
Сопоставляя новый метод с интерфейсным методом, компилятор C# генерирует метаданные, указывающие на то, что обе записи в таблице методов типа SimpleType должны ссылаться на одну 
реализацию. 	Теперь мы перепишем SimpleType, чтобы можно было увидеть разницу:

internal sealed class SimpleType : IDisposable {
 public void Dispose() { Console.WriteLine("public Dispose"); }
 void IDisposable.Dispose() { Console.WriteLine("IDisposable Dispose"); }
}

	Не вызывая метод Main, мы можем просто перекомпилировать и запустить заново программу, и на выходе получим следующее:
	public Dispose
	IDisposable Dispose

	Если в C# перед именем метода указано имя интерфейса, в котором определен этот метод (в нашем примере — IDisposable.Dispose), то вы создаете явную реализацию интерфейсного 
метода (Explicit Interface Method Implementation, EIMI). 
Заметьте: при явной реализации интерфейсного метода в C# нельзя указывать уровень доступа (открытый или закрытый). Однако когда компилятор создает метаданные для метода, 
он назначает ему закрытый уровень доступа (private), что запрещает любому коду использовать экземпляр класса простым вызовом интерфейсного метода. Единственный способ вызвать 
интерфейсный метод — обратиться через переменную этого интерфейсного типа.
	Обратите внимание на то, что EIMI-метод не может быть виртуальным, а значит, его нельзя переопределить. Это происходит потому, что EIMI-метод в действительности не является 
частью объектной модели типа; это всего лишь средство связывания интерфейса (набора вариантов поведения, или методов) с типом. Если такой подход кажется вам немного неуклюжим, 
значит, вы все поняли правильно. 
			
				Обобщенные интерфейсы
	Во-первых, обобщенные интерфейсы обеспечивают безопасность типов на стадии компиляции. Некоторые интерфейсы (такие, как необобщенный IComparable) определяют методы, 
которые принимают или возвращают параметры типа Object. При вызове в коде методов таких интерфейсов можно передать ссылку на экземпляр любого типа, однако обычно это нежелательно.
Ясно, что желательно обеспечить более строгий контроль типов в интерфейсном методе, поэтому в FCL включен обобщенный интерфейс IComparable<T>. 
	Второе преимущество обобщенных интерфейсов заключается в том, что при работе со значимыми типами требуется меньше операций упаковки. Заметьте: 
	в SomeMethod1 необобщенный метод CompareTo интерфейса IComparable ожидает переменную типа Object; передача переменной y (значимый тип Int32) приводит к упаковке значения y. 
	В SomeMethod2 метод CompareTo обобщенного интерфейса IComparable<T> ожидает Int32; передача y выполняется по значению, поэтому упаковка не требуется.
	Третье преимущество обобщенных интерфейсов заключается в том, что класс может реализовать один интерфейс многократно, просто используя параметры различного типа.
	Параметры интерфейса обобщенного типа могут быть также помечены как контравариантые или ковариантные, что позволяет более гибко использовать интерфейсы

				Обобщения и ограничения интерфейса
	Первое преимущество состоит в том, что параметр-тип можно ограничить несколькими интерфейсами. В этом случае тип передаваемого параметра должен реализовывать все ограничения
	Замечательно! При определении параметров метода каждый тип параметра указывает, что передаваемый аргумент должен иметь заданный тип или быть производным от него. Если типом 
параметра является интерфейс, аргумент может относиться к любому типу класса, реализующему заданный интерфейс. Использование нескольких ограничений интерфейса позволяет методу 
указывать, что передаваемый аргумент должен реализовывать несколько интерфейсов.
	На самом деле, ограничивая Т классом и двумя интерфейсами, мы говорим, что типом передаваемого аргумента должен быть указанный базовый класс (или производный от него), 
а также что он должен реализовывать оба интерфейса. Такая гибкость позволяет методу диктовать условия вызывающему коду, а при невыполнении установленных ограничений возникают 
ошибки компиляции.
	Второе преимущество ограничений интерфейса — избавление от упаковки при передаче экземпляров значимых типов. В предыдущем фрагменте кода методу M передавался аргумент x 
(экземпляр типа Int32, то есть значимого типа). При передаче x в M упаковка не выполнялась. Если код метода M вызовет t.CompareTo(...), то упаковка при вызове также не будет 
выполняться (упаковка может выполняться для аргументов, передаваемых CompareTo)	В то же время если M объявляется следующим образом, то для передачи x в M придется выполнять упаковку:

private static Int32 M(IComparable t) {
 ...
}

	Для ограничений интерфейсов компилятор C# генерирует определенные IL-инструкции, которые вызывают интерфейсный метод для значимого типа напрямую, без упаковки. Кроме 
использования ограничений интерфейса нет другого способа заставить компилятор C# генерировать такие IL-инструкции; следовательно, во всех других случаях вызов интерфейсного 
метода для значимого типа всегда приводит к упаковке.
			
				Реализация нескольких интерфейсов с одинаковыми сигнатурами и именами методов
	Иногда нужно определить тип, реализующий несколько интерфейсов с методами, у которых совпадают имена и сигнатуры. Допустим, два интерфейса определены следующим образом:
	
public interface IWindow {
 Object GetMenu();
}

public interface IRestaurant {
 Object GetMenu();
}

	Требуется определить тип, реализующий оба этих интерфейса. В этом случае нужно реализовать члены типа путем явной реализации методов так как этот тип должен реализовывать 
несколько различных методов GetMenu, нужно сообщить компилятору C#, какой из методов GetMenu реализацию для конкретного интерфейса.
	Код, в котором используется объект MarioPizzeria, должен выполнять приведение типа к определенному интерфейсу для вызова нужного метода:
	
	MarioPizzeria mp = new MarioPizzeria();
	// Эта строка вызывает открытый метод GetMenu класса MarioPizzeria
	mp.GetMenu();
	// Эти строки вызывают метод IWindow.GetMenu
	IWindow window = mp;
	window.GetMenu();
	// Эти строки вызывают метод IRestaurant.GetMenu
	IRestaurant restaurant = mp;
	restaurant.GetMenu();		
			
						Совершенствование безопасности типов за счет явной реализации интерфейсных методов
						
					Опасности явной реализации интерфейсных методов
Очень важно понимать некоторые особенности EIMI, из-за которых следует избегать явной реализации интерфейсных методов везде, где это возможно. К счастью, в некоторых случаях 
вместо EIMI можно обойтись обобщенными интерфейсами. Но все равно остаются ситуации, когда без EIMI не обойтись (например, при реализации двух интерфейсных методов с одинаковыми 
именами и сигнатурами). 
	С явной реализацией интерфейсных методов связаны некоторые серьезные проблемы:
	отсутствие документации, объясняющей, как именно тип реализует EIMI-метод, а также отсутствие IntelliSense-поддержки в Microsoft Visual Studio;
	при приведении к интерфейсному типу экземпляры значимого типа упаковываются;
	EIMI нельзя вызвать из производного типа
	Требование приведения типа далеко не очевидно, многие разработчики не могут самостоятельно до этого додуматься. Но на этом проблемы не заканчиваются — при 
приведении значимого типа Int32 к интерфейсному типу IConvertible значимый тип упаковывается, что приводит к лишним затратам памяти и снижению производительности. Это вторая 
серьезная проблема. 
	Третья и, наверное, самая серьезная проблема с EIMI состоит в том, что явная реализация интерфейсного метода не может вызываться из производного класса.			
				
					Дилемма разработчика: базовый класс или интерфейс?
	Связь потомка с предком. Любой тип может наследовать только одну реализацию. Если производный тип не может ограничиваться отношением типа «является частным случаем» с 
базовым типом, нужно применять интерфейс, а не базовый тип. Интерфейс подразумевает отношение «поддерживает функциональность». Например, тип может преобразовывать экземпляры самого 
себя в другой тип (IConvertible), может создать набор экземпляров самого себя (ISerializable) и т. д. Заметьте, что значимые типы должны наследовать от типа System.ValueType и 
поэтому не могут наследовать от произвольного базового класса. В этом случае нужно определять интерфейс.
	Простота использования. Разработчику проще определить новый тип, производный от базового, чем создать интерфейс. Базовый тип может предоставлять массу функций, и в производном 
типе потребуется внести лишь незначительные изменения, чтобы изменить его поведение. При создании интерфейса в новом типе придется реализовывать все члены.
	Четкая реализация. Как бы хорошо ни был документирован контракт, вряд ли будет реализован абсолютно корректно. По сути, проблемы COM связаны именно с этим — вот почему 
некоторые COM-объекты нормально работают только с Microsoft Word или Microsoft Internet Explorer. Базовый тип с хорошей реализацией основных функций — прекрасная отправная точка, 
вам останется изменить лишь отдельные части.
	Управление версиями. Когда вы добавляете метод к базовому типу, производный тип наследует стандартную реализацию этого метода без всяких затрат. 
Пользовательский исходный код даже не нужно перекомпилировать. Добавление нового члена к интерфейсу трребует изменения пользовательского исходного кода и его перекомпиляции

					Глава 14. Символы, строки и обработка текста
			
					Символы
			
					Строки
	Один из самых полезных типов, встречающихся в любом приложении — System.String, — представляет неизменяемый упорядоченный набор символов. Будучи 
прямым потомком Object, он является ссылочным типом, по этой причине строки всегда размещаются в куче и никогда — в стеке потока.		
	Во многих языках (включая C#) String относится к примитивным типам, то есть компилятор разрешает вставлять литеральные строки непосредственно в исходный код. 
Компилятор помещает эти литеральные строки в метаданные модуля, откуда они загружаются и используются во время выполнения.
В C# оператор new не может использоваться для создания объектов String из литеральных строк:
	// Конкатенация трех литеральных строк образует одну литеральную строку
String s = "Hi" + " " + "there.";

Поскольку все строки в этом коде литеральные, компилятор выполняет их конкатенацию на этапе компиляции, в результате в метаданных модуля оказывается лишь строка "Hi there.". 
Конкатенация нелитеральных строк с помощью оператора + происходит на этапе выполнения. Для конкатенации нескольких строк на этапе выполнения оператор + применять нежелательно, 
так как он создает в куче несколько строковых объектов. Вместо него рекомендуется использовать тип System.Text.StringBuilder.
	И наконец, в C# есть особый вариант объявления строки, в которой все символы между кавычками трактуются как часть строки. Эти специальные объявления — буквальные строки 
(verbatim strings) — обычно используют при задании пути к файлу или каталогу и при работе с регулярными выражениями. Следующий пример показывает, как объявить одну и ту же строку 
с использованием признака буквальных строк (@) и без него:

// Задание пути к приложению
String file = "C:\\Windows\\System32\\Notepad.exe";
// Задание пути к приложению с помощью буквальной строки
String file = @"C:\Windows\System32\Notepad.exe";

		Неизменяемые строки
Самое важное, что нужно помнить об объекте String — то, что он неизменяем; то есть созданную однажды строку нельзя сделать длиннее или короче, в ней нельзя изменить ни одного 
символа. Неизменность строк дает определенные преимущества. Для начала можно выполнять операции над строками, не изменяя их:
Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. Кроме того, в CLR несколько ссылок String могут указывать на один, а не на несколько 
разных строковых объектов, если строки идентичны. А значит, можно сократить количество строк в системе и уменьшить расход памяти — это именно то, что непосредственно относится к 
интернированию строк (string interning). По соображениям производительности тип String тесно интегрирован с CLR. В частности, CLR «знает» точное расположение полей в этом типе и 
обращается к ним напрямую. За повышение производительности и прямой доступ приходится платить небольшую цену: класс String является запечатанным.
		Сравнение строк
Сравнение — пожалуй, наиболее часто выполняемая со строками операция. Есть две причины, по которым приходится сравнивать строки. Мы сравниваем две строки 
для выяснения, равны ли они, и для сортировки (прежде всего, для представления их пользователю программы).
	При сортировке всегда нужно учитывать регистр символов. Дело в том, что две строки, отличающиеся лишь регистром символов, будут считаться одинаковыми и поэтому при каждой 
сортировке они могут упорядочиваться в произвольном порядке, что может приводить пользователя в замешательство.
		Интернирование строк
Если в приложении строки сравниваются часто методом порядкового сравнения с учетом регистра или если в приложении ожидается появление множества одинаковых строковых объектов, то 
для повышения производительности надо применить поддерживаемый CLR механизм интернирования строк (string interning). 
При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами являются строки, а значениями — ссылки на строковые объекты в управляемой 
куче. Вначале таблица, разумеется, пуста. В классе String есть два метода, предоставляющие доступ к внутренней хеш-таблице:
public static String Intern(String str);
public static String IsInterned(String str);

	Первый из них, Intern, ищет String во внутренней хеш-таблице. Если строка обнаруживается, возвращается ссылка на соответствующий объект String. Иначе создается копия строки, 
она добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию. Если приложение больше не удерживает ссылку на исходный объект String, уборщик мусора вправе 
освободить память, занимаемую этой строкой. Обратите внимание, что уборщик мусора не вправе освободить строки, на которые ссылается внутренняя хеш-таблица, поскольку в ней самой 
есть ссылки на эти String. Объекты String, на которые ссылается внутренняя хеш-таблица, нельзя освободить, пока не выгружен соответствующий домен приложения или не закрыт поток.
	Как и Intern, метод IsInterned получает параметр String и ищет его во внутренней хеш-таблице. Если поиск удачен, IsInterned возвращает ссылку на интернированную строку. 
В противном случае он возвращает null, а саму строку не вставляет в хеш-таблицу.
		Создание пулов строк
При обработке исходного кода компилятор должен каждую литеральную строку поместить в метаданные управляемого модуля. Если одна строка встречается в исходном коде много раз, 
размещение всех таких строк в метаданных приведет к увеличению размера результирующего файла.Чтобы не допустить роста объема кода, многие компиляторы (в том числе C#) 
хранят литеральную строку в метаданных модуля только в одном экземпляре. Все упоминания этой строки в исходном коде компилятор заменяет ссылками на ее экземпляр в метаданных. 
		Эффективное создание строк
У объекта StringBuilder предусмотрено поле со ссылкой на массив структур Char. Используя члены StringBuilder, можно эффективно манипулировать этим массивом, сокращая строку и 
изменяя символы строки. При увеличении строки, представляющей ранее выделенный массив символов, StringBuilder автоматически выделит память для нового, большего по размеру массива, 
скопирует символы и приступит к работе с новым массивом. А прежний массив попадет в сферу действия уборщика мусора. Сформировав свою строку с помощью объекта StringBuilder, 
«преобразуйте» массив символов StringBuilder в объект String, вызвав метод ToString типа StringBuilder. Этот метод просто возвращает ссылку на поле-строку, управляемую 
объектом StringBuilder. Поскольку массив символов здесь не копируется, метод выполняется очень быстро
		Форматирование нескольких объектов в одну строку
	String s = String.Format("On {0}, {1} is {2} years old.", new DateTime(2012, 4, 22, 14, 35, 5), "Aidan", 9); 
	
				Получение объекта посредством разбора строки
	Любой тип, способный разобрать строку, имеет открытый, статический метод Parse. Он получает String, а на выходе возвращает экземпляр данного типа; в какомто смысле Parse 
ведет себя как фабрика. В FCL метод Parse поддерживается всеми числовыми типами, а также типами DateTime, TimeSpan и некоторыми другими 
	public static Int32 Parse(String s, NumberStyles style, IFormatProvider provider);
	
Взглянув на прототип, вы сразу поймете суть работы этого метода. Параметр s типа String идентифицирует строковое представление числа, которое необходимо разобрать для получения 
объекта Int32. Параметр style типа System.Globalization.NumberStyles — это набор двоичных флагов для идентификации символов, которые метод Parse должен найти в строке. 
А параметр provider типа IFormatProvider идентифицирует объект, используя который метод Parse может получить информацию о региональных стандартах, о чем речь шла ранее.
Так, в следующем фрагменте при обращении к Parse генерируется исключение System.FormatException, так как в начале разбираемой строки находится пробел:

Int32 x = Int32.Parse(" 123", NumberStyles.None, null);
	Чтобы «пропустить» пробел, надо вызвать Parse с другим параметром style:
Int32 x = Int32.Parse(" 123", NumberStyles.AllowLeadingWhite, null);

				Глава 15. Перечислимые типы и битовые флаги
					Перечислимые типы
	Перечислимым (enumerated type) называют тип, в котором описан набор пар, состоящих из символьных имен и значений. 
	Однако перечислимый тип все-таки лучше жестко заданных в исходном коде числовых значений по крайней мере по двум причинам.
		Программу, где используются перечислимые типы, проще написать и понять, а у разработчиков возникает меньше проблем с ее сопровождением. Символьное имя перечислимого типа 
проходит через весь код, и занимаясь то одной, то другой частью программы, программист не обязан помнить значение каждого «зашитого» в коде значения (что White равен 0, а 0 
означает White). Если же числовое значение символа почему-либо изменилось, то нужно только перекомпилировать исходный код, не изменяя в нем ни буквы. Кроме того, работая 
с инструментами документирования и другими утилитами, такими как отладчик, программист видит осмысленные символьные имена, а не цифры.
	Перечислимые типы подвергаются строгой проверке типов. Например, компилятор сообщит об ошибке, если в качестве значения я попытаюсь передать методу 
тип Color.Orange (оранжевый цвет), когда метод ожидает перечислимый тип Fruit (фрукт).			

	Каждый перечислимый тип напрямую наследует от типа System.Enum, производного от System.ValueType, а тот, в свою очередь, — от System.Object. Из этого 
следует, что перечислимые типы относятся к значимым типам (см. главу 5) и могут выступать как в неупакованной, так и в упакованной формах. Однако в отличие 
от других значимых типов, у перечислимого типа не может быть методов, свойств и событий. Впрочем, как вы увидите в конце данной главы, наличие метода у перечислимого типа можно 
имитировать при помощи механизма методов расширения(extension methods).
	При компиляции перечислимого типа компилятор C# превращает каждый идентификатор в константное поле типа.
	В общем-то, перечислимый тип — это обычная структура, внутри которой описан набор константных полей и одно экземплярное поле. Константные поля попадают 
в метаданные сборки, откуда их можно извлечь с помощью механизма отражения. Это означает, что в период выполнения можно получить все идентификаторы и их 
значения, связанные перечислимым типом, а также преобразовать строковый идентификатор в эквивалентное ему числовое значение. Эти операции предоставлены 
базовым типом System.Enum, который предлагает статические и экземплярные методы, выполняющие специальные операции над экземплярами перечислимых 
типов, избавляя вас от необходимости использовать отражение			
	В основе любого перечисления лежит один из основных типов, например byte, sbyte, short, ushort, int (именно он используется в C# по умолчанию), uint, long и ulong. Все 
эти примитивные типы C# имеют аналоги в FCL. Однако компилятор C# пропустит только примитивный тип; задание базового класса FCL (например, Int32) приведет к сообщению об 
ошибке (ошибка CS1008: ожидается тип byte, sbyte, short, ushort, int, uint, long или ulong):
error CS1008: Type byte, sbyte, short, ushort, int, uint, long, or ulong expected			
	Компилятор C# считает перечислимые типы примитивными, поэтому для операций с их экземплярами применяются уже знакомые нам операторы	(==, !=, <, >, <=, >=, +, –, ^, &, 
|, ~, ++ и ––). Все они применяются к полю value__ экземпляра перечисления, а компилятор C# допускает приведение экземпляров одного перечислимого типа к другому. 
	Также поддерживается явное и неявное приведение к числовому типу.
Имеющийся экземпляр перечислимого типа можно связать со строковым представлением — для этого следует вызвать ToString, унаследованный от System.Enum:			
				
				
						Битовые флаги	
	Из описания типа FileAttributes видно, что, как правило, при создании набора комбинируемых друг с другом битовых флагов используют перечислимые типы. 
Однако несмотря на внешнюю схожесть, перечислимые типы семантически отличаются от битовых флагов. Если в первом случае мы имеем отдельные числовые значения, то во втором 
приходится иметь дело с набором флагов, одни из которых установлены, а другие нет.			
	Определяя перечислимый тип, предназначенный для идентификации битовых флагов, каждому идентификатору следует явно присвоить числовое значение. 
Обычно в соответствующем идентификатору значении установлен лишь один бит. Также часто приходится видеть идентификатор None, значение которого определено 
как 0. Еще можно определить идентификаторы, представляющие часто используемые комбинации (см. приведенный далее символ ReadWrite). Настоятельно рекомендуется применять к 
перечислимому типу специализированный атрибут типа System.FlagsAttribute:

[Flags] // Компилятор C# допускает значение "Flags" или "FlagsAttribute"
internal enum Actions {
 None = 0
 Read = 0x0001,
 Write = 0x0002,
 ReadWrite = Actions.Read | Actions.Write,
 Delete = 0x0004,
 Query = 0x0008,
 Sync = 0x0010
}			
				
					Глава 16. Массивы
	Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию. Общеязыковая исполняющая среда Microsoft .NET (CLR) 
поддерживает одномерные (single-dimension), многомерные (multidimension) и нерегулярные (jagged) массивы. Базовым для всех массивов является абстрактный класс 
System.Array, производный от System.Object. Значит, массивы всегда относятся к ссылочному типу и размещаются в управляемой куче, а переменная в приложении 
содержит не элементы массива, а ссылку на массив.			
	По возможности нужно ограничиваться одномерными массивами с нулевым начальным индексом, которые называют иногда SZ-массивами, или векторами. Векторы обеспечивают 
наилучшую производительность, поскольку для операций с ними используются команды промежуточного языка (Intermediate Language, IL), Впрочем, если у вас есть такое желание, 
можно применять и многомерные массивы. Вот как они создаются:

// Создание двухмерного массива типа Doubles
Double[,] myDoubles = new Double[10, 20];
// Создание трехмерного массива ссылок на строки
String[,,] myStrings = new String[5, 3, 10];

	CLR поддерживает также нерегулярные (jagged) массивы — то есть «массивы массивов». Производительность одномерных нерегулярных массивов с нулевым начальным индексом 
такая же, как у обычных векторов. Однако обращение к элементу нерегулярного массива означает обращение к двум или больше массивам одновременно. 
Вот пример массива многоугольников, где каждый многоугольник состоит из массива экземпляров типа Point:

// Создание одномерного массива из массивов типа Point
Point[][] myPolygons = new Point[3][]

				Инициализация элементов массива
В предыдущем разделе рассмотрена процедура создания элементов массива и присвоения им начальных значений. Синтаксис C# позволяет совместить эти операции:
String[] names = new String[] { "Aidan", "Grant" };

	Набор разделенных запятой символов в фигурных скобках называется инициализатором массива (array initializer). Сложность каждого символа может быть произвольной, 
а в случае многомерного массива инициализатор может оказаться вложенным. В показанном примере фигурируют всего два простых выражения типа String.

				Приведение типов в массивах
В CLR для массивов с элементами ссылочного типа допустимо приведение. В рамках решения этой задачи оба типа массивов должны иметь одинаковую размерность; кроме того, должно 
иметь место неявное или явное преобразование из типа элементов исходного массива в целевой тип. CLR не поддерживает преобразование массивов с элементами значимых типов в 
другие типы. Впрочем, данное ограничение можно обойти при помощи метода Array.Copy, который создает новый массив и заполняет его элементами.

			Реализация интерфейсов IEnumerable, ICollection и IList
			
			Внутренняя реализация массивов
В CLR поддерживаются массивы двух типов:
	Одномерные массивы с нулевым начальным индексом. Иногда их называют SZ-массивами (от английского single-dimensional, zero-based), или векторами.
	Одномерные и многомерные массивы с неизвестным начальным индексом.
	Доступ к элементам одномерного массива с нулевой нижней границей осуществляется немного быстрее, чем доступ к элементам многомерных массивов 
или массивов с ненулевой нижней границей. Есть несколько причин такому поведению. 
	Во-первых, специальные команды для работы с одномерными массивами с нулевой нижней границей (newarr, ldelem, ldelema, ldlen и stelem) позволяют 
JIT-компилятору генерировать оптимизированный код. При этом предполагается, что первый индекс равен нулю, то есть при доступе к элементам отсутствует 
необходимость вычислять смещение. Кроме того, в общем случае компилятор умеет выносить код проверки границ за пределы цикла.
	К сожалению, обращение к элементам многомерного массива или массива с ненулевой нижней границей происходит намного медленней. Ведь в этих случаях код 
проверки индекса не выносится за пределы цикла и проверка осуществляется на каждой итерации. Кроме того, компилятор добавляет код, вычитающий из текущего 
индекса нижнюю границу массива. Это также замедляет работу программы даже в случае многомерных массивов с нулевой нижней границей. Если вы серьезно оза
бочены проблемой производительности, имеет смысл использовать нерегулярные массивы (массивы массивов).

					Глава 17. Делегаты
	функциями обратного вызова. В Microsoft .NET Framework этот механизм поддерживается при помощи делегатов (delegates). Например, они обеспечивают 
безопасность типов при выполнении обратного вызова. Кроме того, они обеспечивают возможность последовательного вызова нескольких методов, а также вызова как статических, так 
и экземплярных методов.	

// Объявление делегата; экземпляр ссылается на метод с параметром типа Int32, возвращающий значение void
internal delegate void Feedback(Int32 value);
		
		
				Обратный вызов статических методов
	Теперь, когда мы разобрали принцип работы метода Counter, рассмотрим процедуру использования делегатов для вызова статических методов. Для примера возьмем 
метод StaticDelegateDemo из представленного в предыдущем разделе кода.
	private static void StaticDelegateDemo() {
		Console.WriteLine("----- Static Delegate Demo -----");
		Counter(1, 3, null);
		Counter(1, 3, new Feedback(Program.FeedbackToConsole)); // Префикс "Program." не обязателен
		Counter(1, 3, new Feedback(FeedbackToMsgBox)); 
		Console.WriteLine();
	}	
	
	private static void FeedbackToConsole(Int32 value) {
		Console.WriteLine("Item=" + value);
	}
	
	private static void FeedbackToMsgBox(Int32 value) {
		MessageBox.Show("Item=" + value);
	}

	
	Третий вызов метода Counter внутри метода StaticDelegateDemo отличается от второго тем, что делегат Feedback является оболочкой для статического метода 
Program.FeedbackToMsgBox. Именно метод FeedbackToMsgBox создает строку, указывающую на обрабатываемый элемент, которая затем выводится в окне в виде сообщения.
	В этом примере ничто не нарушает безопасность типов. К примеру, при создании делегата Feedback компилятор убеждается в том, что сигнатуры методов 
FeedbackToConsole и FeedbackToMsgBox типа Program совместимы с сигнатурой делегата. Это означает, что оба метода будут принимать один и тот же аргумент 
(типа Int32) и возвращать значение одного и того же типа (void).
		
	Как C#, так и CLR поддерживают ковариантность и контравариантность ссылочных типов при привязке метода к делегату. 
	Ковариантность (covariance) означает, что метод может возвратить тип, производный от типа, возвращаемого делегатом. 
	Контравариантность (contra-variance) означает, что метод может принимать параметр, который является базовым для типа параметра делегата. 
	Например:
		delegate Object MyCallback(FileStream s);
	Определив делегат таким образом, можно получить экземпляр этого делегата, связанный с методом, прототип которого выглядит примерно так:
		String SomeMethod(Stream s);
	Здесь тип значения, возвращаемого методом SomeMethod (тип String), является производным от типа, возвращаемого делегатом (Object); такая ковариантность разрешена. 
Тип параметра метода SomeMethod (тип Stream) является базовым классом для типа параметра делегата (FileStream); такая контравариантность тоже разрешена.
Обратите внимание, что ковариантность и контравариантность поддерживаются только для ссылочных типов, но не для значимых типов или значения void. К примеру, связать следующий 
метод с делегатом MyCallback невозможно:
	Int32 SomeOtherMethod(Stream s);
Несмотря на то что тип значения, возвращаемого методом SomeOtherMethod (то есть Int32), является производным от типа значения, возвращаемого методом MyCallback (то есть Object), 
такая форма ковариантности невозможна, потому что Int32 — это значимый тип. Значимые типы и void не могут использоваться ковариантно и контравариантно, потому что их структура 
памяти меняется, в то время как для ссылочных типов структурой памяти в любом случае остается указатель.				
					
				Обратный вызов экземплярных методов	

	 private static void InstanceDelegateDemo() {
		Console.WriteLine("----- Instance Delegate Demo -----");
		Program p = new Program();
		Counter(1, 3, new Feedback(p.FeedbackToFile));
		Console.WriteLine();
	}				
				
	Обратите внимание, что объект p типа Program создается внутри метода InstanceDelegateDemo. При этом у него отсутствуют экземплярные поля и свойства, поскольку он сконструирован 
с демонстрационными целями. Когда при вызове метода Counter создается делегат Feedback, его конструктору передается объект p.FeedbackToFile. В результате делегат превращается в о
болочку для ссылки на метод FeedbackToFile, который является не статическим, а экземплярным методом. Когда метод Counter обращается к методу обратного вызова, который задан 
аргументом fb, вызывается экземплярный метод FeedbackToFile, а адрес только что созданного объекта p передается этому методу в качестве неявного аргумента this.
	Метод FeedbackToFile отличается от методов FeedbackToConsole и FeedbackToMsgBox тем, что открывает файл и дописывает в его конец строку.
	
	Как видите, делегаты могут служить оболочкой как для статических, так и для экземплярных методов. В последнем случае делегат должен знать, какой экземпляр объекта будет 
обрабатывать вызываемый им метод. Создавая оболочку для экземплярного метода, вы предоставляете коду внутри объекта доступ к различным членам экземпляра объекта. Это означает 
наличие у объекта состояния, которое может использоваться во время выполнения метода обратного вызова.				
					
				Тонкости использования делегатов	
	На первый взгляд работать с делегатами легко. Они определяются при помощи ключевого слова C# delegate, оператор new создает экземпляры делегатов, а для 
обратного вызова служит уже знакомый синтаксис. В последнем случае вместо имени метода указывается ссылающаяся на делегат переменная.
На самом деле все обстоит несколько сложнее, чем демонстрируют приведенные примеры. Пользователи просто не осознают всей сложности процесса благодаря 
работе компиляторов и CLR. 
	Внимательно посмотрите на следующую строку:
		internal delegate void Feedback(Int32 value)
	Класс, определенный компилятором, содержит четыре метода: конструктор, а также методы Invoke, BeginInvoke и EndInvoke. В этой главы мы в основном будем рассматривать 
конструктор и метод Invoke. Методы BeginInvoke и EndInvokeотносятся к модели асинхронного программирования .NET Framework, которая сейчас считается устаревшей. Она была заменена 
асинхронными операциями, которые рассматриваются в главе 27				
	
	Внимание
		Класс System.MulticastDelegate является производным от класса System.Delegate, который, в свою очередь, наследует от класса System.Object.
	Следует помнить, что делегаты можно определять как внутри класса (вложенные в другой класс), так и в глобальной области видимости. По сути, так как делегаты являются классами, 
их можно определить в любом месте, где может быть определен класс.
Любые типы делегатов — это потомки класса MulticastDelegate, от которого они наследуют все поля, свойства и методы				
	Таким образом, любой делегат — это всего лишь обертка для метода и обрабатываемого этим методом объекта. Поэтому в следующих строчках кода переменные 
fbStatic и fbInstance ссылаются на два разных объекта Feedback, инициализированных, как показано на рис. 17.2:
	Feedback fbStatic = new Feedback(Program.FeedbackToConsole);
	Feedback fbInstance = new Feedback(new Program().FeedbackToFile)
	Теперь, когда вы познакомились с процессом создания делегатов и их внутренней структурой, поговорим о методах обратного вызова. Рассмотрим еще раз код 
метода Counter:

private static void Counter(Int32 from, Int32 to, Feedback fb) {
 for (Int32 val = from; val <= to; val++) {
 // Если указаны методы обратного вызова, вызываем их
 if (fb != null)
 fb(val);
 }
}

	Обратите внимание на строку под комментарием. Инструкция if сначала проверяет, не содержит ли переменная fb значения null. Если проверка пройдена, обращаемся к методу 
обратного вызова. Такая проверка необходима потому, что fb — это всего лишь переменная, ссылающаяся на делегат Feedback; она может иметь, в том числе, значение null. 
Может показаться, что происходит вызов функции fb, которой передается один параметр (val). Но у нас нет функции с таким именем. И компилятор генерирует код вызова метода Invoke 
делегата, так как он знает, что переменная fb ссылается на объект делегата. Другими словами, при обнаружении строки fb(val); компилятор генерирует такой же код, как и для строки:
fb.Invoke(val);				
					
					
				Обратный вызов нескольких методов (цепочки делегатов)	 (смотреть картинки)
	Делегаты полезны сами по себе, но еще более полезными их делает механизм цепочек. Цепочкой (chaining) называется коллекция делегатов, дающая возможность вызывать все методы, 
представленные этими делегатами.				
	Ссылочная переменная на делегат Feedback, которая называется fbChain, должна ссылаться на цепочку, или набор делегатов, служащих оболочками для методов обратного вызова. 
Инициализация переменной fbChain значением null указывает на отсутствие методов обратного вызова. Открытый статический метод Combine класса Delegate добавляет в цепочку делегатов:
	fbChain = (Feedback) Delegate.Combine(fbChain, fb1);
При выполнении этой строки метод Combine видит, что мы пытаемся объединить значение null с переменной fb1. В итоге он возвращает значение в переменную fb1, а затем заставляет 
переменную fbChain сослаться на делегата, на которого уже ссылается переменная fb1. Эта схема демонстрируется на рис. 17.4				

				Поддержка цепочек делегатов в C#
Чтобы упростить задачу разработчиков, компилятор C# автоматически предоставляет перегруженные версии операторов += и -= для экземпляров делегатов. Эти операторы вызывают методы 
Delegate.Combine и Delegate.Remove соответственно. Они упрощают построение цепочек делегатов. В результате компиляции методов ChainDelegateDemo1 и ChainDelegateDemo2 
(см. пример в начале главы) получается идентичный IL-code. Единственная разница в том, что благодаря операторам += и -= исходный код метода ChainDelegateDemo2 получается проще.
					
				Дополнительные средства управления цепочками делегатов
Итак, вы научились создавать цепочки делегатов и вызывать все их компоненты. Последняя возможность реализуется благодаря наличию в методе Invoke кода, 
просматривающего все элементы массива делегатов. И хотя этого простого алгоритма хватает для большинства сценариев, у него есть ряд ограничений. К примеру, 
сохраняется только последнее из значений, возвращаемых методами обратного вызова. Получить все остальные значения нельзя. И это не единственное ограничение. Скажем, в ситуации, 
когда один из делегатов в цепочке становится причиной исключения или блокируется на очень долгое время, выполнение цепочки останавливается. Понятно, что данный алгоритм не 
отличается надежностью. В качестве альтернативы можно воспользоваться экземплярным методом GetInvocationList класса MulticastDelegate. Этот метод позволяет в явном виде 
вызвать любой из делегатов в цепочке:	
	Метод GetInvocationList работает с объектами классов, производных от MulticastDelegate. Он возвращает массив ссылок, каждая из которых указывает 
на какой-то делегат в цепочке. По сути, этот метод создает массив и инициализирует его элементы ссылками на соответствующие делегаты; в конце возвращается 
ссылка на этот массив. Если поле _invocationList содержит null, возвращаемый массив будет содержать всего один элемент, ссылающийся на единственного делегата в цепочке — экземпляр 
самого делегата.				
					
					Обобщенные делегаты	
					
	В .NET Framework имеются 17 делегатов Action, от не имеющих аргументов вообще до имеющих 16 аргументов. Чтобы вызвать метод с большим количеством аргументов, придется 
определить собственного делегата, но это уже маловероятно.
Кроме делегатов Action в .NET Framework имеется 17 делегатов Func, которые позволяют методу обратного вызова вернуть значение.
Вместо определения собственных типов делегатов рекомендуется по мере возможности использовать обобщенных делегатов; ведь это уменьшает количество типов в системе и упрощает код. 
Однако, если нужно передать аргумент по ссылке, используя ключевые слова ref или out, может потребоваться определение собственного делегата:
	delegate void Bar(ref Int32 z);
	Аналогично нужно действовать в ситуациях, когда требуется передать делегату переменное число параметров при помощи ключевого слова params, если вы хотите задать значения 
по умолчанию для аргументов делегата или если потребуется установить ограничение для аргумента-типа. При работе с делегатами, использующими обобщенные аргументы и возвращающими 
значения, не следует забывать про ковариантность и контравариантность, так как это расширяет область применения делегатов. 
					
					Упрощенный синтаксис работы с делегатами	
	Многие программисты не любят делегатов из-за сложного синтаксиса. К примеру, рассмотрим строку:
		button1.Click += new EventHandler(button1_Click);
	
	Здесь button1_Click — метод, который выглядит примерно так:
		void button1_Click(Object sender, EventArgs e) {
		// Действия после щелчка на кнопке...
		}
		
	Однако данный делегат нужен среде CLR, так как он служит оберткой, гарантирующей безопасность типов при вызове метода. Обертка также поддерживает вызов экземплярных методов и 
создание цепочек. Тем не менее программисты не хотят вникать во все эти детали и предпочли бы записать код следующим образом:
	button1.Click += button1_Click;
К счастью, компилятор C# поддерживает упрощенный синтаксис при работе с делегатами. Однако перед тем как перейти к рассмотрению соответствующих возможностей, следует заметить, 
что это — не более чем упрощенные пути создания IL кода, необходимого CLR для нормальной работы с делегатами. Кроме того, следует учитывать, что описание упрощенного синтаксиса 
работы с делегатами относится исключительно к C#; другими компиляторами он может и не поддерживаться.
	Упрощение 1: не создаем объект делегата
Как вы уже видели, C# позволяет указывать имя метода обратного вызова без создания делегата, служащего для него оберткой. Вот еще один пример:

internal sealed class AClass {
 public static void CallbackWithoutNewingADelegateObject() {
 ThreadPool.QueueUserWorkItem(SomeAsyncTask, 5);
 }
 
 private static void SomeAsyncTask(Object o) {
 Console.WriteLine(o);
 }
}

Статический метод QueueUserWorkItem класса ThreadPool ожидает ссылку на делегата WaitCallback, который, в свою очередь, ссылается на метод SomeAsyncTask. 
Так как компилятор в состоянии догадаться, что именно имеется в виду, можно опустить строки, относящиеся к созданию делегата WaitCallback, чтобы упростить 
чтение и понимание кода. В процессе компиляции IL-код, генерирующий нового делегата WaitCallback, создается автоматически, а запись является всего лишь 
упрощенной формой синтаксиса

	Упрощение 2: не определяем метод обратного вызова
В приведенном фрагменте кода метод обратного вызова SomeAsyncTask передается методу QueueUserWorkItem класса ThreadPool. C# позволяет подставить реализацию 
метода обратного вызова непосредственно в код, а не в отдельный метод. Скажем, наш код можно записать так:

internal sealed class AClass {
 public static void CallbackWithoutNewingADelegateObject() {
 ThreadPool.QueueUserWorkItem( obj => Console.WriteLine(obj ), 5);
 }
}

Обратите внимание, что первый «аргумент» метода QueueUserWorkItem (он выделен полужирным шрифтом) представляет собой фрагмент кода! Формально в C# он называется лямбда-выражением 
(lambda expression) и распознается по наличию оператора =>. Лямбда-выражения используются в тех местах, где компилятор ожидает присутствия делегата. Обнаружив лямбда-выражение, 
компилятор автоматически определяет в классе новый закрытый метод (в нашем примере — AClass). Этот метод называется анонимной функцией (anonymous function), так как 
вы обычно не знаете его имени, которое автоматически создается компилятором. 
	Компилятор выбирает для метода имя, начинающееся с символа <, потому что в C# идентификаторы не могут содержать этот символ. Такой подход гарантирует, 
что программист не сможет случайно выбрать для какого-нибудь из своих методов имя, совпадающее с автоматически созданным компилятором. При этом, если в C# 
идентификаторы не могут содержать символа <, в CLR это разрешено. Несмотря на возможность обращения к методу через механизм отражения путем передачи 
его имени в виде строки, следует помнить, что компилятор может по-разному генерировать это имя при каждом следующем проходе.
Лямбда-выражение должно соответствовать сигнатуре делегата WaitCallback: возвращать void и принимать параметр типа Object. Впрочем, я указал имя параметра, просто поместив 
переменную obj слева от оператора =>. Расположенный справа от этого оператора метод Console.WriteLine действительно возвращает void. Если бы расположенное справа выражение 
не возвращало void, сгенерированный компилятором код просто проигнорировал бы возвращенное значение, ведь в противном случае не удалось бы соблюсти требования делегата WaitCallback.
Также следует отметить, что анонимная функция помечается как private; в итоге доступ к методу остается только у кода, определенного внутри этого же типа (хотя отражение позволит 
узнать о существовании метода). Обратите внимание, что анонимный метод определен как статический. Это связано с отсутствием у кода доступа к каким-либо членам экземпляра 
(ведь метод CallbackWithoutNewingADelegateObject сам по себе статический). Впрочем, код может обращаться к любым определенным в классе статическим полям или методам

Имена аргументов, которые следует передать лямбда-выражению, указываются слева от оператора =>. При этом следует придерживаться правил, которые мы рассмотрим на прим

И многое другое

	Упрощение 3: не создаем обертку для локальных переменных для передачи их методу обратного вызова
Вы уже видели, что код обратного вызова может ссылаться на другие члены класса. Но иногда бывает нужно обратиться из этого кода к локальному параметру или переменной внутри 
определяемого метода

				Делегаты и отражение


				Глава 18. Настраиваемые атрибуты
				
	Следует понимать, что настраиваемые атрибуты представляют собой лишь средство передачи некой дополнительной информации. Компилятор помещает эту информацию в метаданные 
управляемого модуля. Большая часть атрибутов для компилятора просто не имеет значения; он обнаруживает их в исходном коде и создает для них соответствующие метаданные

	Атрибут DllImport при применении к методу информирует CLR о том, что метод реализован в неуправляемом коде указанной DLL-библиотеки.
	Атрибут Serializable при применении к типу информирует механизмы сериализации о том, что экземплярные поля доступны для сериализации и десериализации.
	Атрибут AssemblyVersion при применении к сборке задает версию сборки.
	Атрибут Flags при применении к перечислимому типу превращает перечислимый тип в набор битовых флагов.

В C# имена настраиваемых атрибутов помещаются в квадратные скобки непосредственно перед именем класса, объекта и т. п. 
В частности, C# позволяет применять настраиваемые атрибуты только к исходному коду, определяющему такие элементы, как сборки, модули, типы (класс, структура, перечисление, 
интерфейс, делегат), поля, методы (в том числе конструкторы), параметры методов, возвращаемые значения методов, свойства, события, параметры обобщенного типа
Настраиваемый атрибут — это всего лишь экземпляр типа. Для соответствия общеязыковой спецификации (CLS) он должен прямо или косвенно наследовать от абстрактного 
класса System.Attribute. 
Как уже упоминалось, атрибуты являются экземплярами класса. И этот класс должен иметь открытый конструктор для создания экземпляров. А значит, синтаксис 
применения атрибутов аналогичен вызову конструктора. Следует заметить, что к одному элементу можно применить несколько атрибутов. Скажем, в приведенном в начале главы фрагменте 
кода к параметру ver метода GetVersionEx применяются атрибуты In и Out. Учтите, что порядок следования атрибутов в такой ситуации не имеет значения. В C# отдельные атрибуты 
могут заключаться в квадратные скобки; также возможно перечисление наборов атрибутов в этих скобках через запятую. Если конструктор класса атрибута не имеет параметров, 
круглые скобки можно опустить. Ну и, как уже упоминалось, суффикс Attribute также является необязательным. Показанные далее строки приводят к одному и тому же результату и 
демонстрируют все возможные способы применения набора атрибутов:
[Serializable][Flags]
[Serializable, Flags]
[FlagsAttribute, SerializableAttribute]
[FlagsAttribute()][Serializable()]

					Определение класса атрибутов
	Вы уже знаете, что любой атрибут представляет собой экземпляр класса, производного от System.Attribute. 
	Для начала нужно определить класс FlagsAttribute:
namespace System {
 public class FlagsAttribute : System.Attribute {
 public FlagsAttribute() {
 }
 }
}
Обратите внимание, что класс FlagsAttribute наследует от класса Attribute; именно это делает его CLS-совместимым. Вдобавок в имени класса присутствует 
суффикс Attribute. Это соответствует стандарту именования, хотя и не является обязательным. Наконец, все неабстрактные атрибуты должны содержать хотя бы 
один открытый конструктор. Простейший конструктор FlagsAttribute не имеет параметров и не выполняет никаких действий

			Конструктор атрибута и типы данных полей и свойств
			
			Выявление настраиваемых атрибуто
			И многое другое
			
			
				Глава 19. Null-совместимые значимые типы
	Как известно, переменная значимого типа не может принимать значение null; ее содержимым всегда является значение соответствующего типа. Именно поэтому 
типы и называют значимыми. Но в некоторых ситуациях такой подход создает проблемы. Например, при проектировании базы данных тип данных столбца можно 
определить как 32-разрядное целое, что в FCL соответствует типу Int32. Однако в столбце базы может отсутствовать значение, что соответствует значению null, 
и это — вполне стандартная ситуация. А это создаст проблемы при работе с базой данных средствами .NET Framework, ведь общеязыковая среда (CLR) не позволяет 
представить значение типа Int32 как null.
	Чтобы исправить ситуацию, в Microsoft разработали для CLR null-совместимые значимые типы (nullable value type). Чтобы понять, как они работают, познакомимся 
с определенным в FCL классом System.Nullable<T>. 
	
	Как видите, этот класс реализует значимый тип, который может принимать значение null. Так как Nullable<T> также относится к значимым типам, его экземпляры 
достаточно производительны, поскольку экземпляры могут размещаться в стеке, а их размер совпадает с размером исходного типа, к которому приплюсован размер 
поля типа Boolean. Имейте в виду, что в качестве параметра T типа Nullable могут использоваться только структуры — ведь переменные ссылочного типа и так могут 
принимать значение null.
	Итак, чтобы использовать в коде null-совместимый тип Int32, вы пишете конструкцию следующего вида:
Nullable<Int32> x = 5;
Nullable<Int32> y = null	
	
В настоящее время C# предлагает достаточно удобный синтаксис для работы с такими типами. Переменные x и y можно объявить и инициализировать прямо в коде, воспользовавшись 
знаком вопроса:
Int32? x = 5;
Int32? y = null;

В C# запись Int32? аналогична записи Nullable<Int32>. При этом вы можете выполнять преобразования, а также приведение null-совместимых экземпляров к другим типам. 
Язык C# поддерживает возможность применения операторов к экземплярам null-совместимых значимых типов.
Еще C# позволяет применять операторы к экземплярам null-совместимых типов. Следует учесть, что для операций с экземплярами null-совместимых типов генерируется большой объем кода. 
К примеру, рассмотрим метод:
private static Int32? NullableCodeSize(Int32? a, Int32? b) {
 return a + b;
}
В результате компиляции будет создан большой объем IL-кода, вследствие чего операции с null-совместимыми типами выполняются медленнее аналогичных операций с другими типами
Напоследок напомню о возможности определения ваших собственных значимых типов, перегружающих упомянутые операторы. О том, как именно это делается, мы говорили в главе 8

		Оператор объединения null-совместимых значений 
В C# существует оператор объединения null-совместимых значений (null-coalescing operator). Он обозначается знаками ?? и работает с двумя операндами. Если левый 
операнд не равен null, оператор возвращает его значение. В противном случае возвращается значение правого операнда. Оператор объединения null-совместимых значений удобен при 
задании предлагаемого по умолчанию значения переменной.
Некоторые пользователи считают оператор объединения null-совместимых значений всего лишь синтаксическим сокращением для оператора ?. Однако оператор ?? предоставляет два важных 
синтаксических преимущества. Во-первых, он лучше работает с выражениями:

	Func<String> f = () => SomeMethod() ?? "Untitled";
	
Прочитать и понять эту строку намного проще, чем следующий фрагмент кода, требующий присваивания переменных и использования нескольких операторов:
	Func<String> f = () => { var temp = SomeMethod();
	return temp != null ? temp : "Untitled";};
	
Во-вторых, оператор ?? лучше работает в некоторых сложных ситуациях:
String s = SomeMethod1() ?? SomeMethod2() ?? "Untitled";

		Упаковка null-совместимых значимых типов 
Представим переменную типа Nullable<Int32>, которой логически присваивается значение null. Для передачи этой переменной методу, ожидающему ссылки на тип Object, ее следует 
упаковать и передать методу ссылку на упакованный тип Nullable<Int32>. Однако при этом в метод будет передано отличное от null значение, несмотря на то что тип Nullable<Int32> 
содержит null. Эта проблема решается в CLR при помощи специального кода, который при упаковке null-совместимых типов создает иллюзию их принадлежности к обычным типам.
При упаковке экземпляра Nullable<T> проверяется его равенство null и в случае положительного результата вместо упаковки возвращается null. В противном случае CLR упаковывает 
значение экземпляра. Другими словами, тип Nullable<Int32> со значением 5 упаковывается в тип Int32 с аналогичным значением. Следующий код демонстрирует такое поведение:

// После упаковки Nullable<T> возвращается null или упакованный тип T
Int32? n = null;
Object o = n; // o равно null
Console.WriteLine("o is null={0}", o == null); // "True"
n = 5;
o = n; // o ссылается на упакованный тип Int32
Console.WriteLine("o's type={0}", o.GetType()); // "System.Int32"

		Распаковка null-совместимых значимых типов
В CLR упакованный значимый тип T распаковывается в T или в Nullable<T>. Если ссылка на упакованный значимый тип равна null и выполняется распаковка в тип 
Nullable<T>, CLR присваивает Nullable<T> значение null. Пример:
// Создание упакованного типа Int32
Object o = 5;
// Распаковка этого типа в Nullable<Int32> и в Int32
Int32? a = (Int32?) o; // a = 5
Int32 b = (Int32) o; // b = 5
// Создание ссылки, инициализированной значением null
o = null;
// "Распаковка" ее в Nullable<Int32> и в Int32
a = (Int32?) o; // a = null
b = (Int32) o; // NullReferenceException

		Вызов метода GetType через null-совместимый значимый тип
При вызове метода GetType для объекта типа Nullable<T> CLR возвращает тип T вместо Nullable<T>. Пример:
Int32? x = 5;
// Эта строка выводит "System.Int32", а не "System.Nullable<Int32>"
Console.WriteLine(x.GetType())

		Вызов интерфейсных методов через null-совместимый значимый тип
В приведенном далее фрагменте кода переменная n типа Nullable<Int32> приводится к интерфейсному типу IComparable<Int32>. Но тип Nullable<T> в отличие от 
типа Int32 не реализует интерфейс IComparable<Int32>. Тем не менее код успешно компилируется, а механизм верификации CLR считает, что код прошел проверку, 
чтобы вы могли использовать более удобный синтаксис.

Int32? n = 5;
Int32 result = ((IComparable) n).CompareTo(5); // Компилируется и выполняется
Console.WriteLine(result); // 0

Без подобной поддержки со стороны CLR пришлось бы писать громоздкий код вызова интерфейсного метода через null-совместимый значимый тип. Для вызова 
метода потребовалось бы приведение распакованного значимого типа перед приведением к интерфейсу:

Int32 result = ((IComparable) (Int32) n).CompareTo(5); // Громоздкий коl
		
		
								Глава 20. Исключения и управление состоянием
								
							Механика обработки исключений
	Следует также упомянуть, что в основе обработки исключений в .NET Framework лежит структурная обработка исключений (Structured Exception Handling, SEH) Windows
	Рассмотрим код, демонстрирующий стандартное применение механизма обработки исключений. Он дает представление о виде и предназначении блоков обработки исключений. 
В комментариях дано формальное описание блоков try, catch и finally.

private void SomeMethod() {
try {
 // Код, требующий корректного восстановления или очистки ресурсов
}
catch (InvalidOperationException) {
 // Код восстановления работоспособности после исключения InvalidOperationException
}
catch (IOException) {
 // Код восстановления работоспособностипосле исключения IOException
}
catch {
 // Код восстановления работоспособности после остальных исключений. После перехвата исключений их обычно генерируют повторно
 throw;
}
finally {
 // Здесь находится код, выполняющий очистку ресурсов после операций, начатых в блоке try. Этот код выполняется ВСЕГДА вне зависимости от наличия исключения
 }
// Код, следующий за блоком finally, выполняется, если в блоке try не генерировалось исключение или если исключение было перехвачено блоком catch, а новое не генерировалось
}

	Блок try
В блок try помещается код, требующий очистки ресурсов и/или восстановления после исключения. Код очистки содержится в блоке finally. В блоке try может располагаться также код, 
приводящий к генерации исключения. Код же восстановления вставляют в один или несколько блоков catch. Один блок catch соответствует одному событию, после которого по вашим 
предположениям может потребоваться восстановление приложения. Блок try должен быть связан хотя бы с одним блоком catch или finally; сам по себе он не имеет смысла, и C# запрещает 
такие определения.

	Блок catch
В блок catch помещают код, который должен выполняться в ответ на исключение. Блок try может быть связан как с набором блоков catch, так и не ассоциироваться 
ни с одним таким блоком. Если код в блоке try не порождает исключение, CLR никогда не переходит к выполнению кода в соответствующем блоке catch. Поток просто пропускает их, 
сразу переходя к коду блока finally (если таковой, конечно, существует). Выполнив код блока finally, поток переходит к инструкции, следующей за этим блоком.
Выражение в скобках после ключевого слова catch называется типом исключения (catch type). В C# эту роль играет тип System.Exception и его производные. 
В предыдущем примере первые два блока catch обрабатывали исключения типа InvalidOperationException и IOException В последнем блоке (для которого не был явно указан тип исключения) 
обрабатывались все остальные виды исключений. Это эквивалентно блоку catch для исключений типа System.Exception, не считая того, что информация исключения в коде, 
заключенном в фигурные скобки, недоступна.
	Поиск подходящего блока catch в CLR осуществляется сверху вниз, поэтому наиболее конкретные обработчики должны находиться в начале списка. Сначала следуют потомки с наибольшей 
глубиной наследования, потом — их базовые классы (если таковые имеются) и, наконец, — класс System.Exception (или блок с неуказанным типом исключений). В противном случае 
компилятор сообщит об ошибке, так как более узкоспециализированные блоки в такой ситуации окажутся для него недостижимыми
	Исключение, сгенерированное при выполнении кода блока try (или любого вызванного этим блоком метода), инициирует поиск блоков catch соответствующего типа. При отсутствии 
совпадений CLR продолжает просматривать стек вызовов в поисках типа исключения, соответствующего данному исключению. Если при достижении вершины стека блок catch нужного типа 
обнаружен не будет, исключение считается необработанным. Эту ситуацию мы рассмотрим чуть позже.
При обнаружении блока catch нужного типа CLR исполняет все внутренние блоки finally, начиная со связанного с блоком try, в котором было вброшено исключение, и заканчивая блоком 
catch нужного типа. При этом ни один блок finally не выполняется до завершения действий с блоком catch, обрабатывающим исключение.
После того как код внутренних блоков finally будет выполнен, исполняется код из обрабатывающего блока catch. Здесь выбирается способ восстановления после исключения. Затем можно 
выбрать один из трех вариантов действий:
	еще раз сгенерировать то же исключение для передачи информации о нем коду, расположенному выше в стеке;
	сгенерировать исключение другого типа для передачи дополнительной информации коду, расположенному выше в стеке;
	позволить программному потоку выйти из блока catch естественным образом.

	В последнем же случае происходит переход к блоку finally (если он, конечно, существует). После выполнения всего содержащегося в нем кода управление переходит к расположенной 
после блока finally инструкции. Если блок finally отсутствует, поток переходит к инструкции, расположенной за последним блоком catch. В C# после типа перехватываемого исключения 
можно указать имя переменной, которая будет ссылаться на сгенерированный объект, потомок класса System.Exception. В коде блока catch эту переменную можно использовать для получения 
информации об исключении (например, данных трассировки стека, приведшей к исключению). Объект, на который ссылается переменная, в принципе можно редактировать, но я рекомендую 
рассматривать его как предназначенный только для чтения. Впрочем, подробный разговор о типе Exception и манипуляциях им вынесен в отдельный раздел.

		Блок finally
	Код блока finally выполняется всегда. Обычно этот код производит очистку после выполнения блока try. Если в блоке try был открыт некий файл, блок finally
должен содержать закрывающий этот файл код:

private void ReadData(String pathname) {
 FileStream fs = null;
 try {
 fs = new FileStream(pathname, FileMode.Open);  // Обработка данных в файле
 }
 catch (IOException) {
 // Код восстановления после исключения IOException
 }
 finally {
 // Файл обязательно следует закрыть
 if (fs != null) fs.Close();
 }
}

	Если код блока try выполняется без исключений, файл закрывается. Впрочем, поскольку даже исключение не помешает выполнению кода в блоке finally, файл 
гарантированно будет закрыт. А если поместить инструкцию закрытия файла после блока finally, в случае неперехваченного исключения файл останется открытым 
(до следующего прохода уборщика мусора).
Блок try может существовать и без блока finally, ведь иногда его код просто не требует последующей очистки. Однако если вы решили создать блок finally, 
его следует поместить после всех блоков catch. И помните, что одному try может соответствовать только один блок finally.

				Класс System.Exception
	CLR позволяет генерировать в качестве исключений экземпляры любого типа — от Int32 до String. Но в Microsoft решили, что не стоит заставлять все языки генерировать и 
перехватывать исключения произвольного типа. Соответственно, был создан тип System.Exception.

				Генерирование исключений
	Во-первых, следует понять, к какому производному от типа Exception типу будет относиться ваше исключение. Выбирать следует осмотрительно. Подумайте 
о том, каким образом код, расположенный выше по стеку вызовов, сможет получать информацию о неудачной работе метода, чтобы выполнить восстановительные операции. 
Можно воспользоваться для этой цели одним из типов, определенных в FCL, но может оказаться и так, что там пока отсутствует подходящий тип. В таком случае вам потребуется 
определить собственный тип, производный от класса System.Exception.
Если вы собираетесь создать иерархию исключений, постарайтесь, чтобы она содержала как можно меньше базовых классов. Дело в том, что базовые классы зачастую обрабатывают 
несколько ошибок по одним правилам, а это может быть опасно. Соответственно, никогда не следует создавать объекты System.Exception и всегда нужно соблюдать максимальную 
осторожность при генерировании исключений базовых классов.
	Во-вторых, следует решить, какое строковое сообщение должно быть передано конструктору исключения. Генерирование исключения должно сопровождаться подробной информацией о том, 
почему метод не смог решить свою задачу. При обработке перехваченного исключения это сообщение остается невидимым. С другой стороны, если исключение останется необработанным, 
оно с большой вероятностью будет зарегистрировано в журнале. Необработанное исключение свидетельствует о наличии в приложении дефекта, об искоренении которого должен позаботиться 
разработчик. Конечные пользователи не имеют доступа к исходному коду и не могут перекомпилировать программу. Соответственно, не видят они и данного сообщения, поэтому туда можно 
включать всю техническую информацию, необходимую для устранения дефекта

				Создание классов исключений
				Приемы работы с исключениями
	Активно используйте блоки finally
По-моему, блоки finally — прекрасное средство! Они позволяют определять код, который будет гарантированно исполнен независимо от вида сгенерированного потоком исключения. 
Блоки finally нужны, чтобы выполнить очистку после любой успешно начатой операции, прежде чем вернуть управление или продолжить исполнение кода, расположенного после них. 
Блоки finally также часто используются для явного уничтожения любых объектов с целью предотвращения утечки ресурсов. В следующем примере в этом блоке размещен весь код, выполняющий 
очистку (закрывающий файл)

	Гарантированное исполнение кода очистки при любых обстоятельствах настолько важно, что большинство языков поддерживает соответствующие программные конструкции. Например, в C# 
при использовании инструкций lock, using и foreach блоки try/finally создаются автоматически. Компилятор строит эти блоки и при переопределении деструктора класса (метод Finalize). 
При работе с упомянутыми конструкциями написанный вами код помещается в блок try, а код очистки — в блок finally. А именно:
	если вы используете инструкцию lock, то внутри блока finally снимается блокировка;
	если вы используете инструкцию using, то внутри блока finally для объекта вызывается метод Dispose;
	если вы используете инструкцию foreach, то внутри блока finally для объекта IEnumerator вызывается метод Dispose;
	если вы определяете деструктор, то внутри блока finally вызывается метод Finalize базового класса

	Не надо перехватывать все исключения
Распространенная ошибка — слишком частое и неуместное использование блоков catch. Перехватывая исключение, вы тем самым заявляете, что ожидали его, понимаете его причины и знаете, 
как с ним разобраться. Другими словами, вы определяете политику для приложения. Эта тема подробно раскрыта в разделе «Продуктивность вместо надежности
	catch (Exception) {
 ...
}

Этот код демонстрирует, что в нем предусмотрены все исключения любых типов и он способен восстанавливаться после любых исключений в любых ситуациях. 
Разве это возможно? Тип из библиотеки классов ни в коем случае не должен перехватывать все исключения подряд: ведь он не может знать наверняка, как приложение должно 
реагировать на исключения. Кроме того, такой тип будет часто вызывать код приложения через делегата, виртуальный метод или интерфейсный метод. Если в одной части приложения 
возникает исключение, то в другой части, вероятно, есть код, способный перехватить его. Исключение должно пройти через фильтр перехвата и быть передано вверх по стеку вызовов, 
чтобы код приложения смог обработать его как надо. Если исключение осталось необработанным, CLR завершает процесс. О необработанных исключениях мы поговорим чуть позже. 
Большинство из них обнаруживаются на стадии тестирования. Для борьбы с ними следует либо заставить код реагировать на определенное исключение, либо переписать его, устранив условия, 
ставшие причиной сбоя. Число необработанных исключений в окончательной версии программы, предназначенной для выполнения в производственной среде, должно быть минимальным, 
а сама программа должна быть исключительно устойчивой
	Кстати, вполне допустимо перехватить исключение System.Exception и выполнить определенный код внутри блока catch при условии, что в конце этого кода 
исключение будет сгенерировано снова. Перехват и поглощение (без повторного генерирования) исключения System.Exception недопустимо, так как оно приводит 
к сокрытию факта сбоя и продолжению работы приложения с непредсказуемыми результатами, что означает нарушение безопасности. Предоставляемая компанией Microsoft утилита FxCopCmd.exe 
позволяет находить блоки catch (Exception), в коде которых отсутствует инструкция throw. 
	Наконец, допускается перехватить исключение, возникшее в одном потоке, и повторно сгенерировать его в другом потоке. Такое поведение поддерживает модель асинхронного 
программирования (см. главу 28). Например, если поток из пула потоков выполняет код, который вызывал исключение, CLR перехватывает и игнорирует исключение, позволяя потоку 
вернуться в пул. Позже один из потоков должен вызвать метод EndXxx, чтобы выяснить результат асинхронной операции. Метод EndXxx сгенерирует такое же исключение, что и поток из пула, 
выполнявшего заданную работу. В данной ситуации исключение поглощается первым потоком, но повторно генерируется потоком, вызывавшим метод EndXxx, в результате ошибка 
не оказывается скрытой от приложения
					
					Корректное восстановление после исключения
					Отмена незавершенных операций при невосстановимых исключениях
	Обычно для выполнения единственной абстрактной операции методу приходится вызывать несколько других методов, одни из которых могут завершаться успешно, 
а другие — нет. Допустим, происходит сериализация набора объектов в файл. После сериализации 10 объектов генерируется исключение (например, из-за переполнения 
диска или из-за отсутствия атрибута Serializable у следующего сериализуемого объекта). После этого исключение фильтруется и передается вызывающему методу, 
но в каком состоянии остается файл? Он оказывается поврежденным, так как в нем находится частично сериализованный граф объектов. Было бы здорово, если бы 
приложение могло отменить незавершенные операции и вернуть файл в состояние, в котором он был до записи сериализованных объектов. Правильная реализация 
должна выглядеть примерно так:
	Для корректной отмены незавершенных операций код должен перехватывать все исключения. Да, здесь нужно перехватывать все исключения, так как важен не тип 
ошибки, а возвращение структур данных в согласованное состояние. Перехватив и обработав исключение, не поглощайте его — вызывающему коду необходимо сообщить о ситуации. 
Это делается путем повторного генерирования того же исключения. В С# и многих других языках это осуществляется просто: просто укажите ключевое слово throw без продолжения, 
как в предыдущем фрагменте кода. Обратите внимание, что в предыдущем примере не указан тип исключения в блоке catch, поскольку здесь требуется перехватывать абсолютно 
все исключения. К счастью, в C# достаточно опустить тип исключения, и инструкция throw повторно сгенерирует это исключение.

					Сокрытие деталей реализации для сохранения контракта
					Необработанные исключения
	Итак, при появлении исключения CLR начинает в стеке вызовов поиск блока catch, тип которого соответствует типу исключения. Если ни один из блоков catch
не отвечает типу исключения, возникает необработанное исключение (unhandled exception). Обнаружив в процессе поток с необработанным исключением, CLR немедленно уничтожает 
этот поток. Необработанное исключение указывает на ситуацию, которую не предвидел программист, и должно считаться признаком серьезной ошибки в приложении. На этом этапе 
о проблеме следует уведомить компанию, где разработано приложение, чтобы авторы могли устранить неполадку и выпустить исправленную версию


						Глава 21. Автоматическое управление памятью (уборка мусора)
						Глава 22. Хостинг CLR и домены приложений
						Глава 23. Загрузка сборок и отражение
						Глава 24. Сериализация
						Глава 25. Взаимодействие с компонентами WinRT
						
						
						
						Глава 26. Потоки исполнения
	Потоки нужны: т.к на заре компьютерной эры операционные системы не поддерживали концепцию потоков. Соответственно любые задачи которые выполнялись длительное время приостанавливали
выполнение других задач, либо приводили к ошибки и проходилось перезагружать систему. Но даже с новвоведением процессов это не решало проблему. Поэтому для решения этих проблем 
были придуманы потоки. Каждому процессу выделяется собственный поток исполнения, который работает как виртуальный процессор. Если код приложения войдет в бесконечный цикл, 
то блокируется только связанный с этим кодом процесс, а остальные процессы продолжают функционировать!
	Процесс - набор ресурсов, используемый отдельным экземпляром приложения и имеет собственно виртуальное адресное пространство; 
	это гарантирует, что код и данные одного процесса будут недоступны для другого, код и данные ядра также недоступны для процессов; 
делает приложения отказоустойчивыми, а система становится более безопасной, потому что код произвольного приложения не имеет доступа к конфиденциальным данным, 
с которыми работают другие приложения.

	Различие между процессом и потоком:
	Поток и процесс служать для разделения работы.
	Поток стоит выбирать для легковесных операций, в то время как процесс для тяжелых операций.
	Каждый процесс имеет собственное виртуальное пространство с набором ресурсов, а инициализированный поток использует эти ресурсы.
	Обменн даных между потоками в рамках одного процесса быстрее, чем у отдельных процессов.
	
	Переключения контекста (context switching) - механизм который позволяет распределять физический процессор между всеми своими потоками. Например поток исполняется в течение 
некоторого временного интервала, после завершения этого интервала контекст Windows переключается на другой поток. После переключения контекста процессор исполняет выбранный 
поток, пока не истечет выделенное потоку время, после этого снова происходит переключение контекста. Windows делает это примерно каждые 30 мс. Оно требуется только для того, 
чтобы операционная система была надежной и быстро реагировала на действия конечных пользователей. Если поток какого-то приложения зацикливается, Windows его периодически выгружает 
и передает процессору другой поток для исполнения. Процесс в результате прекращает свою работу, теряя несохраненные данные, но остальные процессы в системе продолжают 
функционировать, как ни в чем не бывало. Переключение контекстов приводит к повышению отказоустойчивости, хотя за это приходится платить снижением производительности.
	При переключении контекста на другой поток производительность серьезно падает. Пока работа ведется с одним потоком, его код и данные находятся в кэше процессора, чтобы 
обращения процессора к оперативной памяти, замедляющие работу, происходили реже. Однако новый поток, скорее всего, исполняет совсем другой код и имеет доступ к другим данным, 
которых еще нет в кэше процессора. Значит, прежде чем вернуться к прежней скорости работы, процессор вынужден некоторое время 
обращаться к оперативной памяти, наполняя кэш. А время заполнения кэша зависит от запущенных в системе приложений, размера самого кэша и 
ряда других факторов. Достаточно просто запомнить, что при разработке высокопроизводительных приложений и компонентов переключения контекста нужно по возможности избегать.
	В ходе процедуры уборки мусора CLR приостанавливает все потоки, просматривает их стеки в поисках корней, помечает объекты в куче, снова просматривает 
стеки (обновляя корни объектов, перемещенных в процессе сжатия) и возобновляет исполнение всех потоков. Таким образом, сокращение количества потоков повысит 
производительность уборки мусора. В процессе отладки Windows приостанавливает все потоки приложения в каждой точке останова и снова запускает их при переходе 
к следующему шагу или при запуске приложения. Соответственно, чем больше потоков, тем медленнее будет происходить отладка.						

	Приоритет потоков	
	Лучше снизить приоритет одного потока, чем повысить приоритет другого. Обычнопонижение приоритета требуется, если поток выполняет длительные вычисления, например компилирует код,
проверяет орфографию, пересчитывает электронные таблицы и т. п. Повышать приоритет имеет смысл, если поток должен быстро отреагировать на какое-то событие, запуститься на 
короткий промежуток времени и вернуться в состояние ожидания.				

	Фоновые и активные потоки
	В CLR все потоки делятся на активные (foreground) и фоновые (background). При завершении активных потоков в процессе CLR принудительно завершает также все запущенные на 
этот момент фоновые потоки.  Следовательно, активные потоки имеет смысл использовать для исполнения заданий, которые обязательно требуется завершить — например, для перемещения на 
диск данных из буфера в памяти. Фоновые же потоки можно оставить для таких некритичных задач, как пересчет ячеек электронных таблиц или индексирование записей. 
	Концепция активных и фоновых потоков в CLR была введена для лучшей поддержки доменов приложений. Как вы знаете, в каждом домене может быть запущено 
отдельное приложение, при этом каждое такое приложение может иметь собственный фоновый поток. Даже если одно из приложений завершается, заставляя завершиться 
свой фоновый поток, среда CLR все равно должна функционировать, поддерживая остальные приложения. И только после того как все приложения со всеми своими 
фоновыми процессами будут завершены, можно будет уничтожить весь процесс.
	Поток можно превращать из активного в фоновый и обратно. Основной поток приложения и все потоки, в явном виде созданные путем конструирования объекта 
Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию являются фоновыми. Также потоки, создаваемые машинным кодом и попадающие в управляемую среду 
исполнения, помечаются как фоновые.					
	
	Ресурсоемкость потоков	
	Потоки — изобретение, благодаря которым Windows реагирует на наши действия вовремя исполнением длительных заданий, а с помощью диспетчера задач можно принудительно прекратить 
работу другого приложения, если оно перестает отвечать на запросы, но, потоки потребляют дополнительные ресурсы, требуя пространства и времени, снижая производительность среды исполнения.
Поток состоит из нескольких частей.
	Объект ядра потока (thread kernel object). Для каждого созданного потока операционная система выделяет и инициализирует одну из структур данных, которая содержит контекст потока, 
то есть блок памяти с набором регистров процессора.
	Блок окружения потока (Thread Environment Block, TEB). Это место в памяти, выделенное и инициализированное в пользовательском режиме адресное пространство, к которому имеет 
быстрый доступ код приложений. Он содержит заголовок цепочки обработки исключений. Каждый блок try, в который входит поток, вставляет свой узел в начало цепочки. Когда поток выходит из 
блока try, узел из цепочки удаляется. Также TEB содержит локальное хранилище данных для потока и некоторые структуры данных, используемые интерфейсом графических устройств.
	Стек пользовательского режима (user-mode stack). Применяется для хранения передаваемых в методы локальных переменных и аргументов. Также он содержит адрес, показывающий, 
откуда начнет исполнение поток после того, как текущий метод возвратит управление.
	Стек режима ядра (kernel-mode stack). Используется, когда код приложения передает аргументы в функцию операционной системы, находящуюся в режиме ядра. Windows копирует все 
аргументы, передаваемые в ядро из стека потока пользовательского режима в стек режима ядра. После копирования ядро проверяет значения аргументов и с ними начинает работать 
код ядра операционной системы. 
	Уведомления о создании и завершении потоков. Если в процессе создается поток, то для всех загруженных в этот процесс DLL-библиотек вызывается метод DllMain в который 
передается флаг DLL_THREAD_ATTACH, а при завершении потока этому методу передается уже флаг DLL_THREAD_DETACH после получения этого флага некоторые DLL-библиотеки выполняют 
операции инициализации или очистки для каждого созданного/завершенного в процессе потока.
							
						
						Глава 27. Асинхронные вычислительные операции
	Потоки для асинхронных вычислительных операций
	При этом я не рекомендую пользоваться приемами, описываемыми в этом разделе (а для приложений Windows Store они и вовсе невозможны из-за недоступности класса System.Thread). 
По возможности для этой цели лучше прибегать к доступному в CLR пулу потоков (thread pool). О нем мы поговорим в следующей главе.				
					
	Способы создания потока:
	Для создания выделенного потока вам потребуется экземпляр класса System.Threading.Thread, для получения которого следует передать конструктору имя метода					
	Параметр start задает метод, который будет выполняться в выделенном потоке. Сигнатура этого метода должна совпадать с сигнатурой делегата
ParameterizedThreadStart: delegate void ParameterizedThreadStart(Object obj);					
	Создание объекта Thread является достаточно простой операцией, так как при
этом физический поток в операционной системе не появляется. Для создания
физического потока, призванного исполнить метод обратного вызова, следует
воспользоваться методом Start класса Thread, передав в него объект (состояние),
который вы хотите сделать аргументом метода обратного вызова. Следующий код
демонстрирует процедуру создания выделенного потока, который затем асинхронно
вызывает метод:			
Класс Thread также предлагает конструктор, принимающий делегат ThreadStart, который
не имеет аргументов и не возвращает значений. Но лично я не рекомендую их использовать
из-за многочисленных ограничений. Если метод вашего потока принимает класс Object и
возвращает значение типа void, вызовите его при помощи выделенного потока или пула
потока, как показано в главе 27		
						
	все потоки, в явном виде созданные путем конструирования объекта
Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию
являются фоновыми. Также потоки, создаваемые машинным кодом и попадающие
в управляемую среду исполнения, помечаются как фоновые.					
						
	Пул потоков в CLR
	Cоздание и уничтожение потока занимает изрядное время, а при наличии множества потоков впустую расходуется память и снижается производительность, т.к приходится
планировать исполнение потоков и выполнять переключения контекста.
	Среда CLR способна управлять собственным пулом потоков. Для каждого экземпляра CLR существует свой пул, используемый всеми доменами приложений, находящимися под управлением 
экземпляра CLR. Если в один процесс загружаются несколько экземпляров CLR, для каждого из них формируется собственный пул.
	При инициализации CLR пул потоков пуст. В его внутренней реализации поддерживается очередь запросов на выполнение операций. Для выполнения приложением асинхронной операции 
вызывается метод, размещающий соответствующий запрос в очереди пула потоков. Код пула извлекает записи из очереди и распределяет их среди потоков из пула. Если пул пуст, 
создается новый поток. По завершении исполнения своего задания поток не уничтожается, а возвращается в пул и ожидает следующего запроса. Поскольку поток не уничтожается, 
производительность не страдает.
	Когда приложение отправляет пулу много запросов, он пытается обслужить их все с помощью одного потока. Однако если приложение создает очередь запросов быстрее, чем поток 
из пула их обслуживает, создаются дополнительные потоки.
	Когда приложение прекращает отправлять запросы в пул, появляются незанятые потоки, впустую занимающие память. Поэтому через некоторое время бездействия поток пробуждается и 
самоуничтожается, освобождая ресурсы.
	Пул потоков позволяет найти компромисс в ситуации, когда малое количество потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами многопроцессорных систем, 
а также многоядерных и гиперпотоковых процессоров.
					
	Для добавления в очередь пула потоков асинхронных вычислительных операций обычно вызывают один из следующих методов класса ThreadPool:
static Boolean QueueUserWorkItem(WaitCallback callBack);
static Boolean QueueUserWorkItem(WaitCallback callBack, Object state);					
	Эти методы ставят «рабочий элемент» вместе с дополнительными данными состояния в очередь пула потоков и сразу возвращают управление приложению. 					
	Этому методу можно передать один параметр через аргумент state данные состояния. Без этого параметра версия метода QueueUserWorkItem передает методу обратного вызова 
значение null. Все заканчивается тем, что один из потоков пула обработает рабочий элемент, приводя к вызову указанного метода. Создаваемый метод обратного вызова должен 
соответствовать делегату System.Threading.WaitCallback, который определяется так: delegate void WaitCallback(Object state);
					
	Преимуществ: нет необходимости создавать новый поток на каждое задание, что повышает производительность приложения.
	
	Задания Task.
	Вызвать метод QueueUserWorkItem класса ThreadPool для запуска асинхронных вычислительных операций очень просто. Однако этот подход имеет множество недостатков. 
Самой большой проблемой является отсутствие встроенного механизма, позволяющего узнать о завершении операции и получить возвращаемое значение. Для обхода этих и других 
ограничений специалисты Microsoft ввели понятие заданий (tasks), выполнение которых осуществляется посредством типов из пространства имен System.Threading.Tasks.
Вот каким образом при помощи заданий выполняется операция, аналогичная вызову метода QueueUserWorkItem класса ThreadPool:					
		ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5); // Вызов QueueUserWorkItem
		new Task(ComputeBoundOp, 5).Start(); // Аналог предыдущей строки
		Task.Run(() => ComputeBoundOp(5)); // Еще один аналог										
	Во второй строке после создания нового объекта Task немедленно вызывается метод Start для запуска задания. Естественно, вы можете создать объект Task и вызвать Start для него 
позднее. Можно также представить код, передающий созданныйим объект Task какому-то стороннему методу, который и будет определять момент вызова метода Start. Поскольку создание 
объекта Task с немедленным вызовом Start выполняется так часто, также можно воспользоваться удобным статическим методом Run класса Task, как показано в последней строке.
	Для создания объекта Task следует вызвать конструктор и передать ему делегата Action или Action<Object>, указывающего, какую операцию вы хотите выполнить. При передаче метода, 
ожидающего тип Object, в конструктор объекта Task следует передать также аргумент, который должен быть в итоге передан операции.
	При вызове Run передается делегат Func<TResult> или Action, определяющий выполняемую операцию. Также конструктору можно передать еще и структуру CancellationToken, позволяющую 
отменить объект Task до его выполнения.
	При желании конструктору можно передавать флаги из перечисления TaskCreationOptions, управляющие способами выполнения заданий. Элементы перечисления определяют набор флагов, 
которые могут комбинироваться поразрядной операцией ИЛИ.				
						
	Можно дождаться завершения задания и после этого получить результат его выполнения. 
	Можно создать объект Task<TResult> и в качестве универсального аргумента TResult передать тип результата, возвращаемого вычислительной операцией. Затем остается дождаться 
завершения выполняющегося задания и получить результат при помощи следующего кода:
		Task<Int32> t = new Task<Int32>(n => Sum((Int32)n), 1000000000); // Создание задания Task (оно пока не выполняется)
		t.Start(); // Можно начать выполнение задания через некоторое время
		t.Wait(); //Можно ожидать завершения задания в явном виде. Существует перегруженная версия, принимающая тайм-аут/CancellationTokenПолучение результата (свойство Result вызывает метод Wait)
		Console.WriteLine("The Sum is: " + t.Result); // Значение Int32
	При вызове потоком метода Wait система проверяет, началось ли выполнение задания Task, которого ожидает поток. В случае положительного результата проверки поток,
вызывающий метод Wait, блокируется до завершения задания. Но если задание еще не начало выполняться, система может выполнить его при помощи потока, вызывающего метод Wait. 
В этом случае данный поток не блокируется. Он выполняет задание Task и немедленно возвращает управление. Это снижает затраты ресурсов, повышает производительность. Однако и это 
может быть не очень хорошо. Например, если перед вызовом метода Wait в рамках синхронизации потока происходит его блокирование, а затем задание пытается получить доступ к тем же
запертым ресурсам, возникает взаимная блокировка (deadlock)!
	Если вычислительное задание генерирует необработанное исключение, оно поглощается и сохраняется в коллекции, а потоку пула разрешается вернуться в пул.
Затем при вызове метода Wait или свойства Result эти члены вбросят исключение System.AggregateException.
	Тип AggregateException инкапсулирует коллекцию исключений (которые генерируются, если родительское задание порождает многочисленные дочерние задания, приводящие к исключениям).
	Можно ожидать завершения не только одного задания, но и массива объектов Task. Для этого в одноименном классе существует два статических метода. Метод WaitAny блокирует вызов 
потоков до завершения выполнения всех объектов в массиве Task. Этот метод возвращает индекс типа Int32 в массив, содержащий завершенные задания, заставляя поток продолжить 
исполнение. Если происходит тайм-аут, метод возвращает –1. Отмена же метода посредством структуры CancellationToken приводит к исключению OperationCanceledException.
	Статический метод WaitAll класса Task блокирует вызывающий поток до завершения всех объектов Task в массиве. Метод возвращает значение true после
завершения всех объектов и значение false, если истекает время ожидания. Отмена этого метода посредством структуры CancellationToken также приводит
к исключению OperationCanceledException.
	
	Для написания масштабируемого программного обеспечения следует избегать блокировки потоков. Вызов метода Wait или запрос свойства Result при незавершенном задании приведет, 
скорее всего, к появлению в пуле нового потока, что увеличит расход ресурсов и отрицательно скажется на расширяемости. К счастью, существует способ узнать о завершении задания. 
Оно может просто инициировать выполнение следующего задания. Вот как следует переписать предыдущий код, чтобы избежать блокировки потоков:
		Task<Int32> t = Task.Run(() => Sum(CancellationToken.None, 10000)); // Создание объекта Task с отложенным запуском
		Task cwt = t.ContinueWith(task => Console.WriteLine( // Метод ContinueWith возвращает объект Task, но обычно // он не используется
		"The sum is: " + task.Result));
	Теперь, как только задание, выполняющее метод Sum, завершится, оно инициирует выполнение следующего задания (также на основе потока из пула), которое выведет
результат. Исполняющий этот код поток не блокируется, ожидая завершения каждого из указанных заданий; он может в это время исполнять какой-то другой код
или, если это поток из пула, вернуться в пул для решения других задач. Обратите внимание, что выполняющее метод Sum задание может завершиться до вызова метода ContinueWith. 
Впрочем, это не проблема, так как метод ContinueWith заметит завершение задания Sum и немедленно начнет выполнение задания, отвечающего за вывод результата.
	Также следует обратить внимание на то, что метод ContinueWith возвращает ссылку на новый объект Task (в моем коде она помещена в переменную cwt). При
помощи этого объекта можно вызывать различные члены (например, метод Wait, Result или даже ContinueWith), но обычно он просто игнорируется, а ссылка на
него не сохраняется в переменной.
	Следует также упомянуть, что во внутренней реализации объект Task содержит коллекцию ContinueWith. Это дает возможность несколько раз вызвать метод
ContinueWith при помощи единственного объекта Task. Когда это задание завершится, все задания из коллекции ContinueWith окажутся в очереди в пуле потоков.
Кроме того, при вызове метода ContinueWith можно установить флаги перечисления TaskContinuationOptions. Первые шесть флагов — None, PreferFairness,
LongRunning, AttachedToParent, DenyChildAttach и HideScheduler — аналогичны флагам показанного ранее перечисления TaskCreationOptions. Вот как выглядит
тип TaskContinuationOptions:
		Дочерние задания
Как демонстрирует данный код, задания поддерживают в числе прочего и отношения предок-потомок:
		Task<Int32[]> parent = new Task<Int32[]>(() => {
			var results = new Int32[3]; // Создание массива для результатов
			// Создание и запуск 3 дочерних задани
			 return results;
		});
			varcwt = parent.ContinueWith( // Вывод результатов после завершения родительского и дочерних заданий
			parentTask => Array.ForEach(parentTask.Result, Console.WriteLine));
			parent.Start(); // Запуск родительского задания, которое запускает дочерние
	Родительское задание создает и запускает три объекта Task. По умолчанию задания-потомки попадают на самый верхний уровень и не имеют отношения к своему предку. 
Однако при установке флага TaskCreationOptions.AttachedToParent родительское задание завершается только после завершения всех его потомков. Если при создании объекта Task 
методом ContinueWith установить флаг TaskContinuationOptions.AttachedToParent, то задание, запускаемое после завершения предыдущего, станет его потомком		



			Фабрики заданий
		Parallel
	Планировщики заданий TaskScheduler. Экземпляр TaskScheduler класса представляет планировщик задач и гарантирует, что
работа над задачей в итоге будет выполнена который обеспечивает перехват работы для балансировки нагрузки, вставку/удаление потока
для максимальной пропускной способности и общее повышение производительности.
	8. Класс Parallel и методы For, ForEach и Invoke, класс позволяет распределить работу между несколькими потоками из пула.
Все методы класса Parallel заставляют вызывающий поток принимать участие в их обработке, вызывающий поток не блокируется, ожидая
выполнения работы потоками пула. Выполнение вызывающего потока не возобновляется, покане будет завершена вся работа. Если одна из
операций станет источником необработанного исключения, вызванный вами метод Parallel выдаст исключение AggregateException.
Результат работы цикла можно определить при помощи свойств. Если свойство IsCompleted возвращает значение true, значит, цикл
пройден полностью, и все элементы обработаны.
			Управление рабочими потоками

Асинхронные функции C#
Асинхронные операции являются ключом к созданию высокопроизводительных
масштабируемых приложений, выполняющих множество операций при помощи
небольшого количества потоков. Вместе с пулом потоков они дают возможность
эффективно задействовать все процессоры в системе. Осознавая этот огромный
потенциал, разработчики CLR разработали модель программирования, призванную
сделать его доступным для всех программистов1
. Эта модель использует объекты Task (см. главу 27) и асинхронные функции языка C#. В следующем примере кода
асинхронные функции используются для выполнения двух асинхронных операций.









						Глава 28. Асинхронные операции ввода-вывода
						Глава 29. Примитивные конструкции синхронизации потоков
						Глава 30. Гибридные конструкции синхронизации потоков
						
						
						
						
						
						
						
						
						
						
						
						
						
						
						


















	
						