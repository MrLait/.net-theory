- CLR
	- Managed module
	- IL-код
	- Метаданные
	- manifest
	- assembly
	- unsafe
	- Глобальный кэш сборок
- Библиотека FCL
	- CTS
	- CLI
	- CLS
- System.Object. Что такое объект и класс?
- Что делает оператор new?
- Namespace. alias
- Приведение типов
	- Операторы is и as, typeof
	- checked и unchecked
	- Оператор yield
	- Parse, TryParse, Convert
- Примитивные типы
	- Примитивный тип данных dynamic
	- Ссылочные типы
	- Значимые типы. Жизненный цикл Value-type объекта
	- Упаковка и распаковка значимых типов
- Константы
	- Поля
	- Свойства
		- Свойства с параметрами
	- Конструкторы
		- Конструкторы экземпляров:
		- Статические конструкторы, конструкторы классов, типов или инициализаторы типов.
		- Конструкторы структур
	- Методы
		- Методы перегруженных операторов
		- Методы операторов преобразования
		- Методы расширения
		- Частичные методы
		- В чем разница между ключевыми словами virtual, override и new
	- События
	- Делегаты
		- Обобщенные делегаты
- Необязательные и именованные параметры
	- Неявно типизированные локальные переменные
	- Передача параметров в метод по ссылке
	- Передача переменного количества аргументов
	- Типы параметров и возвращаемых значений
- Инициализаторы объектов и коллекций
- Перечислимые типы
	- Битовые флаги
	- Анонимные типы
		- Тип System.Tuple и ValueTuple
	- Null-совместимые значимые типы
		- Упаковка null-совместимых значимых типов 
		- Распаковка null-совместимых значимых типов
	- Тип record
- Обобщения, преимущества обобщений
	- Верификация и ограничения
	- Основные ограничения
	- Дополнительные ограничения
	- Ограничения конструктора
- Наследование в классах
	- Модификаторы доступа
	- Наследование интерфейсов
	- Явные и неявные реализации интерфейсных методов
	- Обобщенные интерфейсы
- Абстрактный класс
- Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах
- Символы
	- Строки
	- StringBuilder
	- Форматирование нескольких объектов в одну строку
- Настраиваемые атрибуты
- Механика обработки исключений. try-catch-finally. throw ex vs throw.
	- Создание пользовательских исключений.
	- Корректное восстановление после исключения
	- Какая разница между методами Finalize и Dispose. Чем плох деструктор/финализатор и когда использовать IDisposable?
	- Сборщик мусора. Триггеры вызова. Что влияет на его скорость работы. Количество поколений. LOH. Как определить производительность GC. Что такое POH.
- Потоки и процессы. Их различия. Переключения контекста. background и foreground thread
	- Способы создания потоков.
	- Концепция асинхронности, TAP. Асинхронные методы. Какие операции лучше выполнять синхронно, а какие асинхронно.
	- Во что разворачивается компилятором конструкция await и Task?
	- CPU-bound и IO-Bound операции
	- Контекст синхронизации. ConfigureAwait(false) vs ConfigureAwait(true) vs без использования ConfigureAwait.
	- Что такое CancellationToken? Отмена асинхронных операций.
	- Виды синхронизации потоков. lock, Monitor
	- Конструкции режима ядра: Mutex, Semaphores и Events
	- Deadlock, livelock, starvation.
- Подробнее об операторе foreach
- Классы коллекций для параллельного доступа. Parallel LINQ. Класс Interlocked, атомарные операции
	- Класс Parallel. Parallel.Invoke, Parallel.For и Parallel.ForEach
	- Почему при CPU Bound лучше не использовать async-await, но можно использовать Parallel.For(), Task.Run()?
- Дилеммы разработчиков:
	- Базовый класс или интерфейс?
	- Абстрактный класс или интерфейс?
	- Статический класс или singleton
	- Событие или делегат
	- Лямбда или делегат
- Сложность алгоритма, О большое. Сравнение сложности, Пространственная сложность
- Интерфейсы структуры данных и их интерфейсы
	- IEnumerable, ICollection.
	- IEnumerable vs IQueryable
	- IList, ISet и IDictionary.
	- Concurrent Collections, Immutable Collections.
	- Массивы
		- Динамический массив List. List vs Array, Count vs Capacity.
	- Linked List. Преимущества и недостатки.
		- Двусвязный список, Кольцевой односвязный список, Кольцевой двусвязный список,
	- Stack, Queue, Dequeue, PriorityQueue
	- Binary Heap, Binary Search Tree, АВЛ-дерева, Обходы дерева, Балансировка узлов
	- Hashtable, Hashset, Хэш-функция, Dictionary, коллизия
	- SortedList, SortedSet, SortedDictionary
- Что такое LINQ. Как реализованы основные методы Linq под капотом. С какими коллекциями можно использовать Linq?
- Как работает сравнение типов через ReferenceEquals, Equals и == в Reference Type и Value Type через Equals.
	- Правила реализации метода Equals, оператора равенства (==) и IComparable. Пример реализации метода Equals(Object)
	- Сравнение с помощью вспомогательных классов и интерфейсов IComparable, IComparer, IEqualityComparer 
- Что такое ООП, принципы ООП. Инкапсуляция, наследование, абстракция и полиморфизм. Агрегация, композиция, ассоциация.
- Класс Stream, TextReader.
	- Сериализация и десериализация, зачем нужна Reflection
- Как реализовать singleton
- SOLID
	- IoC, DI, Способы получения зависимостей, IoC-контейнер, Преимущества DI 
	- Время жизни объектов во встроенном DI ASP.NET Core.
	- Можно ли из сервиса с одним временем жизни вызвать другой сервис с другим временем жизни?
	- Другие принципы: DRY, KISS, YAGNI, DAMP, AAA и GRASP.
- Формы нормализации таблиц, цель нормализации.
	- Связи таблиц.
- Реляционная база данных. Система управления базами данных
	- Нереляционные базы данных NoSQL, Key-value базы данных,	Документоориентированные БД.
	- Назовите преимущества и недостатки NoSQL
	- Структура реляционных баз данных.
	- SQL, Транзакции(ACID). Проблемы параллельного доступа с использованием транзакций.
	- Уровни изоляции транзакций. Optimistic and pessimistic lock.
	- Команды: COMMIT, ROLLBACK, SAVEPOINT, LOCK TABLE, SET TRANSACTION, SET SESSION CHARACTERISTICS
- Базовый синтаксис Select, оператор Select, AS, функции
	- Исключение дубликатов, DISTINCT, WHERE, NOT, XOR, IS NULL, IS NOT NULL, BETWEEN, IN, LIKE, ESCAPE-символ
	- Оператор ORDER BY, GROUP BY, Агрегатные функции, HAVING
	- Порядок выполнения SQL запроса
	- Виды многотабличных запросов JOIN. Внутреннее соединение INNER JOIN
		- Внешнее соединение OUTER JOIN, Внешнее левое соединение (LEFT OUTER JOIN)
		- Внешнее правое соединение (RIGHT OUTER JOIN)
		- Внешнее полное соединение (FULL OUTER JOIN)
	- Ограничение выборки, оператор LIMIT, TOP, OFFSET FETCH
	- Подзапросы. Подзапрос с одной строкой с одним столбцом
		- Подзапросы с несколькими строками и одним столбцом, оператор ALL, IN, ANY
		- Многостолбцовые подзапросы
		- Коррелированные подзапросы
	- Обобщённое табличное выражение, CTE, оператор WITH, Union [ALL], INTERSECT, EXCEPT
	- Основные различия между View и CTE:
	- Оператор CASE, функция IF, IFNULL, NULLIF
	- Операторы INSERT, UPDATE, DELETE и TRUNCATE.
	- Операторы для создания и удаления таблиц и баз данных: CREATE, SHOW и DROP. IF [NOT] EXIST, USE, DESCRIBE, CASCADE
- Масштабирование SQL баз данных. Репликация, подход master-slave, Шардинг, Вертикальный и Горизонтальный шардинг.
	- Основы индексов в SQL Server
		- Кучи, Кластеризованный и Некластеризованный индекс. Составной индекс, Уникальный индекс, Покрывающий индекс.
	- Оконная функция в SQL (OVER)
- Что такое ORM? В чем преимущества ORM? В чем недостатки ORM и когда ее лучше не использовать?
	- В чем разница между Eager loading, Lazy Loading в EF и explicit loading?
	- Какие компоненты архитектуры Entity Framework вы знаете?
		- Entity Framework Context Class. What is an Entity in the Entity Framework? Types of navigation properties.
		- Entity States in Entity Framework
		- Development Approach with Entity Framework. Automated Database Migration in Entity Framework Code-First Approach
		- Inheritance and Entity type hierarchy mapping
		- Default transaction behavior, Savepoints, external DbTransactions? Как выполнить транзакцию для нескольких контекстов
- Messaging. Что такое AMQP? Queue vs Topic, Exchanges и его типы. и другие внутренности - вопрос не закрыт.
	- Что такое Azure Service Bus, в чем разница между Service Bus и обычной Queue? ReceiveAndDelete и PeekLock
	- В чем отличие Kafka от Service Bus или другого брокера сообщений? - без ответа
- Микросервисы. Способы коммуникации между микросервисами.​ Saga, eventual consistency. Two-Phase Commit. 	
	- Какие паттерны для микросервисов вы знаете? Как обеспечить security микросервисов? Какие способы хостинга
- Какие Test Frameworks вы знаете и использовали на практике? - нет ответа
	- Какие вспомогательные библиотеки вы знаете и использовали для написания тестов? - нет ответа
	- В чем разница между Integration и Unit тестами?
	- В чем разница между Dummy, Fake, Stubs, Spies, Mocks объектами?
- Сетевое взаимодействие и протоколы
	- Что происходит, когда пользователь вбивает в браузер адрес google.com
	- Протоколы: HTTP, HTTP/2, HTTPS. Структура HTTP-сообщения, Структура URL-адреса, URI, Абсолютные и относительные URL
	- Методы HTTP-запросов и статус коды.
	- WebSockets, особенности и основные Web Socket API events?
	- Что такое Short polling и Long polling?
	- Что такое HATEOAS, в чем его основная идея и преимущества?
	- CORS
	- HTTP cache. Private cache. Public cache/Shared cache. ETag. Как использовать HTTP-based кэш для Action в ASP.NET Core?
- REST. Какие требование к RESTful сервису? Richardson Maturity Model (RMM)
	- Какие реализации RPC протокола вы знаете? gRPC, JSON-RPC. RPC API vs REST API.
- Аутентификации и Авторизации, OAuth2 и Roles, OpenID Connect, IdentityServer, виды токенов.
	- Что такое JWT token? Из каких частей состоит? Зачем нужен Рефреш токен? Как инвалидировать JWT токен в ASP.NET?
- Какие веб серверы поддерживает ASP.NET Core по умолчанию? IIS, HTTP.sys, Kestrel. Kestrel vs. HTTP.sys
- ASP.NET Core. Что такое middleware в ASP.NET Core? Создание и добавление в pipeline.
	- Run, Use, Next, Map. В чем разница между app.Use и app.Run при добавлении middleware?
	- Типы middleware.
	- Что такое Attribute routing в ASP.NET Core?
	- В чем разница между ConfigureServices и Configure в ASP.NET Core? Что такое wwwroot?
	- Как написать интеграционный тест в ASP.NET Core?
	- Какие типы фильтров существуют в ASP.NET Core? Чуть подробнее нун.
	- В чем разница между Continuously Integration, Continuous delivery и Continuous deployment
	- Clean architecture
- Типы паттернов. Какие архитектурные паттерны вы знаете?
	- Примеры и реализации паттернов поведения.
	- Примеры и реализации порождающих паттернов.
	- Примеры и реализации структурных паттернов.
Регулярные выражения:
\(#[^\)]+\) - удалить все, что после (#
\[(.*?)	- первую [
\]		- вторую ]

#		CLR
	Common Language Runtime, CLR — общеязыковая среда выполнения — это среда выполнения, которая подходит для разных языков 
программирования. 
	Исходный код программы может быть написан на любом языке, поддерживающем среду выполнения CLR. Затем соответствующий
компилятор проверяет синтаксис и анализирует исходный код программы. Результатом компиляции будет являться managed module. 
Помимо управляемого модуля компилятор генерирует IL-код и метаданные. 

##		Managed module
	Управляемый модуль (portable executable, PE) — стандартный переносимый исполняемый файл 32-разрядной или 64-разрядной Windows,
требует для своего выполнения CLR и является результатом компиляции исходного кода. 
	Управляемый модуль состоит: 
	- Заголовок PE32/PE32+  - содержит версию разрядности Windows в которой может исполнятся этот модуль, а также, тип файла,
временную метку, когда файл был собран. 
	- Заголовок CLR - заголовок включает нужную версию CLR, флаги, метку метаданных MethodDef - точки входа в управляемый модуль,
а также месторасположение, размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр;
	- Метаданные - это таблицы, описывающие типы данных и их члены, определенные в исходном коде и на которые имеются ссылки 
в исходном коде. Существуют три категории таблиц: определений, ссылок и манифестов.
	- Код Intermediate Language (IL) - код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует 
IL в машинные команды.
		
## 		IL-код
	IL-код - это код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды.
IL — язык более высокого уровня по сравнению с большинством других машинных языков. Он позволяет работать с объектами и имеет 
команды для создания и инициализации объектов, вызова виртуальных методов и непосредственного манипулирования элементами 
массивов, а так же нем есть команды инициирования и перехвата исключений для обработки ошибок.

##		Метаданные
	Метаданные — это набор таблиц данных, описывающих то, что определено в управляемом модуле, например типы и их члены. 
В метаданных также есть таблицы, указывающие, на что ссылается управляемый модуль, например на импортируемые типы и их члены, 
которые всегда связаны с файлом, содержащим IL-код. Благодаря тому что компилятор генерирует метаданные и код одновременно и 
привязывает их к конечному управляемому модулю, возможность рассинхронизации метаданных и описываемого ими IL-кода исключена.
	 Например функция среды Visual Studio IntelliSense анализирует метаданные и сообщает, какие методы, свойства, события и поля 
предпочтительны в данном случае и какие именно параметры требуются конкретным методам.
	Метаданные позволяют сериализовать поля объекта, а затем провести процесс десериализации, восстановив объект и его 
состояние на удаленном компьютере.
	Метаданные позволяют сборщику мусора отслеживать жизненный цикл объектов. При помощи метаданных сборщик мусора может 
определить тип объектов и узнать, какие именно поля в них ссылаются на другие объекты
	Существуют три категории таблиц: определений, ссылок и манифестов. 

##		manifest
	Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном содержат имена файлов, которые входят в сборку.
Кроме того, эти таблицы описывают версию и региональные стандарты сборки: ее издателя, общедоступные экспортируемые типы, а также
все составляющие сборку файлы.

##		assembly
	Сборка (assembly)- это совокупность одного или нескольких файлов, которые представляет собой исполняемое приложение, либо 
библиотеку DLL, содержащую набор типов, а один из файлов сборки выбирается для хранения ее манифеста, который представляет собой,
набор таблиц метаданных, содержащих в основном имена файлов. 
	Сборка обеспечивает логическую группировку одного или нескольких управляемых модулей или файлов, поддерживающая многократное
использование, безопасность и управление версиями.
	Модули сборки также содержат сведения о других сборках, на которые они ссылаются. Это позволяет среде CLR определить все 
прямые зависимости данной сборки, необходимые для ее выполнения.
	
##		unsafe
	По умолчанию компилятор C# компании Microsoft генерирует безопасный код - это код безопасность которого подтверждается в 
процессе верификации. Небезопасный код - это код, способный напрямую работать с адресами памяти и манипулировать с байтами по 
этим адресам. Соответственно использование небезопасного кода создает значительный риск: он может повредить структуры данных и 
использовать или создавать уязвимости в системе безопасности. По этой причине компилятор C# требует, чтобы все методы, содержащие
небезопасный код, помечались ключевым словом unsafe, а при компиляции исходного кода использовался параметр компилятора /unsafe.

##		Глобальный кэш сборок
	Место, где располагаются совместно используемые сборки, называют глобальным кэшем сборок (global assembly cache, GAC).
	Зачем «регистрировать» сборку в каталоге GAC? Например две компании сделали свою сборку OurLibrary, состоящую из файла с 
одинаковыи именем и поскольку файл, копируемый последним, перезапишет первый и тем самым нарушит работу какого-нибудь приложения,
чтобы не допустить этого для установки в GAC можно использовать специальный инструмент, который создаст отдельные папки для каждой
из этих сборок и скопирует каждую сборку в свою папку.

#		Библиотека FCL
	FCL (Framework Class Library) - является одним из компонентов .NET Framework, который содержит набор сборок в формате DLL, 
содержащих несколько тысяч определений типов. Так как FCL содержит буквально тысячи типов, взаимосвязанные типы объединяются в 
одно пространство имен.
		
##		CTS
	CTS (Common Type System) спецификация, которая описывает способ определения и поведение типов, например, тип может содержать 
ноль и более членов. Иметь, поля, методы, модификаторы доступа, а также определяет правила, управляющие наследованием, работой
виртуальных методов, сроком жизни объектов и т.д. Компания Microsoft предоставляет CTS вместе с другими частями .NET Framework в 
оргкомитете ECMA с целью стандартизации. Стандарт называется CLI (Common Language Infrastructure) и определяется 
спецификацией ECMA-335.

##		CLI
	CLI (Common Language Infrastructure) - общеязыковая инфраструктура, а в документ ECMA-335 содержится спецификация общеязыковой
инфраструктуры (CLI). Короче говоря CLI - это спецификация, а CLR - реализация этой спецификации.
	
##		CLS
	CLS (Common Language Specification) - это спецификация, в котрой перечислен набор правил, которым должны соответствовать типы
и методы, для того чтобы они могли использоваться в любом CLS-совместимом языке на базе CLR.

#		System.Object. Что такое объект и класс?
В CLR каждый объект прямо или косвенно является производным от System.Object. Благодаря тому, что все типы, в конечном счете, 
являются производными от System.Object, любой объект любого типа гарантированно имеет минимальный набор методов.
 - Equals - возвращает true, если два объекта имеют одинаковые значения. 
 - GetHashCode - возвращает хеш-код для значения данного объекта. 
 - ToString - по умолчанию возвращает полное имя типа, но можно переопределить, чтобы он возвращал объект String, содержащий 
состояние объекта в виде строки. 
 - GetType - позволяет получить тип данного объекта. Может использоваться с классами, реализующими отражение для получения 
информации о типе в виде метаданных. Является невиртуальным, его нельзя переопределить.
 - MemberwiseClone этот невиртуальный метод выполняет неглубокое клонирование Object. Возвращается ссылка на созданный
экземпляр, у которого значимые типы будут своими, а ссылочные общие.
 - Finalize - этот виртуальный метод вызывается автоматически уборщиком мусора. В типах работающих с неуправляемыми ресурсами, 
следует переопределить этот метод. 
 - ReferenceEquals - Определяет, совпадают ли указанные экземпляры Object. В отличие от Equals, сравнивает объекты по ссылке, 
а не значению. И являются статическими, принимая два объекта для сравнения.
	Что такое объект и класс?
	Объект - это экземпляр класса имеющий поведение и состояние определенное классом. 
	
#		Что делает оператор new?
	Все объекты создаются при помощи оператора new, который вычисляет количества байт, необходимых для хранения всех 
экземплярных полей типа и всех его базовых типов.
	Для каждого объекта в куче добавляет дополнительные члены: указатель на объект (type object pointer) и индекс блока 
синхронизации (sync block index). Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого объекта
	Выделяет и резервирует необходимое количество памяти в управляемой куче. Выделенные байты инициализируются нулями (0).
	Инициализация указателя на объект-тип и индекса блока синхронизации.
	Вызов конструктора экземпляра типа с параметрами, указанными при вызове new, а так же вызывается конструктор System.Object, 
который ничего не делает, а просто возвращает управление.
	В итоге new возвращает ссылку на вновь созданный объект.

#		Namespace. alias
	Пространства имен используются для логической группировки родственных типов, чтобы разработчику было проще найти нужный тип, а
также средство, позволяющее удлинить имя типа и сделать его уникальным, добавив к началу имени групп символов, разделенных точками
	alias - В C# есть еще одна форма директивы using, позволяющая создать псевдоним для отдельного типа или пространства имен. 

#		Приведение типов
	Приведение типов - это механизм, при помощи которого мы можем преобразовать один тип в другой. C# поддерживает несколько 
видов приведения типов такие как:
	Неявные преобразования - в этом случае специального синтаксиса не требуется, например, преобразования из меньших в большие 
целочисленные типы, или	Upcasting - преобразования из производных классов в базовые классы.
	Явные привидение - если в ходе привидения данные могут быть утрачены или завершиться сбоем. Downcasting - для приведения типа к
производному от него типу. Для явных преобразований требуется выражение приведения такие как is, as, typeof или (T).
	Object o = new Employee();
	Employee e = (Employee) o;
	Пользовательские преобразования такие как методы операторов преобразования для этого используются ключевые слова operator и
implicit или explicit. 
	Преобразования с использованием вспомогательных классов, таких как BitConverter, Convert, Parse, TryParse.
	
##		Операторы is и as, typeof
	Оператор is проверяет совместимость объекта с данным типом и возвращает true или false и никогда не генерирует исключение. 
Для null-ссылок оператор is всегда возвращает false, так как объекта, тип которого нужно проверить, не существует.
		if (o is Employee) { Employee e = (Employee) o;	}
	Но C# предложен механизм, повышающий эффективность кода с помощью оператора as. 
		Employee e = o as Employee; 
		if (e != null) { // Используем e внутри инструкции if}
	as возвращает ненулевой указатель на этот объект, а если нет, то оператор as возвращает null. При этом верифицирует тип 
объекта только один раз, а if лишь сравнивает e с null — такая проверка намного эффективнее, чем определение типа объекта. 
	Оператор typeof получает экземпляр System.Type для указанного типа. Оператор typeof принимает в качестве аргумента: 
имя типа или параметр типа: typeof(T), typeof(List<string>), typeof(int). Type myType = typeof(Person); 
Аргумент может быть типом dynamic или string?

##		checked и unchecked
	checked и unchecked - механизм управления проверки переполнения, при выполнение арифметических операции над примитивными типами
	checked - если требуется указать, что выражение будет проверяться на переполнение. Выдастся исключение OverflowException.
	unchecked - если требуется проигнорировать переполнение. В этом случае результат усекается, чтобы не выйти за пределы 
диапазона представления чисел для целевого типа выражения.

##		Оператор yield
	Оператор yield является итератором, который используется для перебора набора значений. Он возвращает один элемент и запоминает
текущую позицию. Например, с помощью оператора yield return можно реализовать метод GetEnumerator(), а используя цикл foreach
перебрать объект как коллекцию, при получении каждого элемента в цикле foreach, будет срабатывать оператор yield return.
	Конструкция yield break позволяет остановить генератор насовсем, а вызов MoveNext вернёт false.

##		Parse, TryParse, Convert
	Все примитивные типы имеют два метода, которые позволяют преобразовать строку к другому примитивному типу.
	Метод T.Parse("") в качестве параметра принимает строку и возвращает объект текущего типа. Например:
		int a = int.Parse("10");
		double b = double.Parse("23,56");
	Метод T.TryParse("", out var number) попытается преобразовать строку к типу и возвращает Bool, и out-параметр, а также не 
порождает исключений:
		bool result = int.TryParse(input, out var number);
	Метод Convert.ToX(<T>) в качестве параметра принимает различные примитивные типы, необязательно строки и порождает исключение
FormatException в случае неудачного преобразования.
	Формат статических методов: To(примитивный тип), например, ToBoolean(value) или ToByte(value).
		int n = Convert.ToInt32("23");
		bool b = true;	double d = Convert.ToDouble(b);

#		Примитивные типы
	Типы данных, которые поддерживаются компилятором напрямую, у которых существуют прямые аналоги в библиотеке классов FCL. 
Например, int - System.Int32.(s)byte, (u)short, (u)int, (u)long, float, double, decimal, bool, char, string, object, dynamic.
	Можно неявное делать приведение типа, если не будет потери данных, но если есть вероятность потери данных, то требуется 
явного приведения типа. Например из Int32 в Byte так как при больших величинах Int32 теряется точность.	

##		Примитивный тип данных dynamic
	Тип данных dynamic позволяет опустить проверку типов во время компиляции. Кроме того, объекты, объявленные как dynamic, могут
в течение работы программы менять свой тип.	Компилятор конвертирует тип dynamic в Object и применяет DynamicAttribute к различным
частям метаданных, где это необходимо. 
	Компилятор не позволит неявно присвоить тип Object к другому типу, нужно использовать явное приведение типов, но типом 
dynamic можно неявно привести к другому типу, только в таком случае CLR на этапе выполнения проверит правильность приведения с 
целью обеспечения безопасности типов. Если тип объекта несовместим с приведением, CLR выдает исключение InvalidCastException.
	Любое выражение может быть явно приведено к типу dynamic.
	dynamic можно использовать для определения аргументов типов обобщенных классов, структур, интерфейсов, делегатов или методов. 

##		Ссылочные типы
	Ссылочные типы это типы, которые в переменных хранят ссылки на их объекты, которые хранятся в управляемой куче, а оператор new
возвращает адрес в памяти, где размещается сам объект. 	
	Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому операции над одной переменной могут 
затрагивать другую переменную. 
	Дополнительные члены, подлежат инициализации, незанятые полезной информацией обнуляются.
	Со временем ссылочный тип инициирует сборку мусора.	
	Ссылочные типы:	class, interface, delegate, record, dynamic, object, string.
				
##		Значимые типы. Жизненный цикл Value-type объекта
	Значимые типы могут относиться к структурам (structure) и перечислениями (enumeration). Тип структуры, инкапсулирует данные 
и связанные функции, тип перечисления, определяется набором именованных констант. Структуры являются потомками абстрактного типа 
ValueType=>Object, перечисления типа Enum => ValueType => Object.
	Экземпляры значимых типов обычно размещаются в стеке потока, но могут быть встроены и в объект ссылочного типа. 
	Поля экземпляра размещаются в самой переменной, соответственно нет указателя на экземпляр.
	Экземпляры значимых типов не обрабатываются уборщиком мусора, что ускоряет работу приложения.
	Значимый тип является изолированным - он не может наследоваться, соответственно его методы не могут быть абстрактными и неявно
являются запечатанными, то есть их нельзя переопределить. Нельзя создавать в значимом типе новые виртуальные методы, но можно 
вызывать унаследованные виртуальные методы такие, как Equals, GetHashCode или ToString.
	Значимый тип может реализовывать интерфейсы.
	При инициализации всем членам этого типа присваивается 0. 	
	При обращении к значимому типу не может возникнуть исключение NullReferenceException.
	При присвоении переменной значимого типа присваивается другая переменная значимого типа, выполняется копирование всех ее полей.
	Каждая переменная значимого типа имеет собственную копию данных «объекта», поэтому операции с одной переменной значимого типа
не влияют на другую переменную.
	Объекты значимого типа существуют в двух формах : неупакованной (unboxed) и упакованной (boxed) т.к. неупакованные значимые
типы не размещаются в куче, отведенная для них память освобождается сразу при возвращении управления методом, в котором описан 
экземпляр этого типа (в отличие от ожидания уборки мусора).
	Приведение неупакованного значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как
интерфейсные переменные являются ссылочными, а также упаковывается, при вызове реализаций методов из базового типа, таких как 
GetType или MemberwiseClone всегда требует упаковки значимого типа.

##		Упаковка и распаковка значимых типов
	Упаковка (boxing) - служит для преобразования значимого типа в ссылочный. Для этого в управляемой куче выделяется память. Ее 
объем определяется длиной значимого типа и двумя дополнительными членами — указателем на объект и индексом блока синхронизации. 
Поля значимого типа копируются в выделенную кучу и возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть
значимый тип превращается в ссылочный.
	Распаковка (unboxing) - копирование полей из упакованного объекта, который находится в куче в неупакованный объект, который 
находится в стеке потока. Для этого сначала извлекается адрес полей упакованного объекта, а далее копирование этих полей из кучи в
экземпляр значимого типа, находящегося в стеке. Распаковка менее ресурсозатратна, чем упаковка.
	Если переменная содержит ссылку на упакованный значимый тип равный null, то генерируется исключение NullReferenceException.
	Если ссылка указывает на объект, который не является упакованным типом требуемого значимого типа, то генерируется
исключение InvalidCastException.

#		Константы
	Константа является неявно статическим членом типа, значение, которой никогда не меняется, и определяться во время компиляции,
а хранится в метаданных модуля.
	Используется для упрощения чтения и сопровождения кода.
	Можно определять только примитивных типов или если присвоить ей значение null.
Константу следует использовать, только когда точно известно, что ее значение никогда не изменится, а иначе лучше использовать поля

##		Поля
	Поле (field) — это член типа, который хранит экземпляр значимого типа или ссылку на ссылочный тип.
	Поля могут быть для чтения и записи (изменяемые), или только для чтения (неизменяемые).
	Неизменность поля ссылочного типа означает неизменность ссылки, которую этот тип содержит, а вовсе не объекта, на которую 
указывает ссылка, например в массиве можно менять значения элементам.
									Модификаторы применимые к полям: 
	экземплярный Static readonly							volatile 
					   	запись в поле разрешается 			Код, обращающийся к полю, не должен оптимизироваться компилятором, 
					   	только из кода конструктора.		CLR или оборудованием с целью обеспечения безопасности потоков. 

##		Свойства
	Свойства - это член класса, который позволяет получить или установить состояние полей объекта класса.
	Свойства могут помечаться модификатором доступа и определяться в интерфейсах.
	Свойства могут быть статические, экземплярные, абстрактные и виртуальные. 
	Свойства должны иметь имя и тип, но не void.
	Не могут быть обобщенными.
	Нельзя перегружать, то есть определять несколько свойств с одинаковыми именами, но разным типом. 
	Свойства нельзя передавать в метод в качестве параметров с ключевым словом out или ref.
	set, определяет, что свойство, доступное только для записи.
	get, определяет, что свойство, доступное только для чтения.
	Свойства могут быть доступны только для чтения/записи, в то время как поля всегда доступны и для чтения, и для записи. 
	Свойство, являясь по сути методом, может выдавать исключения, а при обращениям к полям исключений не бывает.

###		Свойства с параметрами
	Индексаторы аналогичны свойствам, но позволяют обращаться к объекту как к массиву, передавая индексы в квадратных скобках, 
где индекс - это некоторое значение, используемое для доступа к элементу. Индексаторы позволяют удобно обращаться к элементам 
коллекций, массивов и других структур данных.
	Для объявления индексаторов вместо имени используется ключевое слово this, за которым следуют параметры в квадратных скобках.
		private string[] strings = new string[10];
			public string this[int index]
			{
				get { return strings[index]; }
				set { strings[index] = value; }
			}
	Для обращения к индексатору используется имя переменной и квадратные скобки, как с массивом. Аргументы индексатора необходимо
поместить в квадратные скобки: var item = someObject["key"]; someObject["SecondKey"] = item;
	У индексатора должен быть хотя бы один или более параметров. Соответственно методы доступа get получают один или несколько 
параметров,	типы параметров и тип возвращаемого значения может быть любым, но не void.
	В типе можно определять несколько индексаторов при условии, что они получают разные наборы параметров.
	Тип может поддерживать множество перегруженных индексаторов при условии, что их сигнатуры различны включая методов доступа.

##		Конструкторы
	Конструктор — это метод, у которого не задан тип возвращаемого значения, а сигнатура совпадает с именем типа, и служит для 
инициализации экземпляра типа и его полей.
	Конструкторы бывают двух типов: конструктор по умолчанию(без параметров), и конструктор с параметрами.
	Конструкторы могут быть экземпляров, статические и структур.
	
	Конструктор по умолчанию (default constructor) в C# - это конструктор, который создается автоматически компилятором, если 
в классе не определен ни один конструктор.

###		Конструкторы экземпляров:
	Любые поля, не инициализированные конструктором явно, будут содержат 0 или null.
	Можно перегружать конструкторы, но количество параметров или их тип должны отличаться.
	this - позволяет явно вызвать один конструктор через другой, а base - позволяет вызывать конструктор из базового типа.
	Нельзя наследовать соответственно нельзя применять модификаторы virtual, override, new, sealed и abstract, async, unsafe 
	Если определить класс без явно заданных конструкторов, то будет создан конструктор по умолчанию, реализация которого просто 
вызовет конструктор без параметров базового класса, но если в базовом классе нет конструктора без параметров, производный класс 
должен явно вызвать конструктор базового класса base(), иначе компилятор вернет ошибку. 
	При вызове конструктора класса сначала выполняются конструкторы базовых классов и только затем конструкторы производных.
	В конечном счете всегда вызывается открытый конструктор объекта System.Object без параметров, который просто возвращает 
управление т.е в System.Object не определено никаких экземплярных полей.
	
###		Статические конструкторы, конструкторы классов, типов или инициализаторы типов. 
	Статический конструктор - это конструктор, который не имеет модификатора доступа, параметров, помечен ключевым словом static
и служат для инициализации состояния типа или действия, которое выполняется только один раз. Он вызывается автоматически перед
созданием первого экземпляра или ссылкой на какие-либо статические члены. 
	У статического типа конструктор по умолчанию не создается так же как у запечатанных или абстрактных.
	Из статического конструктора можно обращаться только к статическим членам типа.
	Статический конструктор может быть только в одном экземпляре в ссылочном и значимом типе. 
		
###		Конструкторы структур
	Конструкторы у значимого типа можно не определять, но тогда поля будут инициализированные значениями по умолчанию 0 или null.
	Конструктор значимого типа выполняется только при явном вызове.
	В версиях С# после 10+ можно создавать конструктор без параметров и инициализировать поля по умолчанию, а так же с 11 можно
инициализировать не все поля, но им будет присвоено значение по умолчанию.
	При помощи выражения with и синтаксиса инициализатора объектов, который используется для изменения полей, можно копировать
структуру или анонимный тип.
			
##		Методы
	Метод это член типа, который содержит набор инструкций. Сигнатура метода может иметь модификатор доступа, virtual и другие, 
тип возвращаемого значения, имя метода, а так же передаваемые параметры. Тип возвращаемого значения метода не является частью
сигнатуры метода в целях перегрузки метода, а только для делегата.
	Метод может быть экземплярным либо статическим, для вызова экземплярного нужно создать объект.
	Метод можно вызывать, используя позиционные(без указания имени), и именованные аргументы. Позиционные аргументы могут
следовать за именованными аргументами, только если именованные аргументы находятся на правильных позициях.
	Методы помеченные virtual, abstract можно переопределять в наследниках при помощи override, но new, скрывает реализацию
данного метода, свойства, статического поля или константы из базового класса.
	base.MethodName() - base позволяет вызывать метод из базового класса.
	При передаче параметров по значению изменение значимого типа в методе не повлияет на исходный объект, а изменения значения 
ссылочного повлияет, кроме изменения ссылки.
	При передаче параметров по ссылке используя ключевые слова ref, out, in используются, когда нужно изменить значение аргумента
в методе и сохранить это изменение после того, как управление вернется вызывающему методу, кроме in.
	Параметры метода поддерживают: params одномерный массив параметров, default(SomeType) необязательные параметры, new ValType(),
где ValType — это тип значения. Если метод содержит как обязательные, так и необязательные параметры, необязательные параметры
определяются в конце списка параметров после всех обязательных параметров.
	Возвращаемые значения: если указан тип возвращаемого значения, то метод может вернуть его при помощи return, а если тип void,
инструкцию return без значения по-прежнему можно использовать для завершения выполнения метода. Без ключевого слова return этот
метод будет останавливать выполнение при достижении конца блока кода.
	В некоторых случаях нужно, чтобы метод возвращал больше одного значения. Это можно легко сделать, используя типы кортежей и
литералы кортежа.
	Если метод передает массив в качестве аргумента и изменяет значение отдельных элементов, метод не требуется для возврата
массива т.к. C# передает все ссылочные типы по значению, а значением ссылки на массив является указатель на массив.
	Так же есть методы расширения, частичные методы, методы операторов преобразования, методы перегруженных операторов.
	Обобщенные методы: все методы, определенные в обобщенных типах, могут использовать их параметр-тип. Параметр-тип может
использоваться для параметров метода, возвращаемого значения и типа заданной внутри него локальной переменной, а так же метод
может иметь собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных.
Использование обобщенных типов с методами, получающими параметры out и ref, должны быть того же типа, что и параметр метода, чтобы
избежать возможного нарушения безопасности типов.
	Чисты функция - это функция, которая не изменяет внешние переменные, а принимает все зависимости через параметры т.е её
выходные данные зависят только от входных и она не имеет побочных эффектов 

###		Методы перегруженных операторов
	Методы перегруженных операторов представляют собой метод, который перегружает определенный оператор, но не все операторы можно
перегружать, например, sizeof, typeof или new и другие, а некоторые должны быть перегружены парами.
	Перегруженные операторные методы должны быть открытыми и статическими, но implicit или explicit не используется.
	Тип, хотя бы одного из параметров или возвращаемого значения должен совпадать с типом, в котором определен операторный метод.
	public sealed class Complex {
		public static Complex operator+(Complex c1, Complex c2) { ... }
	}
	
###		Методы операторов преобразования
	Метод операторов преобразования — методы, преобразующий объект одного типа(класса или структуры) в объект другого типа.
	Методы преобразования должен быть открытыми и статическими, далее указать implicit или explicit, при явном приведении типов.
	operator - сообщает компилятору, что данный метод представляет собой оператор преобразования.
	После ключевого слова operator указывается целевой тип, в который преобразуется объект, а в скобках — исходный тип объекта.
	Тип, хотя бы одного из параметров или возвращаемого значения должен совпадать с типом, в котором определен операторный метод.
		public sealed class Rational {
			public static implicit operator Rational(Int32 num) { Неявно создает Rational из Int32 и возвращает полученный объект
			return new Rational(num); }

###		Методы расширения
	Метод расширения - статический метод, который вызывается при помощи синтаксиса экземплярного метода и позволяет добавлять 
новые методы в уже существующие типы без создания нового производного класса, даже если эти типы были определены в сторонних 
библиотеках, которые мы не можем изменять.
	Метод расширения должен быть объявлен в статическом необобщенном классе. Он является статическим методом, который принимает 
в качестве первого параметра тип, который помечен ключевым словом this, которое указывает, что данный метод является методом 
расширения для указанного типа и только первый параметр может быть отмечен ключевым словом this.
	Методами расширениями можно расширять типы, интерфейсные типы, типов-делегатов(Action) и перечислимые типы.
	Для статических классов и структур создавать методы расширения нельзя.
	Во время поиска метода расширения компилятор просматривает все статические классы, определенные в области файла, и сканирует
их статические методы. Если существуют два и более методов расширения, должен применяться синтаксис статического метода с
указанием имени статического класса, чтобы точно сообщить компилятору, какой именно метод нужно вызвать.
	Существует потенциальная проблема с версиями. Если в будущем разработчики Microsoft добавят экземплярный метод к классу 
StringBuilder с тем же прототипом, который совпадает с прототипом метода расширения, то после компилляции программы, компилятор 
свяжет с программой экземплярный метод компании Microsoft вместо метода расширения 	
		public static class StringBuilderExtensions {
			public static Int32 IndexOf(this StringBuilder sb, Char value) {//код метода}}

###		Частичные методы
	Частичные методы (partial methods) - это методы, которые могут быть определены частично в одном месте и реализованы 
частично в другом месте. Ключевое слово partial говорит компилятору C#, что исходный код класса, структуры или интерфейса 
может располагаться в нескольких файлах. Компилятор объединяет все частичные файлы класса во время компиляции.
	Они используются в основном для разделения автоматического кода и кода, который должен быть написан вручную.
	Методы объявляются только внутри частичного класса или структуры.
	Объявление частичного метода и его реализующее объявление должны иметь идентичные сигнатуры.
	В новых версиях C# могут возвращать тип и иметь модификаторы доступа, но нельзя указать явно ключевое слово private. 
	Не могут иметь параметров out, но может иметь параметры, помеченные ключевым словом ref, а также универсальные параметры,
экземплярные, статические или unsafe.
	Если не существует реализующего объявления частичного метода, то нельзя создать делегат, ссылающегося на частичный метод. 

###		В чем разница между ключевыми словами virtual, override и new
	Виртуальный метод (virtual) – это метод, который может быть переопределен в классе-наследнике. Такой метод может иметь 
стандартную реализацию в базовом классе.
	Переопределение метода (override) – это изменение реализации метода, установленного как виртуальный (в классе наследнике
метод будет работать отлично от базового класса).
	Модификатор override расширяет метод virtual базового класса, а модификатор new скрывает доступный метод базового класса.
Разница проявляется в случае полиморфизма. Если вы работаете с экземпляром класса-наследника через его родительский класс,
то в случае, если вы будете вызывать переопределенный виртуальный метод (override), то будет вызвана его реализация из наследника,
а если перекрытый (new), то будет вызван метод базового класса.

##		События	
	События — это члены типа, который позволяет типу регистрировать и отменять регистрацию на событие, и поле-делегат для 
управления набором зарегистрированных методов и получения уведомлений на которые он подписался. Для объявления событие указываем
модификатор доступа, ключевое слово event, тип делегата, указывающий на прототип вызываемого метода, и имя.
	Событие не может возвращать значения и вызывается только из типа, можно объявить в интерфейсе, а так же всегда public. 
События позволяет типу отправлять уведомления статическим или экземплярным методам.
	Определение события состоит из двух частей: объявления делегата и создания события на основе этого делегата.
			public delegate void ClickEventHandler(object sender, EventArgs e); 		// Определяем делегат для события Click
			public event ClickEventHandler Click;    									// Определяем само событие Click
			protected virtual void OnClick() => Click?.Invoke(this, EventArgs.Empty);	// Метод, вызывающий событие Click
	События являются механизмом, где одни объекты создают события, а подписчики или обработчики событий подписываются на них и
выполняют соответствующие действия в ответ на возникновение событий. 
	Чтобы подписаться на событие, необходимо создать метод, который будет обрабатывать это событие, и затем добавить этот метод
в список обработчиков события. Для того, чтобы при возникновении события передать обработчику события дополнительную информацию
подписчикам, нужно в новом классе инкапсулировать набор данных, а в соответствии с соглашением этот тип должен наследоваться от
типа EventArgs, а имя типа должно заканчиваться словом EventArgs.
	Делегат в отличии от события - делегирует свою работу внешнему коду, вызывая методы других объектов, и может быть параметром
в методе или возвращаемым значением, а событие используются для уведомления об изменениях в объекте.

##		Делегаты
	 Делегат (delegates) - функциями обратного вызова, которая обеспечивает безопасность типов при выполнении обратного вызова
методов, а так же позволяют последовательно вызывать несколько методов.
	Делегаты могут вызывать статические и экземплярные методы.	
		internal delegate void Feedback(Int32 value);// Объявление делегата; 
	Делегаты определяются при помощи ключевого слова C# delegate, а оператор new создает экземпляр делегата.
	Сигнатура метода должна быть совместима с сигнатурой делегата - это означает что оба типа должны принимать один и тот же
аргумент и возвращать значение одного и того же типа.
	делегаты могут быть параметрами методов, а так же можно возвращать из методов.
	Класс делегата, определенный компилятором, содержит четыре метода: конструктор, а также методы Invoke, BeginInvoke и EndInvoke
	Делегаты можно определять как внутри класса (вложенные в другой класс), так и в глобальной области видимости. По сути, т.к 
делегаты являются классами, их можно определить в любом месте, где может быть определен класс.
	Класс MulticastDelegate является производным от класса Delegate, который, в свою очередь, наследует от класса System.Object.	
	Делегаты поддерживают ковариантность и контравариантность ссылочных типов при привязке метода к делегату. 			
	Обратный вызов нескольких методов (цепочки делегатов/групповые делегаты). Цепочкой (chaining) называется коллекция делегатов,
дающая возможность вызывать все методы, представленные этими делегатами. Для этого есть перегруженные версии операторов += и -= для
экземпляров делегатов. Эти операторы вызывают методы Delegate.Combine и Delegate.Remove соответственно.
	Если делегат возвращает некоторое значение, то возвращается значение последнего метода из цепочки, в качестве альтернативы
можно воспользоваться экземплярным методом GetInvocationList класса MulticastDelegate. Этот метод позволяет в явном виде вызвать
любой из делегатов в цепочке.
	Можно не определять делегат, а подставить реализацию делегата сразу в код, используя лямбда-выражение. Например:
		ThreadPool.QueueUserWorkItem( obj => Console.WriteLine(obj ), 5);
							
###		Обобщенные делегаты	
	При определении типа делегата с параметрами типа, компилятор задает методы класса делегата, а параметры типа применяются ко
всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.	(чет не понятно, но понятно)
	В .NET существует 17 делегатов Action и Func, от не имеющих аргументов вообще до имеющих 16 аргументов. Делегат Func, в отличии
от Action позволяют методу обратного вызова вернуть значение. Кроме них есть еще и Predicate, который принимает один параметр и 
возвращает значение типа bool.  Но, если нужно передать аргумент по ссылке, используя ключевые слова ref и out или передать
делегату переменное число параметров при помощи ключевого слова params, может потребоваться определение собственного делегата:
	delegate void Bar(ref Int32 z);
	Поддержка обобщенных делегатов в CLR позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом
безопасность типов. Более того, благодаря обобщенным делегатам экземпляры значимого типа могут передаваться методам обратного
вызова без упаковки. 

#		Необязательные и именованные параметры
	Необязательными параметрами являются параметры, которым присвоено значение по умолчанию, после необязательных параметров все
последующие параметры также должны быть необязательными. void M(string name, int age = 1, string company = "Undefined")
	Именованные параметры это параметры у которых указано имя параметра и через двоеточие его значение. ctor(company:"Microsoft")
	Значения по умолчанию указываются для параметров методов, конструкторов, индексаторов и делегатов. 
	Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами, кроме слова params, который должен
располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию.
	Либо если используются в правильном положении. Параметр находится в правильной позиции, но не имеет явно заданного имени.
		PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
	Ключевые слова default и new, можно использовать для параметров, чтобы проинициализировать их в первоначальное состояние.
	Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.

##		Неявно типизированные локальные переменные
	Неявно типизированные локальная переменная - переменная помеченная ключевым словом var. 
	Чтобы определить ее тип, компилятор смотрит на тип выражения с правой стороны от оператора присваивания (=).
	var name = "Jeff";

##		Передача параметров в метод по ссылке
	По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу
передается ссылка на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если
параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта,
а исходный экземпляр сохраняется неизменным
	Ключевые слова out, ref и in позволяет передавать параметры по ссылке, а не по значению. 
	Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод, но
вызванный метод должен записать в него значение, прежде чем вернуть управление. 
	Если параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод
может как читать, так и записывать значение параметра.
	Модификатор in указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение
параметра нельзя будет изменить.
	Использование ключевого слова out со значимыми типами повышает эффективность кода, так как предотвращает копирование
экземплярных полей значимого типа при вызовах методов.
	Со значимыми типами ключевые слова out и ref позволяют методу управлять единственным экземпляром значимого типа. 
	Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью. 
	В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, а вызванный код управляет этим
указателем. Т.е все изменения, выполняемые внутри метода, влияют на исходный объект, в отличии от случая передачи ссылочного типа
по значению можно менять только значения объект, но присвоение новой ссылки не повлияет на исходный объект.

##		Передача переменного количества аргументов
	Примененное ключевое слова params позволяет методу принимает одномерный массив значений и может быть помечен только последний
параметр метода. 
	Что бы метод принимающий произвольное количество параметров любого типа, для этого достаточно назначить тип params Object[]. 
	Вызов метода, принимающего переменное число аргументов, снижает производительность. Чтобы уменьшить негативное влияние этих
операций на производительность, лучше определить несколько перегруженных методов, в которые не используется ключевое слово params.
	static Int32 Add(params Int32[] values) {

##		Типы параметров и возвращаемых значений					
	Объявляя тип параметров метода, нужно указывать «минимальные» типы, предпочитая интерфейсы базовым классам используя интерфейс
IEnumerable<T> вместо сильного типа, List<T>. 
	В то же время, объявляя тип возвращаемого методом объекта, желательно выбирать самый сильный из доступных вариантов. 
		
#		Инициализаторы объектов и коллекций
	Инициализаторы объектов позволяют присваивать значения всем доступным полям и свойствам объекта во время создания без вызова
конструктора, за которым следуют строки операторов присваивания. 
		Employee e = new Employee() { Name = "Jeff", Age = 45 };			
	Реальная выгода от синтаксиса инициализатора объекта состоит в том, что он позволяет программировать в контексте выражения,
строя функции, которые улучшают читабельность кода.
		String s = new Employee() { Name = "Jeff", Age = 45 }.ToString().ToUpper();
	При инициализации коллекции можно передать несколько аргументов, для чего используется синтаксис с фигурными скобками:
		var table = new Dictionary<String, Int32> { { "Jeffrey", 1 }, { "Kristin", 2 }, { "Aida", 3 }, { "Grant", 4 }};

#		Перечислимые типы
	Перечислимым (enumerated type) называют тип, в котором описан набор пар, состоящих из символьных имен и значений т.е это 
обычная структура, внутри которой описан набор константных полей и одно экземплярное поле. Константные поля попадают в метаданные
сборки. Программу, где используются перечислимые типы, проще написать и понять, а у разработчиков возникает меньше проблем с ее 
сопровождением т.к программист видит осмысленные символьные имена, а не цифры. Перечислимые типы подвергаются строгой проверке 
типов. Например,компилятор сообщит об ошибке, если в качестве значения я попытаюсь передать методу тип Color.Orange, когда метод 
ожидает перечислимый тип Fruit (фрукт).	
	Перечислимые типы относятся к значимым типам и наследуется от типа Enum <= ValueType <= Object.  
	Перечислимого типа не может быть методов, свойств и событий, но методы можно имитировать при помощи методов расширения.
	При компиляции перечислимого типа компилятор C# превращает каждый идентификатор в константное поле типа.
	В основе любого перечисления лежит один из основных типов, например (s)byte, (u)short, int используется по умолчанию и (u)long
	Компилятор C# считает перечислимые типы примитивными, поэтому для операций с их экземплярами можно применять операторы	(==, 
!=, <, >, <=, >=, +, –, ^, &, |, ~, ++ и ––).
	Компилятор C# допускает приведение экземпляров одного перечислимого типа к другому. 
	Также поддерживается явное и неявное приведение к числовому типу.
	Имеющийся экземпляр перечислимого типа можно связать со строковым представлением — для этого следует вызвать ToString, 
унаследованный от System.Enum: 	public static Array GetValues(Type enumType) и 	public Array GetEnumValues(); 
	Этот метод вместе с методом ToString позволяет вывести все идентификаторы и числовые значения перечисления
				
##		Битовые флаги	
	Перечисления можно использовать для создании битовых флагов, благодаря этому экземпляр enum может иметь комбинацию значений
констант, определенных в списке. Для создания перечисления с битовым флагом нужно добавить атрибут [Flags] или [FlagsAttribute]
	Определяя перечислимый тип, битовыми флагами, каждому идентификатору следует явно присвоить числовое значение. 
	Стоит добавлять идентификатор None, значение которого определено как 0. 
	Константы должны быть степенями двойки - это гарантирует, что комбинации флагов не будут перекрываться.
	Если есть часто используемые комбинации флагов, то их можно добавить в перечисление.
	Стоит использовать только положительные константы, чтобы не вводить никого в заблуждение.
	Т.к константы должны содержать степень двойки, то можно задавать их несколькими способами: двоичными литералами, 
числовым литералом с операцией сдвига, десятичными числами и шестнадцатеричными.
	Для комбинирования, сброса и проверки флагов используются битовые операции.	Битовые маски широко используются в среде .Net,
в частности для указания привязки объектов к контейнерам и определения уровня доступа к файлам, это лишь малая часть из 
перечислений которые входят в состав .Net Framework.

##		Анонимные типы
	Анонимные тип - это тип который позволяют инкапсулировать свойства только для чтения в один объект без необходимости
определения нового типа.
	Анонимный тип определяется с помощью ключевого слова var, оператора new и инициализатором объектов.
	Свойства анонимного объекта доступны только для чтения, поскольку они не имеют сеттеров. А так же не могут быть переданы в 
качестве аргументов в обобщенных методах.
	Анонимные типы обычно используются в select предложении выражения запроса, для возврата наборов значений из методов или 
для передачи данных между методами в качестве аргументов.
		var o1 = new { Name = "Jeff", Year = 1964 };
	
###		Тип System.Tuple и ValueTuple
	Tuple - это обобщенный кортежный тип который наследуется от класса Object, который позволяет объединять набор значений 
разных типов в единый объект без создания явно определенной структуры или класса.
	Позволяют возвращать несколько значений из методов и передавать как параметр метода или просто для объединения нескольких 
значений в один объект, а так же удобно использовать в конструкторе для инициализации полей типа
	ValueTuple это значимый тип, а Tuple это ссылочный тип. Это означает, что при создании экземпляра Tuple происходит
выделение памяти на стеке, а не на куче и соответственно вызывается уборщик мусора. 
 	У ValueTuple его элементы могут иметь имена: 	var person = (Name: "John", Age: 30, City: "New York");
													var tuple = Tuple.Create(1, "Hello", true)
	ValueTuple использует поля, а не свойства.
	ValueTuple являются изменяемыми типами, а тип Tuple - неизменяемые.
	Кроме того, Tuple может содержать до 8 элементов
 	Tuple можно создавать с помощью указания явных типов, var, именованные кортежи или конструктор кортежей, а для обращения, 
к полям используем порядковый номер или имя, если оно было указано через двоеточие, а так же с помощью деконструкции:	
						var myTuple = (1, "Hello", true);
						int firstItem = myTuple.Item1; // получаем первый элемент (1)
						var (firstItem, secondItem, thirdItem) = myTuple; //деконструкция

##		Null-совместимые значимые типы
	Класс System.Nullable<T> - это структура, которая позволяет принимать значимым типам значение null, а ее экземпляры могут
размещаться в стеке потока. Часто используется в связке с БД, т.к переменные, которые она может возвращать, могут быть равны null.
Но следует учесть, что операции с Nullable типом выполняются медленнее аналогичных операций с другими значимыми типами.
	Структура Nullable<T> имеет два свойства: Value - возвращает значение объекта и HasValue: возвращает true или false, если
объект равен null. В качестве параметра T могут использоваться только структуры, а также использовать упрощенный синтаксис
воспользовавшись знаком вопроса: Int32? y = null;
	Можно выполнять преобразования и приведение экземпляров Nullable типов к другим типам.
	Можно применять операторы к экземплярам null-совместимых значимых типов. Но следует учитывать, что если в операции участвует
nullable-тип, то результатом также будет значение nullable-типа и если один из операндов равен null, то результатом операции
также будет null, а в операциях сравнения, если хотя бы один из операндов равен null, то возвращается false.: 
	int? x = 5;		int z = x + 7; - нельзя; int? w = x + 7; - можно; int d = x.Value + 7; - можно
	int? x = null;  int? w = x + 7; // w = null
	Можно использовать is с шаблоном типа, чтобы проверить и получить значение базового типа или свойство HasValue: int? a = 42;
	var str = (a is int valueOfA) ? $"a is {valueOfA}" : "a does not have a value";
	var str = (а.HasValue) ? $"a is {valueOfA}" : "a does not have a value";
	Можно использовать оператор объединения null-совместимых значений ?? и ??= Если левый операнд не равен null, оператор
возвращает его значение. В противном случае возвращается значение правого операнда

###		Упаковка null-совместимых значимых типов 
	Если в переменную типа Nullable<Int32> присвоено значение null, то для передачи этой переменной ссылочному типу, ее следует
упаковать и передать ссылку на упакованный тип Nullable<Int32>. При упаковке экземпляра Nullable<T> проверяется его равенство на
null, но в случае положительного результата вместо упаковки возвращается null. Но если присвоено значение отличное от null,
например 5, то тип Nullable<Int32> упаковывается в тип Int32 с аналогичным значением.

###		Распаковка null-совместимых значимых типов
	Упакованный значимый тип T распаковывается в T или в Nullable<T>. Если упакованный значимый тип равен null, то и при
выполннении распаковки в тип Nullable<T> присваивается значение null, а в T исключение NullReferenceException. 
	При вызове метода GetType для объекта типа Nullable<T> CLR возвращает тип T вместо Nullable<T>, а так же будет произведена 
упаковка. Поэтому для определения int или int? нужно использовать связку Nullable.GetUnderlyingType и оператор typeof
	bool IsNullable(Type type) => Nullable.GetUnderlyingType(typeof(int?)) != null;

##		Тип record
	Records представляют ссылочный тип или значимый, если это структура. Он позволяет типам, к которым применен, быть неизменяемыми,
но чтобы действительно сделать тип неизменяемым, свойства должны использовать модификатор init. А также у типа record по умолчанию
есть реализация сравнения по значению, методы GetHashCode и ToString, перегружены операторы == и !=, а с помощью оператора with
можно создать record на основе другого record: 
		var tom = new Person("Tom", 37);
		var sam = tom with { Name = "Sam" };
	Record поддерживает деконструкцию, которая позволяет раскладывает тип на кортеж значений, как в JS.
	Можно создать позиционный record - это короткая запись, которая автоматически создаст конструктор, деконструктор, но для
структур позиционные record являются изменяемыми, что бы свойства стали не изменяемыми нужно добавить readonly:
		public record Person(string Name, int Age); - это все!
		public readonly record struct Person(string Name, int Age); - теперь автоматически будет создаваться свойство с init

#		Обобщения, преимущества обобщений
	Обобщения — механизм, для многократного использования кода, а именно многократного использования алгоритмов. Разработчик
описывает алгоритм, но не указывает типы данных, с которыми тот работает, что позволяет применять алгоритм к объектам разных типов.
	Поддерживаются обобщенные: ссылочные и значимые типы, интерфейсы, делегаты, методы определенные в ссылочном, значимом и в
интерфейсе, а так же при наследовании.
	Параметр тип может использоваться в свойствах, индексаторах, событиях, конструкторах, деструкторах и операторных методах.
	При определении обобщенного типа или метода, переменные, указанные вместо типа T, называются параметрами типа type parameters.
T — это имя переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий тип данных. В
случае обобщенного типа или метода указанные типы данных называют аргументами-типами (type arguments).
	Преимущества обобщений:	
	Безопасность типов. Попытка использования несовместимого объекта приведет к ошибке на этапе компиляции или исключению во 
время выполнения. 
	Более простой и понятный код. Поскольку компилятор обеспечивает безопасность типов, в исходном тексте требуется меньше
операций приведения типов, а такой код проще писать и сопровождать.
	Повышение производительности. До появления обобщений приходилось следить, чтобы все челны типа были совместимы с типом Object,
но тогда значимые типы, приходилось упаковать, перед вызовом членов алгоритма, что приводит к процедурам уборки мусора.
	Поскольку обобщение можно использовать для работы с конкретным значимым типом, экземпляры значимого типа могут передаваться
по значению и CLR не нужно выполнять упаковку. Операции приведения типа также не нужны, поэтому CLR не нужно контролировать
безопасность типов при их преобразовании, что также ускоряет работу кода.

##		Верификация и ограничения
	Ограничение сужает перечень типов, которые можно передать в обобщенном аргументе, и расширяет возможности по работе с этими
типами. public static T Min<T>(T o1, T o2) where T : IComparable<T> 
	Маркер where сообщает компилятору, что указанный в T тип должен реализовывать обобщенный интерфейс IComparable того же типа(T)
Благодаря этому ограничению компилятор разрешает методу вызвать метод CompareTo т.к он определен в интерфейсе IComparable<T>.
	Ограничения можно применять к параметрам типа обобщенных типов и обобщенных методов. 
	При переопределении виртуального обобщенного метода в переопределяющем методе должно быть тоже число параметров-типов, которые
наследуют ограничения, заданные для них методом базового класса. Переопределяемый метод вообще не вправе задавать ограничения для
своих параметров-типов, а только может переименовывать параметры-типы. Аналогично, при реализации интерфейсного метода, причем эти 
параметры-типы наследуют ограничения, заданные для них методом интерфейса.
	Не поддерживается перегрузка по именам параметров типа или по именам ограничений, только по арности:
	internal sealed class AType {}
	internal sealed class AType<T> {}
	internal sealed class AType<T1, T2> {}
	К параметру-типу могут применяться следующие ограничения основное (primary), дополнительное (secondary) и/или ограничение 
конструктора (constructor constraint). 

##		Основные ограничения
	Основным ограничением может быть незапечатанный ссылочный тип, кроме Object, Array, ValueType и Void в новых версиях языка
можно использовать Enum, Delegate. Указывая ограничения ссылочного типа означает, мы говорим компилятору, что заданный аргумент-тип
будет относиться к типу, указанному в ограничении, либо к производному от него.
	По умолчанию, если ограничение не указано, то оно будет типа Objet, но явно задавать этот тип нельзя.
	В параметре-типе может быть только одно основное ограничения.  
	Так же существуют еще два особых основных ограничения: class и struct. сlass гарантирует, что указанный аргумент-тип является
ссылочным типом. К нему относятся все классы, интерфейсы, делегаты и массивы. struct гарантирует, что указанный аргумент-тип будет
иметь значимый тип. К нему относятся все значимые типы, и перечисления, кроме Nullable<T> т.к получилась бы рекурсия.
	
##		Дополнительные ограничения 
	К дополнительным ограничениям относятся ограничения интерфейсного типа. Данное ограничение гарантирует, что указанный 
аргумент-тип будет определять тип, реализующий этот интерфейс. Можно задать ноль и более интерфейсных ограничений, соответственно
тип передаваемого параметра должен реализовывать все интерфейсные ограничения и все основные ограничения, если они заданы.
	Существуют интерфейсные ограничения и ограничение параметра типа.
	Ограничением параметра типа (type parameter constraint). Позволяет задавать отношение между аргументами типа.
	public class SomeClass : ISomeInterface<MyClass>	// интерфейсные ограничения
	public class Example<T> where T : IComparable		//ограничение параметра типа
	Преимущество использования интерфейсного ограничения со значимым типом является: Избавляет от упаковки при передаче
экземпляров значимых типов, но, если тип аргумента объявить интерфейсом, то будет выполнена упаковка.

##		Ограничения конструктора
	Ограничение конструктора гарантирует компилятору, что указанный аргумент-тип будет иметь неабстрактный тип, имеющий открытый
конструктор без параметров.	Можно задать не более одного ограничения конструктора. 
	Нельзя задавать одновременно struct(значимых типов) и new(), т.к у любой структуры есть обязательный конструктор без
параметров и такая запись является избыточной.
		internal sealed class ConstructorConstraint<T> where T : new() {}
	
#		Наследование в классах
	Наследование - это механизм языка, который позволяет определить производный класс на основе существующего, а также наследовать
его данные и свойства, при этом у класса может только один прямой родитель, который предоставляет набор сигнатур и реализации его
методов, а новый класс может стать базовым для другого класса, и новый производный класс унаследует все сигнатуры методов и их
реализации. В С# каждый объект прямо или косвенно наследуется от Object, что позволяет наследовать его методы.
	Наследования классов — дает возможность подстановки экземпляров производного типа в любые контексты, в которых выступают 
экземпляры базового типа Upcasting.
	Производный класс может наследовать практически все члены базового типа, кроме конструкторов - их нужно определять для каждого
класса, а при помощи base() можно вызывать конструктор базового класса.
	Производные классы могут переопределять унаследованные члены, которые в базовом классе отмечены ключевым словом virtual, а 
если член базового класса, отмечен ключевым словом abstract, то он обязательно должен переопределяться в производном классе
	Наследование применяется только для классов и интерфейсов. Другие категории типов (структуры, делегаты и перечисления) не 
поддерживают наследование. Класс может наследовать ноль и более интерфейсов, через указание их имен, но должен реализовать все
унаследованные методы интерфейсов. Интерфейсы позволяет реализовать ограниченное множественное наследование.

##		Модификаторы доступа
	private являются видимыми только в производных классах, которые вложены в базовый класс.
	protected члены являются видимыми только в текущем и производных классах. Производный класс может располагаться в другой сборке.
	internal члены являются видимыми только для тех членов, которые находятся в той же сборке, что и базовый класс.
	protected internal: члены являются видимыми из того же класса, наследника и любой части программы в той же сборке. Он также 
доступен в производном классе, расположенном в другой сборке, только в том случае, если доступ осуществляется через переменную 
типа производного класса.
	private protected: компонент класса доступен из любого места в своем классе или в производных классах, которые определены в 
той же сборке.
Структуры не могут использовать модификаторы private protected, protected и protected internal, поскольку структуры не могут быть 
унаследованы.

##		Наследование интерфейсов
	Интерфейс представляет собой тип с набором сигнатур методов и не содержит их реализации до C#8 т.е с помощью интерфейса мы 
определяем поведение которое будет реализовано в каком-то конкретном классе. В интерфейсах можно определять статические поля, 
константы, свойства, события и индексаторы и методы (начиная с версии C# 8.0)
	При определении интерфейсного типа можно указать модификатор доступа по умолчанию internal и ключевое слово interface, а в 
соответствии с соглашением имена интерфейсных типов начинаются с прописной буквы I. 
	Интерфейс может наследовать другие интерфейсы, а наследующий интерфейс класс, должен реализовать все их методы.
	Помимо наследования интерфейсов классами, интерфейсы могут наследоваться от интерфейсов, при этом интерфейсы поддерживают 
множественное наследование.
	Аналогичным образом как и классы наследование от интерфейсов позволяет подставлять экземпляры типа, реализующего интерфейс, во
все контексты, где требуются экземпляры указанного интерфейсного типа, что позволяет создавать слабосвязанные и гибкие приложения,
например DI контейнер, MOCK-тестирование.
	CLR поддерживает обобщенные интерфейсы и интерфейсные методы.
	Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался модификатором public. 
	По умолчанию интерфейсный метод является виртуальным и запечатанным, это не позволяет производному классу переопределять 
интерфейсные методы, но если явно указать метод как виртуальный, компилятор сделает его таковым и оставит незапечатанным, что 
предоставит производному классу возможность переопределять интерфейсные методы.
	Производный класс не в состоянии переопределять интерфейсные методы, объявленные запечатанными, но может повторно унаследовать
тот же интерфейс и предоставить собственную реализацию его методов. При вызове интерфейсного метода объекта вызывается реализация,
связанная с типом самого объекта.		

##		Явные и неявные реализации интерфейсных методов
	Явную реализацию интерфейсного метода (Explicit Interface Method Implementation, EIMI) - иногда нужно определить тип,
реализующий несколько интерфейсов с одинаковыми методами, у которых совпадают имена и сигнатуры. При реализации интерфейсов нужно
явно указать название методов вместе с названием интерфейса, чтобы сообщить компилятору, какая из реализаций принадлежит
конкретному интерфейсу. 
	При явной реализации интерфейсного метода нельзя указывать уровень доступа, по умолчанию он будет private, что запрещает
любому коду использовать экземпляр класса простым вызовом интерфейсного метода. Единственный способ вызвать интерфейсный метод —
обратиться через переменную этого интерфейсного типа.
	EIMI-метод не может быть виртуальным, а значит, его нельзя переопределить.
	Недостатками EIMI являются: также отсутствие IntelliSense-поддержки в Microsoft Visual Studio, при приведении к интерфейсному
типу экземпляры значимого типа упаковываются, EIMI нельзя вызвать из производного типа, явная реализация интерфейсного метода не
может вызываться из производного класса.	
	
##		Обобщенные интерфейсы
	Обобщенный интерфейс - это механизм который позволяет не указывать аргумент-тип, а только описать набор сигнатур, а уже в 
ссылочном или значимом типе, который реализуют обобщенный интерфейс указать этот аргумент-тип. Любая попытка работы со значимым
типом через необобщенный интерфейс, будет приводить к необходимости упаковки и потере безопасности типов, соответственно:
	Обеспечивают безопасность типов на стадии компиляции;
	При работе со значимыми типами требуется меньше операций упаковки;
	Класс может реализовать один интерфейс многократно, просто используя параметры различного типа;
	Параметры интерфейса обобщенного типа могут быть также помечены как контравариантные или ковариантные, что позволяет более
гибко использовать интерфейсы.

#		Абстрактный класс
	Абстрактный класс - это класс с модификатором abstract, который указывает, что класс предназначен только для использования в 
качестве базового класса и не должен быть создан сам по себе, а его члены имеют отсутствующую или неполную реализацию. 
	Абстрактные классы могут быть наследованы от базового класса и могут переопределять виртуальные методы.
	Абстрактные классы могут быть наследованы от интерфейса и сопоставлять методы интерфейса с абстрактными методами.
	Абстрактные типы могут содержать абстрактные методы, свойства, индексаторы и события
	Абстрактный класс может иметь не абстрактные переменные, методы, конструкторы, свойства.
	При переопределении в производном классе абстрактный метод или свойство объявляются с модификатором override. Если класс имеет
хотя бы один абстрактный член, то этот класс должен быть определен как абстрактный.

#		Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах
	Каждый из параметров-типов обобщенного делегата должен быть помечен как ковариантный или контравариантный. Благодаря этому 
можно выполнять приведение экземпляров обобщенного делегата к тому же типу делегата, но с другим параметром-типом. 
	Параметры-типы могут быть:
	Инвариантными - параметр-тип не может изменяться и данный подход используется по умолчанию.
	Контравариантными - параметр тип может быть преобразован к производному классу от него и обозначается ключевым словом in и 
может появляться только во входной позиции, например, в качестве параметра метода.
	Ковариантными - параметр-тип может быть преобразован к базовому классу и обозначается ключевым словом out и может появляться 
только в выходной позиции, например, возвращаемого значения метода.
	Нельзя использовать инвариантность с ключевыми словами ref и out

#		Символы
	Символы в .NET Framework всегда представлены 16-разрядными кодами стандарта Юникод и являются экземпляром структуры Char, тип
System.Char содержит два открытых неизменяемых поля: константа MinValue MaxValue.
	Для облегчения работы с типом Char имеется несколько статических методов также несколько собственных экземплярных методов
	Есть три способа преобразования различных числовых типов в экземпляры типа Char, и наоборот: приведение типа, использование 
типа Convert, который содержит несколько статических методов, или использование интерфейса IConvertible, котором определены такие
методы, как ToUInt16 и ToChar.
	 
##		Строки
	System.String — представляет неизменяемый набор символов, являясь прямым потомком Object, и является ссылочным типом, поэтому
всегда размещаются в куче. String относится к примитивным типам соответственно компилятор хранит литеральные строки в метаданных
модуля, откуда они загружаются и используются во время выполнения.
		String s = "Hi" + " " + "there."; 	// Конкатенация трех литеральных строк образует одну литеральную строку
	Конкатенацию литеральных строк, компилятор выполняет на этапе компиляции, а в метаданных модуля помещается строка "Hi there."
	Конкатенация нелитеральных строк происходит на этапе выполнения, соответственно ее применять нежелательно, так как он создает
в куче несколько строковых объектов. Рекомендуется использовать тип System.Text.StringBuilder.
	Интерполяция строк  - это когда используется знак доллара перед строкой, а внутри строки используются плейсхолдеры {}, в 
которых уже можно напрямую писать те выражения, которые мы хотим вывести. $"Имя: {name}  Возраст: {age}"
	Буквальные строки (verbatim strings) — используют при задании пути к файлу или каталогу и при работе с регулярными выражениями
		String file = "C:\\Windows\\System32\\Notepad.exe"; 				String file = @"C:\Windows\System32\Notepad.exe";
	Сравнение строк - операторы равенства == и != по определению сравнивают не ссылки, а значения объектов string.
	Необработанные строковые литералы - доступны начиная C#11 содержат произвольный текст, не требуя escape-последовательностей. 
Необработанные строковые литералы заключены как минимум в три двойные кавычки (""").
	Интернирование строк - если в приложении ожидается появление множества одинаковых строк, то для повышения производительности
можно применить интернирование строк (string interning). При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами
являются строки, а значениями — ссылки на строковые объекты в управляемой куче. В классе String есть два метода, предоставляющие
доступ к внутренней хеш-таблице:
		String Intern(String str);  					 String IsInterned(String str);
	Intern, ищет String во внутренней хеш-таблице и возвращает ссылку на найденный объект String. Иначе создается копия строки,
которая добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию.
	IsInterned, ищет String во внутренней хеш-таблице и возвращает ссылку на интернированную строку. Иначе возвращает null, а
саму строку не вставляет в хеш-таблицу.
	Создание пулов строк - чтобы не допустить роста объема кода, многие компиляторы хранят литеральную строку в метаданных модуля
только в одном экземпляре. Все упоминания этой строки в исходном коде компилятор заменяет ссылками на ее экземпляр в метаданных. 
	
##		StringBuilder
	Тип StringBuilder в отличие от String представляет изменяемую строку - массив структур Char. Используя экземпляр StringBuilder,
можно манипулировать этим массивом, сокращая строку и изменяя символы строки. Это значит, что изменение содержимого экземпляра SB,
не создает новые объекты, а при увеличении строки, ранее выделенный массив символов, StringBuilder автоматически выделит память
для нового, большего по размеру массива, скопирует символы и приступит к работе с новым массивом. А прежний массив попадет в сферу
действия уборщика мусора. StringBuilder выделяет память для новых объектов только в двух случаях:
	при динамическом построении строки, размер которой превышает установленную емкость;
	при вызове метода ToString типа StringBuilder.	
	Вызов метода ToString типа StringBuilder преобразовывает массив символов StringBuilder в объект String. Этот метод возвращает
просто ссылку на строку. Поскольку массив символов здесь не копируется, метод выполняется очень быстро.
	У типа StringBuilder несколько конструкторов, которые позволяют проинициализировать три поля: 
	Максимальная емкость (maximum capacity) по умолчанию оно равно Int32.MaxValue.
	Емкость (capacity) — поле типа Int32, показывающее размер массива символов StringBuilder. По умолчанию оно равно 16. 
	Массив символов (character array) — массив структур Char, содержащий набор символов «строки». 
	
##		Форматирование нескольких объектов в одну строку
	String s = String.Format("On {0}, {1} is {2} years old.", new DateTime(2012, 4, 22, 14, 35, 5), "Aida", 9); 

#		Настраиваемые атрибуты
	Настраиваемые атрибуты представляют собой средство передачи дополнительной информации, которая хранится в метаданных 
управляемого модуля. Атрибуты могут применяться как ко всему типу: классу, интерфейсу и т.д., так и к отдельным его частям:
методу, свойству и т.д. Чтобы применить атрибут для этого нужно имя атрибута поместить в квадратные скобки перед именем класса или
другим членом типа.
	Можно применить один или несколько атрибутов ко всей сборке, к модулю или к более мелким элементам программы, например к
классам и свойствам. Атрибуты могут принимать параметры, также как методы и свойства. Можно явным образом указать target - целевой
объект атрибута, например, что атрибут применяется к методу, параметру или возвращаемому значению. А при помощи отражения можно
получать сведения атрибутов, которые применены к объекту, используя метод GetCustomAttributes.
	Настраиваемый атрибут — это экземпляр класса, который должен прямо или косвенно наследовать от абстрактного класса Attribute и
должен иметь открытый конструктор для создания экземпляров. 
											
#		Механика обработки исключений. try-catch-finally. throw ex vs throw.
	Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а иногда и вовсе невозможно.При
обработке исключений используются ключевые слова try, catch и finally для действий, которые могут оказаться неудачными. Например,
при передачи файла по сети может неожиданно оборваться сетевое подключение или просто нужно закрыть сетевое подключение или файл.
private void SomeMethod() {
try { // Код, требующий корректного восстановления или очистки ресурсов}
catch (InvalidOperationException) { // Код восстановления работоспособности после исключения InvalidOperationException}
catch (IOException) { // Код восстановления работоспособности после исключения IOException}
catch {Код восстановления работоспособности после остальных исключений - их обычно генерируют повторно.
	throw;}
finally { // Код, выполняющий очистку ресурсов после операций, начатых в блоке try. Он выполняется ВСЕГДА}
	// Код, следующий за блоком finally, выполняется, если в блоке try не генерировалось исключение или если исключение было 
перехвачено блоком catch, а новое не генерировалось
}
	Блок try
	В блок try помещается код, требующий очистки ресурсов или восстановления, после исключения, а сам код очистки содержится в
блоке finally. Также может располагаться код, приводящий к генерации исключения. Код же восстановления вставляют в один или
несколько блоков catch.
	Блок try должен быть связан хотя бы с одним блоком catch или finally; сам по себе он не имеет смысла иначе будет ошибка.
	Блок try может существовать и без блока finally, но одному блоку try может соответствовать только один блок finally.
	Когда внутри такого блока try возникает исключение, поток управления переходит к первому подходящему обработчику исключений в
стеке вызовов. Если для созданного исключения не существует обработчиков, выполнение программы прекращается с сообщением об ошибке.
	Один блок try может быть вложен в ноль и больше блоков try. Исключение, генерируемое во внутреннем блоке try и не перехваченное
в соответствующем блоке catch, передается во внешний блок try. 
	Блок catch
	В блок catch помещают код, который должен выполняться в ответ на исключение. Выражение в скобках после ключевого слова catch
называется типом исключения (catch type). Один блок catch соответствует одному событию, после которого может потребоваться
восстановление приложения. 
	Поиск подходящего блока catch осуществляется сверху вниз, поэтому сначала следуют потомки с наибольшей глубиной наследования,
потом — их базовые классы и, наконец, — класс Exception или блок с неуказанным типом исключений.
	При обнаружении блока catch нужного типа выбирается способ восстановления после исключения. Еще раз сгенерировать то же
исключение throw или throw ex, сгенерировать исключение другого типа throw new exceptOb для передачи информации о нем коду
расположенному выше в стеке или позволить программному потоку выйти из catch естественным образом.
	В последнем же случае происходит переход к блоку finally, после выполнения всего содержащегося в нем кода, управление
переходит к коду расположенному после блока finally. Если блок finally отсутствует, поток переходит к коду распложенному после 
блока catch.
	В C# после типа перехватываемого исключения можно указать имя переменной, которая будет ссылаться на сгенерированный объект,
потомок класса System.Exception. В коде блока catch эту переменную можно использовать для получения информации об исключении.
	Если код в блоке try не порождает исключение, CLR никогда не переходит к выполнению кода блока catch, а сразу переходя к коду
блока finally, если таковой существует. Выполнив код блока finally, поток переходит к инструкции, следующей за этим блоком.
	Фильтры исключений позволяют обрабатывать исключения в зависимости от определенных условий. Для их применения после выражения
catch идет выражение when, после которого в скобках указывается условие: catch (DivideByZeroException) when (y == 0) {cw("0");}
	Блок finally
	Код блока finally выполняется всегда. Обычно этот код производит очистку после выполнения блока try. Если в блоке try был
открыт некий файл, блок finally должен содержать закрывающий этот файл код, а если код блока try выполняется без исключений, файл
закрывается.
	Блок finally следует поместить после всех блоков catch или если его нет, то после блока Try.
	Явное создание исключений исключение можно вызвать явным образом с помощью C# throw new exceptOb;
	Перехваченное исключение можно вызвать повторно с помощью оператора throw, чтобы повторно выбросить обнаруженное исключение,
и сохранить трассировку стека (путь к источнику исключения), а throw ex генерирует тоже исключение, но сбрасывает трассировку стека
- это полезно, если нужно скрыть от пользователя конфиденциальную информацию, которую может содержать трассировка стека.

##		Создание пользовательских исключений.
	Можно создавать собственные классы исключений для этого нужно создать сериализуемый класс, который наследует от Exception, а
имя класса должно заканчиваться на Exception. Классы должен определять три конструктора:
    public InvalidDepartmentException() : base() { } один конструктор без параметров, 
    public InvalidDepartmentException(string message) : base(message) { } свойство сообщения
		и тот, который задает как свойство сообщение так и InnerException свойство.
    public InvalidDepartmentException(string message, Exception inner) : base(message, inner) { }
	Определите любые дополнительные свойства и конструкторы которые бутут хранить дополнительную информацию.
	При добавлении новых свойств в производный класс исключений необходимо переопределить метод ToString() чтобы он возвращал
добавленные сведения.	
	При использовании инструкций lock, using и foreach блоки try/finally создаются автоматически. Компилятор строит эти блоки и
при переопределении деструктора класса метод Finalize.
	При работе с упомянутыми конструкциями написанный вами код помещается в блок try, а код очистки — в блок finally. А именно:
	если вы используете инструкцию lock, то внутри блока finally снимается блокировка;
	если вы используете инструкцию using, то внутри блока finally для объекта вызывается метод Dispose;
	если вы используете инструкцию foreach, то внутри блока finally для объекта IEnumerator вызывается метод Dispose;
	если вы определяете деструктор, то внутри блока finally вызывается метод Finalize базового класса
					
##		Корректное восстановление после исключения
	Нужно использовать блоки try/catch/finally для восстановления после ошибок, освобождения ресурсов или ресурсов, которые лежат
за пределами dotNet.
	Обработка общих условий без выдачи исключений. Для условий, которые могут возникнуть, но способны вызвать исключение,
рекомендуется реализовать обработку таким способом, который позволит избежать исключения. Например, если попытаться закрыть уже
закрытое подключение, вы получите InvalidOperationException. Этого можно избежать, используя оператор if для проверки состояния
подключения перед попыткой закрыть его.	Если вы не проверяете состояние подключения перед закрытием, можно перехватить
InvalidOperationException исключение блоком catch.
	Можно использовать специальные методы или свойства предоставляемые классом, чтобы недопустить возникновения исключения.
Например при чтении из файла, определять, достигнут ли конец файла.
	Необработанные исключения - если ни один из блоков catch не отвечает типу исключения, возникает необработанное исключение 
(unhandled exception). Обнаружив в процессе поток с необработанным исключением, CLR немедленно уничтожает этот поток. 
Необработанное исключение указывает на ситуацию, которую не предвидел программист, и должно считаться признаком серьезной ошибки.

##		Какая разница между методами Finalize и Dispose. Чем плох деструктор/финализатор и когда использовать IDisposable?
	Финализатор т.е деструктор используется для того, чтобы явно освободить неуправляемые ресурсы, когда будет вызван GC.
	К неуправляемым ресурсам можно отнести соединения с базами данных, сетевые соединения, файлы, а также прочие элементы, которые
не являются частью .Net, но используются в нашем коде. Финализация позволяет объекту освободить ресурсы, которые он использует.
Объявление финализатора похоже на объявления конструктора, но перед названием необходимо добавить знак «тильда». Однако на деле при
очистке сборщик мусора вызывает не деструктор, а метод Finalize
	Одним из недостатков использования финализаторов является то, что мы не знаем точно, когда он будет вызван. Т.е когда именно
Garbage Collector будет удалять наш объект из памяти. Кроме того, при финализации двух связанных объектов порядок вызова
деструкторов не гарантируется.
	Чтобы очистить неуправляемы ресурсы быстрее нужно наследовать этот объект от интерфейса IDisposable или если в классе уже есть
управляемые (IDisposable) ресурсы. Интерфейс IDisposable содержит только один метода - Dispose, который позволяет освободить
неуправляемые ресурсы немедленно. Важно, при реализации этого метода, что даже многократный вызов Dispose должен происходить без
ошибок. 
	Объекты, которые реализуют интерфейс IDisposable, можно освобождать при помощи ключевого слова using, которое гарантирует, что
после использования данного объекта будет вызван метод Dispose, а в случае исключений они будут обработаны. Поскольку к коду внутри
using автоматически добавляются блоки try/finally. Если программист хотел бы расширить этот синтаксис и использовать блок catch,
то связку try/catch/finally необходимо будет написать самостоятельно.
	Разницей между использованием финализаторов и интерфейса IDisposable является то, что финализаторы вызываются Garbage
Collector’ом и у нас нет особых рычагов влияния, когда это произойдет, а объекты, которые реализует IDisposable, нужно освободить
пользователем явно, вызывав метод Dispose, когда объект уже не нужен или использовать using.

##		Сборщик мусора. Триггеры вызова. Что влияет на его скорость работы. Количество поколений. LOH. Как определить
		производительность GC. Что такое POH.
	Garbage Collector - это механизм, который управляет выделением и освобождением памяти для приложения. Очистка памяти – это
ресурсоёмкий процесс, т.к. перед уборкой мусора все потоки, связанных с приложением, приостанавливаются. Он запускается, когда в
куче отсутствует место для создания нового объекта в поколениях или операционная система сигнализирует об отсутствие свободного
места в памяти, а также, после завершения работы CLR, выгрузки домена приложения или вызов статического метода GC.Collect().
	Во время работы уборщик мусора проверяет счётчик ссылок на другие объекты, наличие ссылок на корневой элемент в callStack-e и
маркирует их. В результате мы имеем набор маркированных и не маркированных объектов. Не маркированные объекты процесс уборки
мусора не переживут, а с маркированными будут дефрагментированны. В итоге объекты, пережившие уборку мусора переносятся из
поколения ноль в первое, всего поколений 2. Это количество поколений подобрано экспериментальным путем и является наиболее
оптимальным. Для ускорения работы GC, при первой попытке очистки – проверяются объекты только «поколения 0». Если был освобожден
достаточный объем памяти, то работа GC прекращается, иначе происходит очистка следующих поколений.
	Кроме Small Object Heap (SOH) также существуют большие объекты, размер которых превышает 85к байт и размещаются они в Large
Object Heap (LOH), хотя сейчас POH и LOH уже принадлежат User Old Heap (UOH). Её особенностью является то, что она не
дефрагментируется т.к. на их перемещение в памяти потребуется слишком много процессорного времени, а также эти объекты принадлежат
поколению 2 соответственно очистка этих объектов происходит редко.
	Для определения производительности, существуют статические методы CollectionCount и GetTotalMemory, которые вызываются для
выяснения числа операций уборки мусора в конкретном поколении и объема памяти, занятого в данный момент объектами в куче.
		Int32 CollectionCount(Int32 generation);
		Int64 GetTotalMemory(Boolean forceFullCollection);
	Pinned Object Heap (POH) - куча закрепленных объектов в отличие от других видов кучи, эта доступна разработчикам явно и
принадлежит поколению 2. Закрепленные объекты - это объекты, которые были явно помечены как невозможные к перемещению сборщиком
мусора, чтобы гарантировать что они не будут случайно перемещены сборщиком мусора. Это помогает поддерживать целостность
расположения памяти при работе с низкоуровневыми сценариями и передачи данных в unmanaged код. Рекомендуется закреплять объекты
только на короткое время из-за дефрагментации. В POH поддерживает только закрепления массивов.

#		Потоки и процессы. Их различия. Переключения контекста. background и foreground thread
	Первые операционные системы не поддерживали концепцию потоков. Соответственно задачи которые выполнялись длительное время
приостанавливали выполнение других задач, либо приводили к ошибки и проходилось перезагружать систему. Поэтому для решения этих
проблем были придуманы потоки и процессы. Каждому процессу выделяется собственный поток исполнения, который работает как
виртуальный процессор. Если код приложения войдет в бесконечный цикл, то блокируется только связанный с этим кодом процесс, 
а остальные процессы продолжают функционировать.
	Процесс - набор ресурсов, используемый отдельным экземпляром приложения и имеет собственно виртуальное адресное пространство,
что гарантирует, что код и данные одного процесса будут изолированы для другого
	Различие между процессом и потоком: поток и процесс служат для разделения работы, но поток стоит выбирать для легковесных
операций, в то время как процесс для тяжелых операций. Каждый процесс имеет собственное виртуальное пространство с набором
ресурсов, а инициализированный поток использует эти ресурсы. Обмен данных между потоками в рамках одного процесса быстрее, чем у
отдельных процессов.
	Переключения контекста (context switching) - механизм который позволяет распределять физический процессор между всеми своими
потоками путем переключения контекста на другой поток. Переключение контекста повышает надежность
системы и скорость реагирования на действия конечных пользователей, но снижает производительность.
	Фоновые и активные потоки background и foreground. 
	foreground - активные поток, при завершении всех активных потоков также принудительно завершат свою работу все запущенные 
фоновые потоки и завершит выполнение приложения. Поток можно превращать из активного в фоновый и обратно, а при помощи
свойства IsBackground узнать фоновый он или активных. 
	Основной поток приложения и все потоки, в созданные путем объекта Thread, по умолчанию являются активными. А вот потоки из 
пула по умолчанию являются фоновыми.

##		Способы создания потоков. Thread, ThreadPool, Task.
	Первый способ. Создание потока при помощи Thread, для создания которого следует передать конструктору делегат ThreadStart 
с параметром либо без и вызвать метод Start для запуска потока. Потоки, созданные при помощи Thread, по умолчанию являются
активными. Недостатком является то, что для каждого задания нужно создавать новый поток, а это уменьшает производительность.
	delegate void ThreadStart(); delegate void ParameterizedThreadStart(object obj)  

	Второй способ. Создание потока при помощи ThreadPool. Каким образом поток берется с ThreadPool и возвращается туда обратно.
	При инициализации CLR ThreadPool пуст, пока не появится первый запрос, который помещается в очередь пула потоков. Далее 
ThreadPool извлекает запросы из очереди и распределяет по разным потокам в ThreadPool. Если у пула нет потока, то создается новый
поток, а после завершения исполнения своего задания поток не уничтожается, а возвращается в пул для ожидания следующего запроса
это позволяет повысить производительность, но если приложение отправляет пулу много запросов, которые он не успевает обслужить с
помощью одного потока, то создаются дополнительные потоки, которые через некоторое время бездействия, после уменьшения нагрузки
пробуждаются и самоуничтожаются, освобождая ресурсы.
	Чтобы добавить метода в очередь ThreadPool, то используется его метод QueueUserWorkItem, в который передается делегат
WaitCallback, представляющий метод, который нужно добивать в очередь. 
	ThreadPool.QueueUserWorkItem(new WaitCallback(SomeMethod)); delegate void WaitCallback(Object state);
	Для каждого процесса существует один пул потоков. Размер пула потоков зависит от размера виртуального адресного пространства. 
	Преимущества: 
	- Не нужно создавать новый поток на каждое задание, что повышает производительность приложения. 
	- Пул потоков сам управляет созданием потоков, благодаря этому можно сосредоточиться на решении задачи.
	Недостатки:
	- Все потоки в пуле потоков являются фоновыми.
	- Нельзя изменять приоритет, получить имя потока, возвращаемое значение или узнать о завершении операции.
	- Потоки в пуле подходят для выполнения только коротких задач. Поскольку большое число заблокированных потоков в пуле может
препятствовать запуску задач.
	
	Третий способ. Создание потока при помощи Task. Он описывает  задачу, которая запускается асинхронно пула потоков, но также
ее можно запустить синхронно. Для создания Task, нужно передать делегат Action или лямбда-выражение и вызвать метод Start для
запуска задачи, а для операций, возвращающие значения используется Task<TResult> и метод Result, чтобы получить значение.
	- Использовать Task и делегат	
		Task t1 = new Task(() => CW("Hello")); t1.Start();
	- Использовать статический метод Run и делегат
		Task t2 = Task.Run(() => CW("Hello"));
		Task<int> t3 = Task.Run(() => Math.Max(10, 20)); t3.Result
	- Использовать Task.Factory.StartNew для создания группы заданий, а метод StartNew сразу запускает задачу. 
		Task t4 = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
	- Можно создать и запустить массив задач, а метод Task.WaitAll(tasks) позволит дождаться выполнение всех задач.
		Task<Int32>[] t5 = new Task<Int32>[](() => {много Task}
	Методы:
	t.Result - получаем результат выполнения, возвращаемого вычислительной операцией.
	t.Wait() - ждет завершения задания и получить результат, даже если все foreground потоки завершили свое выполнение - они
будут ждать и приложение не закроется.
	t.WaitAll - ждет завершения всех заданий. Возвращает Bool.
	t.ContinueWith - позволяет узнать о завершении задания Task и запустить следующую.
	Если вычислительное задание генерирует необработанное исключение, оно поглощается и сохраняется в коллекции, а потоку пула
разрешается вернуться в пул. Затем при вызове метода Wait или свойства Result эти члены вбросят исключение AggregateException.
	Для написания масштабируемого программного обеспечения следует избегать блокировки потоков. Вызов метода Wait или запрос
свойства Result при незавершенном задании приведет, скорее всего, к появлению в пуле нового потока, что увеличит расход ресурсов и
отрицательно скажется на расширяемости. 
	
##		Концепция асинхронности, TAP. Асинхронные методы. Какие операции лучше выполнять синхронно, а какие асинхронно. 
	Асинхронность подразумевает выполнение операции без ожидания ее завершения и без блокировки вызывающего потока, благодаря
чему можно приступить к выполнению другой задачи.
	TAP (Task-based Asynchronous Pattern) — это паттерн, при котором используется тип Task и async/await, хотя это подход
появился до их появления, но async/await значительно улучшил эту концепцию.
	Асинхронные методы - это метод помеченный модификатором async, который означает, что в этом методе можно использовать 
инструкцию await, которое позволяет обойтись без блокировки вызывающего потока, когда элемент управления достигает выражения 
await, а затем продолжить выполнение кода в методе, когда задача завершается. 
	Оператор await заставляет компилятор сгенерировать код, который запрашивает свойство Result объекта Task<TResult> и
присваивает результат локальной переменной, или выдает исключение в случае ошибки, а затем выполняется оставшаяся часть кода.
Асинхронный метод обычно имеет тип возвращаемого значения Task<TResult>, Task, IAsyncEnumerable<T> или void, который используется
для определения обработчиков событий, но вызывающий объект метода не может перехватывать исключения, т.е передать исключение 
выше по callStack, а также нельзя применить void.
	Асинхронный метод не может объявлять параметры out, ref, или in, но может вызывать методы, имеющие такие параметры.
	Для приличия соблюдать конвенцию о суффиксе Async и желательно добавлять перегрузку с CancellationToken.
	Когда нельзя использовать await:
	Оператор await может встречаться внутри блока try, но не внутри блоков catch, finally или unsafe, соответственно всегда можно 
поставить не внутри блока catch, а после него, для чего следует либо воспользоваться предложением return, либо завести 
булевскую переменную, в которой запомнить, возбуждала ли исходная операция исключение. 
	Какие операции лучше выполнять синхронно, а какие асинхронно.
	Используйте async /await только для тех мест, которые могут длиться «долго», например выполнение IO запроса - сетевые запросы,
доступ к диску, продолжительные задержки и тд, а если ваша операция коротка или займёт несколько циклов процессора, тогда возможно
будет лучше выполнять эту операцию синхронно. 
	Также, если метод фреймворка заканчивается на Async и возвращает Task, тогда, скорее всего нужно использовать его асинхронно.

	Вам нужно выкопать во дворе бассейн.
	Вы взяли лопату и копаете. Это однопоточная работа
	Вы пригласили друга Васю и копаете вместе, периодически задевая друг-друга лопатами. Это многопоточная работа
	Пока вы копаете бассейн, Вася копает канаву под водопровод. Никто никому не мешает. Это распараллеливание
	Вы пригласили бригаду землекопов, а сами с Васей пошли пить пиво. Когда бригада все сделает, к вам придут за деньгами. Это асинхронная работа.
	Количество лопат в хозяйстве - это количество ядер в системе

##		Во что разворачивается компилятором конструкция await и Task?
	Конструкция async/await разворачивается компилятором в конечный автомат. В конечном автомате переменные метода становятся
полями, это позволяет запоминать состояние работы метода и продолжать его, после ожидания завершения длительной операции.
	Task строит цепочку продолжений, которая увеличивается в соответствии с количеством задач, связанных последовательно, и
состояние системы управляется через замыкания, найденные компилятором.

##		CPU-bound и IO-Bound операции
	CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне 
текущей железки. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов 
обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число 
вычислительных устройств) бессмысленно поскольку это приведет к падению общей эффективности вычислений. ОС-ке придется 
переключать несколько доступных ядер для обслуживания сотен потоков. А этот процесс не является дешевым.
	
##		Контекст синхронизации. ConfigureAwait(false) vs ConfigureAwait(true) vs без использования ConfigureAwait.
	Контекст синхронизации (SynchronizationContext) - это тип, который позволяет получить текущий контекст синхронизации, сохранить
его и возобновить выполнение метода в том контексте, в котором он начал свое выполнение, но выполнение может продолжится в другом
потоке, а в .Net Core и вовсе нет контекста синхронизации. В классе SynchronizationContext есть метод Post, который гарантирует,
что переданный делегат будет исполняться в правильном контексте.
Важно! В момент приостановки метода при встрече оператора await текущий контекст SynchronizationContext сохраняется.
Далее, когда метод возобновляется, компилятор вставляет вызов Post, чтобы исполнение возобновилось в запомненном контексте.
	ConfigureAwait - это метод, который принадлежит классу Task и позволяет указать, необходимо ли нам выполнять продолжение 
в том же контексте, где была вызвана асинхронная операция. 
	По умолчанию, без использования этого метода, контекст запоминается и продолжение ведется в нем с помощью метода Post, но и 
является дорогой операцией. Поэтому, если производительность на 1-м месте, и нам необязательно продолжать операцию в том же 
контексте, то можно указать ConfigureAwait(false). 
	ConfigureAwait(false) - это означает, что неважно, в каком контексте продолжится выполнение.
	ConfigureAwait(true) - задаёт поведение по-умолчанию и не несёт в себе никакого смысла.
	Без использования ConfigureAwait - если сравнить await task и await task.ConfigureAwait(true) — они окажутся функционально
идентичны. Таким образом, если в коде присутствует ConfigureAwait(true), его можно удалить без каких-либо негативных последствий. 

##		Что такое CancellationToken? Отмена асинхронных операций.	
	CancellationToken - это тип, который позволяет отменить асинхронную операцию. По соглашению асинхронный метод должен иметь
перегруженный вариант с типом CancellationToken, который при помощи метода ThrowIfCancellationRequested порождает исключение типа
OperationCanceledException. Библиотека Task Parallel Library знает, что такое исключение представляет отмену, а не ошибку, и 
обрабатывает его соответственно. Например, в классе Task имеется свойство IsCanceled, которое автоматически принимает значение 
true, если при выполнении async-метода произошло исключение OperationCanceledException.
	Удобной особенностью подхода к отмене, основанного на токенах CancellationToken, является тот факт, что один и тот же токен 
можно распространить на столько частей асинхронной операции, сколько необходимо, – достаточно просто передать его всем частям.
Неважно, работают они параллельно или последовательно, идет ли речь о медленном вычислении или удаленной операции, – один 
токен отменяет всё.

##		Виды синхронизации потоков. lock, Monitor
	Оператор lock это упрощенный синтаксис класса Monitor. Он определяет блок кода, для блокировки которого используется
объект-заглушка. Когда выполнение доходит до оператора lock, объект блокируется и весь код становится недоступным для других
потоков до завершения работы текущего потока. Остальные потоки помещаются в очередь ожидания и ждут, пока текущий поток не
освободит данный блок кода.
	Не используйте один и тот же экземпляр объекта блокировки для разных общих ресурсов: это может привести к взаимоблокировке.
	Удерживайте блокировку в течение максимально короткого времени, чтобы сократить число конфликтов при блокировке.
	Класс Monitor - его метод Monitor.Enter принимает два параметра: объект блокировки и значение типа bool, которое указывает на
результат блокировки, если он равен true, то блокировка успешно выполнена. Его код рекомендуется обернуть блоком try, а вызов
Exit, в котором происходит освобождение объекта, поместить в блок finally. Это гарантирует снятие блокировки даже при возникновении 
исключения, если блокировка осуществлена успешно он становится доступным для других потоков.
	Оператор lock - синтаксический сахар, который вызывает методы Monitor.Enter и Monitor.Exit, но Monitor позволяет добавлять
значение тайм-аута для ожидания получения блокировки, чтоб избежать блокировки на слишком длительное время при помощи метода
TryEnter и передать в нем значение тайм-аута.
	Оператор lock работает быстрее чем Mutex, но к нему невозможно получить доступ из другого процесса, а вот к Mutex - можно.

##		Конструкции режима ядра: Mutex, Semaphores и Events
	Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в
одном экземпляре. Они работают намного медленнее конструкций пользовательского режима, т.к требуют координации со стороны ОС. К
ним относятся Mutex, Semaphores и Events в их основе лежит абстрактный класс WaitHandle.
	Вот как выглядит иерархия этих классов:
		WaitHandle
			EventWaitHandle
				AutoResetEvent
				ManualResetEvent
			Semaphore
			Mutex
			
	Mutex — это примитив синхронизации, предоставляющий монопольный доступ к общему ресурсу только одному потоку. Если поток
получает мьютекс, второй поток, приостанавливается до тех пор, пока первый поток не выпустит мьютекс.
	Класс Mutex в отличии от Semaphore обеспечивает идентификацию потоков, поэтому он может быть освобожден только тем потоком,
который его приобрел. Мьютекс также можно передавать через границы домена приложения.
	К классу Mutex в отличии lock можно получить доступ из другого процесса, но работает он намного медленнее.
	Сначала создаем объект Mutex: 	Mutex mutexObj = new Mutex()
	Метод mutexObj.WaitOne() приостанавливает выполнение потока до тех пор, пока не будет получен мьютекс mutexObj. Изначально
мьютекс свободен, поэтому его получает один из потоков, а после выполнения всех действий, поток освобождает его с помощью метода
mutexObj.ReleaseMutex(). Далее мьютекс получает следующий ожидающий поток.

	Semaphore - это примитив синхронизации, предоставляющий монопольный доступ к общему ресурсу нескольким потокам. В конструкторе
указывается количество потоков. Их количество уменьшается каждый раз, когда поток входит в семафор, и увеличивается, когда поток
его освобождает. Если счетчик равен нулю, то следующие запросы блокируются до тех пор, пока другие потоки не отпустят семафор.
	Семафоры бывают двух типов: локальные и именованные системные семафоры. 
	Именованный семафор - это семафор, который принимает имя в конструкторе, и видные всей ОС и могут использоваться для
синхронизации действий процессов. Можно создать несколько экземпляров представляющих один и тот же именованный семафор, если
указать одно и тоже имя несколько раз.
	Локальный семафор существует только внутри процесса. Его может использовать любой поток в вашем процессе, имеющий ссылку на
локальный объект Semaphore.
	Для работы с потоками класс Semaphore имеет два основных метода:
	WaitOne(): ожидает получения свободного места в семафоре
	Release(): освобождает место в семафоре
	The SemaphoreSlim class represents a lightweight, fast semaphore that can be used for waiting within a single process when 
wait times are expected to be very short. This would mean that a SemaphoreSlim could not be used for cross-process synchronization

	EventWaitHandle - это примитив синхронизации, предоставляющий монопольный доступ к общему ресурсы либо сразу нескольким
потокам - в зависимости от режима сброса. Он может находиться в сигнальном или несигнальном состоянии. Если состояние события
несигнальное, поток, который вызывает метод WaitOne, будет заблокирован, пока состояние события не станет сигнальным методом Set(),
который задает сигнальное состояние события, находясь в сигнальном состоянии, потоки, ожидающие событие, могут продолжить свою
работу.	Поведение EventWaitHandle после получения сигнала зависит от его режима сброса:
	EventResetMode.AutoReset: AutoResetEvent - это класс, автоматически сбрасывается в несигнальное состояние после получении
сигнала, а после выполнения работы обратно переводит его в сигнальное состояние. Это похоже на турникет, пропускающий только один
поток каждый раз, когда он переводится в сигнальное состояние.
	Для этого создаем переменную типа AutoResetEvent. Передавая в конструктор значение true, указывая, что создаваемый объект
изначально будет в сигнальном состоянии. Когда начинает работать поток, то первым делом срабатывает вызов waitHandler.WaitOne(),
который указывает, что главный поток переводится в состояние ожидания. После выполнения работы вызывается метод Set, который
уведомляет все ожидающие потоки, что объект waitHandler снова находится в сигнальном состоянии, теперь следующий ожидающий поток,
переводит waitHandler в несигнальное состояние и выполняет свой код. А остальные потоки снова ожидают.
	EventResetMode.ManualReset: ManualResetEvent основное отличие от AutoResetEvent заключается в том, что при установке одного
set работу начинают от одного и более потоков, а не один, и для того что бы перевести поток в не сигнальное состояние
используется Reset(). Это как ворота, которые закрыты до получения сигнала и остающиеся затем открытыми, пока кто-нибудь их не
закроет. 
	Если у нас в программе используются несколько объектов AutoResetEvent, то мы можем использовать для отслеживания состояния
этих объектов статические методы WaitAll и WaitAny, которые в качестве параметра принимают массив объектов класса WaitHandle.
	Итак, что происходит при выполнении программы:
	1. AutoResetEvent waitHandler = new AutoResetEvent(true) - подал сигнал
	2. Первый поток в очереди к нему 
	3. waitHandler.WaitOne(); - поймал сигнал, и погасил текущий поток - главный т.е ввёл остальные потоки в режим ожидания.
	4. Выполнился блок кода
	5. waitHandler.Set(); - отдал-включил сигнал. - включил главный поток(вывел главный поток из режима ожидания)
	6. Второй поток в очереди: пункты 3,4,5 - поймал сигнал, погасил, выполнился, отдал-включил
	7. И так далее

##		Deadlock, livelock, starvation.
	Deadlock - взаимоблокировка (deadlock) называется ситуация, когда как минимум два потока останавливаются и ожидают друг от
друга снятия блокировки. Поскольку оба потока ожидают друг от друга выполнения соответствующего действия, получается, что они
блокируют друг друга, из-за чего их ожидание может длиться бесконечно.
	livelock - если поток, использующий в данный момент конструкцию, не освободит ее, ожидающий конструкции поток может оказаться
заблокированным навсегда. В этом случае в пользовательском режиме поток бесконечно исполняется процессором; этот вариант
блокировки называется активной (живой) блокировкой (livelock) или зависанием.
	starvation - во время включения потока Б эксклюзивный ресурс всегда занят другим потоком, из-за чего поток Б прекращает свою
работу не может выполнить свои операции.

#		Подробнее об операторе foreach
	Цикл foreach является универсальным инструментом для обработки коллекций/последовательностей. Способ его преобразования
компилятором зависит от типа перебираемой коллекции (обобщенная/необобщенная) и представляет собой простой цикл while, в котором
вызываем метод enumerator.MoveNext(). Пример обхода необобщенной коллекции выглядит следующим образом (листинг 4.5).
Объекты должны наследоваться от IEnumerable и реализовывать GetEnumerator
public static void ForEachIEnumerable(IEnumerable sequence)
{
	// foreach(var e in sequence) {Console.WriteLine(e);}
	IEnumerator enumerator = sequence.GetEnumerator();
	object current = null;	
	try
	{
		while (enumerator.MoveNext())
		{
			current = enumerator.Current;
			Console.WriteLine(current);
		}
	}
	finally
	{
		IDisposable disposable = enumerator as IDisposable;
		if (disposable != null)
		{
			disposable.Dispose();
		}
	}
}	
	
#		Классы коллекций для параллельного доступа. Parallel LINQ. Класс Interlocked, атомарные операции
	Классы concurrent коллекции можно безопасно использовать в многопоточных приложениях, где возможен одновременный доступ к
коллекции из нескольких потоков. Они реализованы при помощи разбиения хранилища на сегменты, которые внутренне скомбинированы в
связный список. Существует пять коллекций для параллельного доступа, принадлежащих пространству имен System.Collections.Concurrent:
	ConcurrentQueue<T> - этот класс использует 32 массива, которые внутренне скомбинированы в связный список;
	ConcurrentStack<T> - очень похож на ConcurrentQueue<T>;
	ConcurrentBag<T> - Этот класс не определяет никакого порядка для добавления или извлечения элементов;
	ConcurrentDictionary<TKey, TValue> - безопасная в отношении потоков коллекция ключей и значений. При этом коллекция, которая
содержит ключи(buckets) представляет собой связный список c начальным размером не 4, а 32;
	BlockingCollection<T> - коллекция, которая осуществляет блокировку и ожидает, пока не появится возможность выполнить действие
по добавлению или извлечению элемента.

	Parallel LINQ - благодаря классу ParallelEnumerable позволяет выполнять обращения к элементам коллекции в LINQ коллекции в
параллельном режиме. Источник данных разделяется на сегменты, которые обрабатывается в отдельном потоке, что ускоряет выполнение
запросов. PLINQ особенно полезен при работе с большими коллекциями или сложными операциями.
	Атомарная операция — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть
частично выполнена и частично не выполнена. 
	Класс Interlocked обеспечивает более быстрый подход по сравнению с остальными приемами синхронизации, который позволяет
создавать простые операторы для атомарных операций с переменными. Но его методы Increment, Decrement, Exchange, CompareExchange
предназначены только для устранения простых последствий синхронизации.

##		Класс Parallel. Parallel.Invoke, Parallel.For и Parallel.ForEach
	Класс Parallel предназначен для упрощения выполнения параллельного кода. Parallel имеет ряд методов, которые позволяют
распараллеливать задачу. 
	Метод Parallel.Invoke в качестве параметра принимает массив объектов Action, т.е можно передать в данный метод несколько
методов, которые будут выполняться параллельно при его вызове. Можно передать либо название метода, либо лямбда-выражение. И таким
образом, при наличии нескольких ядер на целевой машине данные методы будут выполняться параллельно на различных ядрах.
	Метод Parallel.For позволяет выполнять цикла параллельно. Он принимает три параметра: начальное значение, конечное значение и
делегат, который будет вызываться для каждой итерации цикла.
	Метод Parallel.ForEach осуществляет итерацию по коллекции, реализующей интерфейс IEnumerable, подобно циклу foreach, только
осуществляет параллельное выполнение перебора. Он принимает два параметра: коллекцию, которую нужно обработать, и делегат,
который будет вызываться для каждого элемента коллекции. На выходе метод возвращает структуру ParallelLoopResult, которая
содержит информацию о выполнении цикла, а метод Break позволяет выйти из цикла.
	Методы Parallel.ForEach и Parallel.For возвращают объект ParallelLoopResult, наиболее значимыми свойствами которого являются
два следующих:
	IsCompleted: определяет, завершилось ли полное выполнение параллельного цикла
	LowestBreakIteration: возвращает индекс, на котором произошло прерывание работы цикла

##		Почему при CPU Bound лучше не использовать async-await, но можно использовать Parallel.For(), Task.Run()?
	Ответ на этот вопрос зависит от того, какие ресурсы наиболее интенсивно используются:
	 - если CPU, то лучше использовать Task.Run(), Parallel.For() и т. д.;
	 - а если I/O (диск, сеть, внешние устройства), то async/await.
	Parallel.For(), Task.Run() и схожие с ними методы берут свободный поток для каждой запускаемой задачи. А т.к число 
одновременно выполняемых потоков конечно, то в случае с активным использованием I/O операций, в какой-то момент, новые задачи 
будут ждать завершения уже запущенных. При этом CPU практически не нагружен и простаивает. Т. е. не смотря на наличие
ресурсов, часть I/O операций будет отложена.
Указанная выше проблема не актуальна в случае потоков, интенсивно использующих CPU. В этой ситуации процессор будет постоянно 
загружен работой и простоя не будет.
	Пара async/await работает по другому. По своей сути это конечный автомат, который позволяет во время ожидания использовать
тот же самый поток для следующей в списке задачи. Таким образом, используя небольшое число потоков можно инициировать большее
число I/O операций и ожидать их завершения. При этом свободные потоки смогут продолжать обслуживать другие задачи приложения.

#		Дилеммы разработчиков:
##		Базовый класс или интерфейс?
	Любой тип может наследовать только одну реализацию, но если нужно реализовать подобие множественного наследования или 
слабосвязанное, гибкое приложение, например, DI контейнер или MOCK-объект, а так же значимые типы не могут наследоваться от 
произвольного базового класса, то в этом случае нужно определять интерфейс.
	Иногда проще определить новый тип, производный от базового, чем создать интерфейс. Базовый тип может предоставлять массу
функций, и в производном типе потребуется внести лишь незначительные изменения, чтобы изменить его поведение. При создании
интерфейса в новом типе придется реализовывать все члены.
	Управление версиями. 
	Когда вы добавляете метод к базовому типу, производный тип наследует стандартную реализацию этого метода без всяких затрат. 
Пользовательский исходный код даже не нужно перекомпилировать. Добавление нового члена к интерфейсу требует изменения 
пользовательского исходного кода и его перекомпиляции. Для интерфейса придется менять и добавлять реализацию в каждого наследника,
а следовательно, и перекомпилировать. Особенно сильно это влияет, если меняется интерфейс в библиотеке, которая используется в
различных проектах. Для базового класса — такой проблемы нет. Наследники просто принимают изменения базового типа и их даже не
нужно перекомпилировать.

##		Абстрактный класс или интерфейс?
	Рассказать про абстрактный класс. Когда следует использовать абстрактные классы:
	Если надо определить общий функционал для родственных объектов, чтобы все производные классы на всех уровнях наследования
имели некоторую общую реализацию. 
	При использовании абстрактных классов, если мы захотим изменить базовый функционал во всех наследниках, то достаточно поменять
его в абстрактном базовом классе. А в случае с интерфейсом, придется вносить изменения и также во всех классах, которые данный
интерфейс реализуют.
	Абстрактные классы можно комбинировать вместе c интерфейсами т.к абстрактный класс может наследоваться от интерфейсов.
	Когда следует использовать интерфейсы:
	Если нам надо определить функционал для группы разрозненных объектов, которые могут быть никак не связаны между собой.
	В новой версии С# можно добавить реализацию методам и свойствам по умолчанию, но из-за того, что в интерфейс не поддерживает
экземплярные поля, а только статические поля и константы, то мы не сможем управлять состоянием объекта по сравнению с классами.
Но преимуществом является, то что это позволяет добавить совместимость с такими языками как Java, где уже есть подобная реализация,
а также сохраняет обратную совместимость на уровне сборки т.е если мы добавим в интерфейс новый метод, то нужно будет его реализовать,
но если мы добавим реализацию по умолчанию, то этот интерфейсный метод не обязательно будет реализовывать.
	Допустим, у нас есть система транспортных средств: легковой автомобиль, автобус, трамвай, поезд. Поскольку данные объекты 
являются родственными, мы можем выделить у них общие признаки, то в данном случае можно использовать абстрактный класс, например,
Vehicle, который определяет абстрактный метод перемещения Move(), а классы-наследники его реализуют, но если объекты малосвязанные
между собой, то для определения общего для всех них функционала лучше определить интерфейс.
	Говоря об использовании абстрактных классов и интерфейсов можно привести еще такую аналогию, как состояние и действие. 
Как правило, абстрактные классы фокусируются на общем состоянии классов-наследников. В то время как интерфейсы строятся вокруг
какого-либо общего действия.

##		Статический класс или singleton
	Singleton является более гибким по сравнению со статическим классом по скольку является объектом соответственно его можно
передавать как параметр, реализовывать интерфейсы, наследоваться, сериализовать/десериализовать а также можно управлять временем 
жизни. Статический класс используется для логической группировки схожих методов, констант, полей и свойств, а также может создавать
статические методы расширения

##		Событие или делегат
	События — это члены типа, который позволяет типу регистрировать и отменять регистрацию на событие, и поле-делегат для 
управления набором зарегистрированных методов и получения уведомлений на которые он подписался.
	Событие не может возвращать значения и вызывается только из типа в котором было объявлено, можно объявить в интерфейсе, а так же 
всегда объявляется как public поле, а не свойство используются для уведомления об изменениях в объекте
	Делегат (delegates) - функциями обратного вызова, которая обеспечивает безопасность типов при выполнении обратного вызова
методов, а так же позволяют последовательно вызывать несколько методов. Он делегирует свою работу внешнему коду, вызывая методы
других объектов, и может быть параметром в методе или возвращаемым значением.

##		Лямбда или делегат
	Лямбды - это специальный синтаксис для сокращённого объявления анонимных методов(делегатов) или деревьев выражений. Слева от
лямбда оператора стоят параметры ввода, справа от лямбда оператора => выражение. В лямбда-выражениях можно использовать внешние
переменные. В отличие от делегатов их можно напрямую назначать в правой части при регистрации событий, а также в различных
предложениях и методах LINQ.

#		Сложность алгоритма, О большое. Сравнение сложности, Пространственная сложность
	Сложность алгоритма - это сколько времени и ресурсов, необходимых для его выполнения, в зависимости от размера входных данных,
а О большое является инструментом анализа сложности алгоритма, но когда говорят о Большом O, на самом деле имеется ввиду Тета (Θ
Theta). Пространственная сложность связана с тем, сколько памяти будет использовать программа. Например функция O (n²) описывает,
что n - представляет размер входных данных, а функция внутри скобок дает представление насколько сложен алгоритм.
	О большое (O()) описывает верхнюю границу сложности.
	Малое O (o()) описывает верхнюю границу, исключая точную оценку.
	Омега (Ω ()) описывает нижнюю границу сложности.
	Тета (Θ ()) описывает точную оценку сложности.
	Порядок сложностей: O(1), O(log(n)), O(n), n*log(n), O(n²), O(n³), O(1.1^n), O(2^n), Факториалы, Умножение

#		Интерфейсы структуры данных и их интерфейсы
##		IEnumerable, ICollection.
	IEnumerable<T> - это базовый интерфейс для всех коллекций, который осуществляет итерацию, для этого нужно реализовать метод
GetEnumerator, благодаря которому коллекции доступна конструкция foreach. С IEnumerable часто используются расширения из Linq. 
	ICollection<T> - это интерфейс, который дает возможность изменять коллекцию и узнать ее размер. Он наследуется от IEnumerable 

##		IEnumerable vs IQueryable
	IQueryable в отличии от IEnumerable – IQueryable предлагает высокую производительность в случае работы с большим объемом
данных. IQueryable предварительно фильтрует данные по запросу а затем отправляет только отфильтрованные данные клиенту.
	Основное отличие между этими интерфейсами в том, что IEnumerable работает со всем массивом данных, а IQueryable с
отфильтрованным. IEnumerable получает все данные на стороне сервера и загружает их в память а затем позволяет сделать фильтрацию
по данным из памяти. Когда делается запрос к базе данных, IQueryable выполняет запрос на серверной стороне и в запросе применяет
фильтрацию. 

##		IList, ISet и IDictionary.
	Интерфейс IList<T> - наследуется от IEnumerable, ICollection и добавляет возможность получить доступ к элементами коллекции
по их индексу.
	Интерфейс ISet<T> - наследуется от обобщенных версий IEnumerable, ICollection и хранит набор уникальных элементов.
	IDictionary<TKey, TValue> - наследуется от обобщенных версий IEnumerable<T>, ICollection<T>, он использует
KeyValuePair<TKey, TValue> в качестве аргумента типа. Он предназначен для хранения пар ключ-значение вместо отдельных значений.
	Queue и Stack - не реализуют ни один из специализированных интерфейсов, полученных из интерфейса ICollection<T>. Класс Queue<T>
реализует принцип FIFO (first in, first out) - первым пришел, первым вышел, а класс Stack<T> реализует принцип LIFO - последний
пришел, первый вышел. Единственный элемент, который непосредственно доступен в этой коллекции - это тот, который был добавлен
совсем недавно.

##		Concurrent Collections, Immutable Collections.
	Concurrent Collections  они предоставляют поточно-ориентированные реализации интерфейсов коллекции. Классы concurrent
коллекции можно безопасно использовать в многопоточных приложениях.
	Immutable Collections Immutable (неизменяемые) коллекции не включены в библиотеку базовых классов. Чтобы использовать их
в проекте должен быть установлен пакет NuGet System.Collections.Immutable. Вместо использования синхронизирующих блокировок,
как это делают параллельные коллекции, неизменяемые коллекции не могут быть изменены после их создания. Это автоматически
делает их безопасными для использования в многопоточных сценариях.

##		Массивы
	Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию. Базовым для всех 
массивов является абстрактный класс System.Array, производный от System.Object и являются ссылочным типом и размещаются в
управляемой куче, а переменная в приложении содержит не элементы массива, а ссылку на массив.
	Сложность: По индексу O(1), поиск O(n)
	Поддерживаются массивы:
    Одномерные (single-dimension) [] SZ-массивы или векторами - одномерный массив с нулевым начальным индексом;
    Многомерные (multidimension) [,] или больше [,,];
    Нерегулярные (jagged) массивы массивов [][].
	По возможности нужно ограничиваться одномерными массивами с нулевым начальным индексом, которые называют векторами, поскольку
векторы обеспечивают наилучшую производительность, т.к для операций с ними используются команды промежуточного языка (IL).
	Производительность одномерного массива с нулевой нижней границей выше чем многомерных массивов или массивов с ненулевой нижней 
границей поскольку есть специальные команды для работы ним, которые позволяют JIT-компилятору генерировать оптимизированный код.
А благодаря тому, что первый индекс равен нулю, отсутствует необходимость вычислять смещение на каждой итерации.
	У многомерных массивов есть ранг т.е количество измерений. Доступ к элементам осуществляется посредством двух и более индексов
		Double[,] myDoubles = new Double[10, 20]; // Создание двухмерного массива типа Doubles
	Нерегулярные (jagged) массивы — то есть «массивы массивов». Производительность одномерных нерегулярных массивов с нулевым 
начальным индексом такая же, как у обычных векторов. Однако обращение к элементу нерегулярного массива означает обращение к двум
или больше массивам одновременно. Point[][] myPolygons = new Point[3][] // Создание одномерного массива из массивов типа Point
	Чтобы привести массив к другому, оба типа массивов должны иметь одинаковую размерность.
	Недостатки простого массива являются, если вам нужно неизменное количество объектов, то массив вполне подходит. Но если 
нужно добавить в массив ещё один элемент, то в простом массиве этого сделать невозможно. Или если нужно удалить элемент из 
массива. В простом массиве это так же невозможно. Т.к вы привязаны к одному количеству элементов. 

###		Динамический массив List. List vs Array, Count vs Capacity.
	Динамический массив — это массив, который может менять свой размер. В основе List лежит Array, но он имеет два дополнительных
блока данных Count и Capacity. В них хранятся действительный размер простого массива и объём данных, который может на самом деле
храниться в простом массиве.
	Сложность: По индексу O(1), поиск элемента по значению O(n), вставка в конец O(1) и середину O(n) т.к нужно сдвигать данные.
	Динамический массив не подходит, если массив очень велик, а нужно часто добавлять и удалять объекты, при этом объекты могут
часто копироваться в другие места, из-за этого многие указатели становиться недействительными. Поэтому если нужно часто вносить
изменения в середину динамического массива, то для этого есть более подходящий тип линейной структуры данных
	Также можно получить утечку памяти дело в том, что при увеличении массива растёт его Capacity, но методы Clear, Remove не
уменьшает размер Capacity соответственно при очистке массива мы не уменьшаем его реальный зарезервированный объём памяти. В 
таком случае лучше использовать присвоение новой ссылки List = new List;
	List<KeyValuePair> 						vs 						Dictionary<T Key, T Value>
	1. Lighter														1. Heavy
	2. Insertion is faster in List									2. Insertion is slower. Has to compute Hash
	3. Searching is slower than Dictionary							3. Searching is faster because of Hash.
	4. This can be serialized to XMLSerializer						4. Can't be serialized. Custom code is required.
	5. Changing the key,value is not possible. Keyvaluepair can 	5. You can change and update dictionary.
be assigned value only during creation. If you want to change 
then remove and add new item in same place.

##		Linked List. Преимущества и недостатки.
	Связный список (Linked List) состоит из связанных узлов, каждый из которых содержит данные и ссылку на следующий узел. Он
он оптимизирован для вставки и удаления, но медленно работает при индексировании и поиске.
	Для хранения данных предназначено свойство Data. 
	Для ссылки на следующий узел определено свойство Next.
Методы:
	AddLast - добавление элемента в конец списка:
		При помощи tail(хвост) - указывает всегда на последний элемент списка. Сложность O(1) 
		Без помощи tail(хвост) - 					Сложность O(n)
	AddFirst - добавление элемента в начало списка.	Сложность О(1)
	Remove - удаление элемента. 					Сложность O(n)
	Contains - для проверки наличия элемента. 		Сложность O(n)
	Clear - удаляет все ссылки;
	IEnumerable - можно реализовать, чтобы список можно было бы перебрать во внешней программе 	с помощью цикла foreach.

###		Двусвязный список, Кольцевой односвязный список, Кольцевой двусвязный список	
	Двусвязные списки также представляют последовательность связанных узлов, однако теперь каждый узел хранит ссылку на следующий
и на предыдущий элементы.
	Кольцевой односвязный список - это связный список, но его условный последний элемент хранит ссылку на первый элемент, поэтому
список получается замкнутым или кольцевым.
	Кольцевой двусвязный список - это кольцевой список, но каждый элемент списка содержит указатель на предыдущий и следующий
элемент.

##		Stack, Queue, Dequeue, PriorityQueue
	Стек представляет собой структуру данных, которая работает по принципу LIFO (Last In First Out - "последний пришел -
первый вышел"). При добавлении и удалении из стека последний добавленный элемент будет первым удаляемым.
Для стека нужно всего три метода: 
	Push добавляет объект в стек O(1)
	Pop удаляет объект из стека O(1)
	Top даёт самый последний объект в стеке. O(1)
	
	Очередь представляет собой структуру данных, которая работает по принципу FIFO (First In First Out, «первым зашёл,
первым вышел»).	При добавлении и удалении из очереди первый добавляемый элемент будет первым извлекаемым. 
Очереди нужно четыре метода: 
	Push_Back добавляет элемент к концу очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.

	Двухсторонней очередь, если часто нужно добавлять или удалять элементы из обоих концов очереди. 
	Push_Back добавляет элемент к концу очереди;
	Push_Front добавляет элемент в начало очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Pop_Back удаляет элемент из конца очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	
	Очередь с приоритетом очень похожа на обычную очередь. Программа добавляет элементы с конца и извлекает элементы из
начала. Разница в том, что можно задавать приоритеты определённым элементам очереди. Все самые важные элементы
обрабатываются в порядке FIFO. Потом в порядке FIFO обрабатываются элементы с более низким приоритетом. 
	И так повторяется, пока не будут обработаны в порядке FIFO элементы с самым низким приоритетом.

	Стеки, очереди, двухсторонние очереди и очереди с приоритетом можно реализовать на основе других структур данных.
Это не фундаментальные структуры данных, но их часто используют. Они очень эффективны, когда нужно работать только с
конечными элементами данных, а серединные элементы не важны.
	НЕДОСТАТКИ 	Видимо зависят от на какой структуре данных они были реализованы, но это не точно)

##		Binary Heap, Binary Search Tree, АВЛ-дерева, Обходы дерева, Балансировка узлов
    Двоичная куча - binary heap - представляет собой полное бинарное дерево, т.е у каждого узла не более двух потомков,
а так же все уровни полностью заняты данными, новый элемент добавляется на последнее место на позицию слева на право т.е с
индексом heapSize. Возможно, что при этом будет нарушено основное свойство кучи, так как новый элемент может быть больше
родителя. В таком случае следует «поднимать» новый элемент на один уровень (менять с вершиной-родителем) до тех пор, пока
не будет соблюдено основное свойство кучи: Двоичная куча может быть минимальной или максимальной: 
    В максимальной куче ключ любого узла всегда больше ключей его потомков или равен им; 
    В минимальной куче ключ любого узла меньше ключей его потомков или равен им.
    Для чтения элемента с самым высоким приоритетом О(1);
    Для добавления и извлечения элементов О(log(n));
    Сортировка O(nLog(n)).
    Max - получение максимального элемента О(1);
    DelMax - удаление максимального элемента О(log(n)) - т.к. нужно делать балансировку;
    Add - добавление элемента О(log(n)) - т.к. нужно делать балансировку.
Балансировка:
    Заключается в выполнении Swap корневого элемента с узловым и так далее рекурсивно до самой вершины, до тех пор пока
родительский элемент не будет больше чем потомки.
Удаление:
    После удаления элемента вместо него переносится самый крайний добавленный элемент, далее этот элемент балансируется
с потомками, если нужно.
Добавление элемента
	Новый элемент добавляется на последнее место в массиве, то есть позицию с индексом heapSize, но может потребоваться
балансировка.
Формулы:
    Левый потом: 2i+1; Правый потомок 2i+2; Предок (i-1)/2.
    Благодаря этим формулам можно легко древовидный вид преобразовать в линейный и реализовать на массиве, чтобы получать
быстрый доступ к элементам.

	Двоичное дерево поиска
    Каждый узел имеет до двух дочерних узлов (потомков). При этом каждый узел больше своих потомков слева, но меньше своих
потомков слева или равен им.
    Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой
операции пропорционально логарифму общего числа элементов в дереве.
Сложность:
    Search    O(log n);
    Insert    O(log n);
    Delete    O(log n).
Элементы, не имеющие потомков, называются листьями. А тот, что не имеет предка — корнем. 

    АВЛ-дерево — это прежде всего двоичное дерево поиска, ключи которого удовлетворяют стандартному свойствам бинарного
дерева, но особенностью АВЛ-дерева является то, что оно является сбалансированным в следующем смысле: 
    для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу. 

	Обходы дерева:
    Префиксный: - Для копирования дерева с сохранением позиций элементов.
        1 - текущий элемент; 2 - левый элемент; 3 - правый элемент.
    Постфиксный: - При удалении элементов дерева.
        1 - левый элемент; 2 - правый элемент; 3 - текущий элемент.
    Инфиксный: - Возвращает отсортированное дерево.
        1 - левый элемент; 2 - текущий элемент; 3 - правый элемент.
        
	Балансировка узлов
    В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение ситуации, когда balance factor некоторых
узлов оказывается равными 2 или -2, т.е. возникает разбалансировка поддерева.
    Выполняется левый или правый поворот. 
                y           x
            x      c     a    y
        a     b            b   c
    Большой поворот применяется при условии h(s)>h(D) и сводится к двум простым — сначала правый поворот вокруг q и затем 
левый вокруг p.

##		Hashtable, Hashset, Хэш-функция, Dictionary, коллизия
	Hashtable - представляет собой структуру данных, коротая хранит разный тип данных в виде пар ключ-значение. Хэш функция на
основе полученного ключа высчитывает число, которое используется как индекс. Преимущество хеширования заключается в том, что оно
обеспечивает временную сложность от O(1) независимо от размера структуры для операций поиска, извлечения и добавления значений.
	При добавлении данных в хэш-таблицу нельзя добавлять данные с одинаковым ключом, а также ключ не может быть равен null, 
но value может быть и одинаковые value, но с разным ключом.
		Hashtable openWith = new Hashtable();
		openWith.Add("txt", "notepad.exe");
		openWith.Add(1, "notepad.exe"); // разный тип данных и ключей
	Хэш-функция должна выдавать один и тот же результат при подаче одинакового значения. Так же она должна равномерно 
распределять значения по все области значений и чем быстрее будет вычислять значение тем лучше.
	Хэш-коллизиями называются ситуации, когда для двух разных ключей функция возвращает одинаковое число. В хэш-таблицах
для борьбы с коллизией создается отдельный контейнер под этот хэш, в который помещаются ключи, но в таком случае сложность
увеличивается до O(n)
	Hashset и dictionary разрешают конфликт с коллизией по-другому, а именно для одинаковых хэшей не создается отдельная
таблица, а просто заполняется ближайший следующий элемент в этой же таблице.
	Тип, используемый в качестве ключа, должен переопределять методы GetHashCode() и Equals(). Поскольку разные объекты могут
возвращать один и тот же хеш-код, поэтому метод Equals() используется при сравнении ключей словаря. Словарь проверяет два ключа А
и В на эквивалентность, вызывая A.Equals(В).

	HashSet<T> предоставляет собой структуру данных, в основе которой лежит Hashtable, но хранит только уникальные элементы одного
типа. Временная сложность операций поиска, удаления и вставки от O(1).
		HashSet<int> numbers = new HashSet<int>();
		numbers.Add(1);

	Dictionary представляет собой структуру данных, в основе которой лежит Hashtable, данные хранятся в виде пар ключ-значение, но
в отличии от нее Dictionary нужно типизировать при инициализации. Временная сложность операций поиска, удаления и вставки от O(1).
		Dictionary<int, string> people = new Dictionary<int, string>();

##		SortedList, SortedSet, SortedDictionary
	SortedList<TKey, TValue> предоставляет собой структуру данных, в основе которой лежит массив, но все элементы отсортированы на
основе ключа. Использует бинарный поиск для поддержания сортировки и поиска элементов. Ключи могут повторяться.
	SortedSet<T> предоставляет собой структуру данных, в основе которой лежит красно черное дерево, но хранит только уникальные
элементы одного типа в упорядоченном порядке.
	Класс SortedDictionary<TKey, Tvalue> предоставляет собой структуру данных, в основе которой лежит красно черное дерево, но все
элементы отсортированы на основе ключа. Нельзя добавлять данные с одинаковым ключом.

	SortedList ключи могут повторяться и использует меньше памяти, чем SortedDictionary и SortedSet, но они быстрее вставляет и
удаляет элементы, но поиск одинаковый O(log2(n)).
	 								Вставка			Удаление 		Поиска элемента
	SortedList<TKey, TValue>		O(n)			O(n)			O(log2(n))
	SortedDictionary<TKey, TValue>	O(log2(n))		O(log2(n))		O(log2(n))
	SortedSet<T>					O(log2(n))		O(log2(n))		O(log2(n))

#		Что такое LINQ. Как реализованы основные методы Linq под капотом. С какими коллекциями можно использовать Linq?
	LINQ(Language-Integrated Query) - это язык запросов к различным типам источников данных, которые поддерживают интерфейс
IEnumerable<T> или IQueryable<T>, например, коллекций иля для обращения к базе данных SQL
	Запросы в LINQ состоят из трех действий: источник данных, запрос и выполнение запроса. Это важно понимать поскольку выполнение
запроса откладывается, пока переменная запроса не будет обработана в операторе foreach или вызвана явно при помощи методов ToList,
ToArray или методами Count, Max, Average и First. 
	LINQ поддерживает два вида синтаксиса, которые можно комбинировать вместе: синтаксис запросов и синтаксис методов
		var res = from n in MyArray
          where n > 0
          select n;
	IEnumerable<int> numQuery2 = numbers.Where(num => num % 2 == 0).OrderBy(n => n);
	Методы Linq реализованы как методы расширяющие поэтом легко можно добавить собственные, большинство из методов принимает в
параметр лямбда-выражение или делегат.
Шпаргалка по LINQ и SQL - https://bool.dev/blog/detail/shpargalka-po-linq-i-sql
Объяснение методов LINQ с помощью изображений -  https://bool.dev/blog/detail/obyasnenie-metodov-linq-v-net-s-pomoshchyu-kartinok

#		Как работает сравнение типов через ReferenceEquals, Equals и == в Reference Type и Value Type через Equals.
	В ссылочных типах ReferenceEquals, Equals и == сравнивают ссылки на объекты в куче и возвращает true, если ссылки равны, но
Equals и == можно переопределить, чтобы сравнивать по значению. За стандартной реализацией Equals скрывается вызов ReferenceEquals.
Статический метод Equals(Object objA, Object objB) - сначала проверяет ссылки объектов используя ==, далее каждый объект на null и
и вызывает стандартный виртуальный метод a.Equals(b).
		var obj1 = new TestClass { Count = 2};
		var obj2 = new TestClass { Count = 2};
		Console.WriteLine(obj1 == obj2); 		false
		Console.WriteLine(obj1.Equals(obj2)); 	false - Equals не переопределен.
		Console.WriteLine(object.ReferenceEquals(obj1, obj2));	false
		Console.WriteLine(obj1.Equals(obj2)); 	true - Equals переопределен.
	В значимых типах Equals и == сравнивают объекты по значению, но если структура содержит поля, которые являются ссылочными
типами, следует их переопределить, а также GetHashCode, поскольку это может повысить производительность.

##		Правила реализации метода Equals, оператора равенства (==) и IComparable. Пример реализации метода Equals(Object)
	При реализации оператора равенства (==) или интерфейса IComparable, следует реализовать метод Equals, но при реализации
IComparable также рекомендуется реализовать перегрузку операторов ==, !=, < и >
	Реализовав метод Equals следует реализовать GetHashCode.
	Не вызывайте исключения из методов Equals и GetHashCode или оператора равенства (==).
	Пример реализации метода Equals(Object):
	- Проверить объект на null и сравнить типы объектов;
	- Произвести явное приведение к типу текущего класса и сравнить его поля с соответствующими полями входного объекта.

##		Сравнение с помощью вспомогательных классов и интерфейсов IComparable, IComparer, IEqualityComparer 
	IComparable - сравнивает объекты между собой для сортировки и возвращает число, которое указывает, что объект больше, меньше
или равен текущему объекту.
	IComparer - предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения, в зависимости от результата
сравнения, но в отличии IComparable мы можем создать несколько классов с разными правилами сортировки.
	Array.Sort(people, new AgeComparer()) или Array.Sort(people, new WeighComparer()) и тд, а не просто Array.Sort(people)
	IEqualityComparer - этот интерфейс позволяет реализовать настраиваемое сравнение на равенство для классов коллекций, но
рекомендуется использовать не интерфейс, а класс EqualityComparer. Сравнение используется, например если мы хотим добавить объект
выступающим в роле ключа коллекции Hashtable или Dictionary<K, V>, а также некоторые LINQ-методы.

#		Что такое ООП, принципы ООП. Инкапсуляция, наследование, абстракция и полиморфизм. Агрегация, композиция, ассоциация.
	ООП(Объектно ориентированное программирование) - это принцип программирования, основанный на представлении программы в 
виде совокупности объектов, каждый из которых является классом, а классы образуют иерархию наследования. Принципы ООП:
	Инкапсуляция — это механизм языка, который связывает код и данные вместе и сохраняет их в безопасном месте как от внешнего
вмешательства, так и от неправильного использования данных. В C# для инкапсуляции используются публичные свойства и методы объекта.
Поля, за редким исключением, не должны быть публичными.
	Наследование - это механизм языка, который позволяет определить производный класс на основе существующего, а также наследовать
его данные и свойства. Наследование позволяет ускорить процесс разработки за счет повторного использования кода. Наследование
позволяет выстроить архитектуру типов и открывает путь к полиморфизму.
	Абстракция - это механизм языка, который позволяет описать набор ключевых свойств объекта без реализации или с частичной
реализацией.
	Полиморфизм – это механизм языка, который позволяет написать разные реализации для одного интерфейса. Возможность одних и тех
же объектов принимать разные формы. В C# полиморфизм проявляется по-разному и прибавляются несколько понятий:
	- Ad-hoc полиморфизм: перегрузка методов(overloading);
	- параметрический полиморфизм: обобщение;
	- полиморфизм подтипов: абстрактные классы и интерфейсы, соответственно, абстрактные методы, virtual, override и new, а так
же который достигается при помощи upcasting. Ну и инвариантность, ковариантность и контравариантность - тоже самое, что upcasting
и downcasting, но в обобщениях.
	new обеспечивает сокрытие, но при Upcasting позволяет вызвать метод из базового: B b = new D(); - вызовется метод из B.
	При upcasting методы, которые не описаны в родителе, недоступны.
	Агрегация - это когда в конструктор класса передаётся ссылка на существующий экземпляр класса.
	Композиция - это когда не передаем в конструктор, а создаем в нем новый объект, который будет неразрывно связан с этим объектом.
	Ассоциация - это когда создаем объект как свойство. Агрегация и композиция являются частным случаем ассоциации.
	Для хранения адресов виртуальных методов используется таблица виртуальных методов, общая для всех объектов одного класса. 
Именно поэтому конкретный виртуальный метод, который будет вызван, определяется во время выполнения - позднее связывание, а не во
время компиляции - раннее связывание.

#		Класс Stream, TextReader.
	System.IO.Stream - это абстрактный базовый класс для чтения и записи байтов в поток. Предназначен для работы с любым видом 
источником данных, например, файлом, областью памяти или сетевые сокеты:
	- FileStream - для работы с любыми файлам как с текстовыми файлами, так и с бинарными;
	- MemoryStream - для работы с памятью;
	- NetworkStream - для работы с сетевыми данными.

	System.IO.TextReader - это абстрактный базовый класс для работы с текстовыми файлами.
	- StreamReader - считывает символы из потока байтов в определенной кодировке;
	- StreamWriter - записывает символы в поток в определенной кодировке.

##		Сериализация и десериализация, зачем нужна Reflection
	Сериализация - это процесс преобразования объекта в форму, пригодную для передачи, в поток или другую структуру данных.
	Десериализация -  это процесс преобразования потока в объект. Например для передачи объекта по сети, используя HttpClient
и библиотеку Newtonsoft.Json и методы JsonConvert.SerializeObject и DeserializeObject при post и get методах соответственно.
	Чтобы объект можно было сериализовать, надо этот класс пометить атрибутом Serializable. Сериализация применяется к свойствам
и полям класса, но если мы не хотим, чтобы какое-то поле класса сериализовалось, то его нужно пометить атрибутом NonSerialized.
Атрибут Serializable автоматически не наследуется.
	Форматы сериализации используется: бинарный, SOAP или XML. Они по-разному обрабатывают приватные поля и свойства:
	- BinaryFormatter - приватные поля и свойства будут сериализованы. Сериализует данные в двоичную форму. Но не рекомендуется
использовать, поскольку он считается не безопасным;
	- SoapFormatter - приватные поля и свойства будут сериализованы;
	- XmlSerializer - приватные поля и свойства будут потеряны, чтобы этого избежать при использовании формата XML необходимо
обеспечить доступ к этим приватным полям через публичные свойства;
	- JSON (JavaScript Object Notation) - основная функциональность по работе с JSON сосредоточена в пространстве имен 
System.Text.Json, и он является быстрее чем Newtonsoft.Json.

	Рефлексия – это способность кода C# читать и использовать другой код C# во время выполнения, т.е читать типы, записанные в
файлах DLL, и выполнять логику из сторонних библиотек. Например чтение атрибутов. Для получения информации типе есть оператор
typeof, метод GetType() и статический метод Type.GetType(), а далее можно получить множество информации о типе.
	Недостаток заключается в то, что код получается громоздким и его не очень удобно читать, а так же использует большое количество
ресурсов приложение из-за чего они становятся малопроизводительным и относительно медленным.

#		Как реализовать singleton
	Проблема singleton-а заключается в том, что он не соответствует принципу SRP поскольку он управляет своим собственным
экземпляром чтобы никто не мог создать два объекта этого типа, а также в нём определённая логика. Также объект созданный как
singleton должен существовать в единственном экземпляре, но иногда может понадобиться создать еще один экземпляр соответственно
придётся исправлять большое количество кода. Поэтому лучше всего не реализовывать его самому, а использовать DI контейнер с
временем жизни singleton или использование фабрик для создания экземпляров классов. Но чтобы создать его нужно:
	1. Сделать приватный конструктор
	2. Создать и вызвать статичный метод, который проверяет есть ли уже созданный объект данного типа. 
	3. В этом методе реализовать поддержку многопоточности т.е внутри первого if создать lock, а внутри него проверить
еще раз, что бы окончательно исключить, что другой поток не сделал экземпляр и после этого создать экземпляр,
проинициализировав приватное статическое поле.
		private static LockSingleton _instance;
        private static object _syncRoot = new object();
        static LockSingleton(){}
        public static LockSingleton GetInstance()
        {
            if (_instance == null)
            {
                lock (_syncRoot)
                {
                    if (_instance == null)
                    {
                        _instance = new LockSingleton();
                    }
                }
            }
            return _instance;
        }

#		SOLID
    Single Responsibility Principle - принцип единственной обязанности. У класса должна быть только одна причина для изменения 
т.е класс должен выполнять одну единственную задачу. Весь функционал класса должен быть целостным, обладать высокой связностью.
	Open/Closed Principle - принцип открытости/закрытости. Сущности программы должны быть открыты для расширения, но закрыты для 
изменения.
	Liskov Substitution Principle- принцип подстановки Лисков. Должна быть возможность вместо базового типа подставить любой его 
наследник без изменения свойств программы. 
    Существует несколько правил, которые должны быть соблюдены для выполнения принципа подстановки Лисков. Прежде всего это 
правила контракта. - Контракт представляет собой некоторый интерфейс базового класса, который задает ряд ограничений или правил, 
и производный класс должен выполнять эти правила:
	Предусловия (Preconditions) не могут быть усилены в наследнике т.е. нельзя добавлять больше предусловий, чем это определено 
в базовом классе. Предусловия - это условия, которые находятся в самом начале метода причем предусловием могут быть только 
public свойства, поля или параметры метода. ПРИВАТНОЕ поле не может быть объектом для предусловия, так как оно не может быть 
установлено из вызывающего кода.
	Постусловия (Postconditions) не могут быть ослаблены в подклассе т.е нельзя убирать или уменьшать постусловия, которые 
определены в базовом классе. Постусловия это условия, которые стоят в самом конце метода перед вызовом return.
	Инварианты (Invariants) — все условия базового класса - также должны быть сохранены и в подклассе. Это условия например как 
поле Age, которое не должно превышать 100 как в свойстве, так и в методе. 
	В целом подтипы должны проходить все тесты, которые проходят базовые классы.
    Как правило проблема решается в общем случае с помощью абстрагирования и выделения общего функционала, который уже наследуют
классы. То есть не один из них наследуется от другого, а оба они наследуются от одного общего класса.
	Interface Segregation Principle - принцип разделения интерфейсов. Несколько специализированных интерфейсов лучше, чем один 
универсальный. Т.е универсальный интерфейс лучше разделить на несколько разных интерфейсов. В итоге разделение интерфейсов делает
систему слабосвязанной, и тем самым ее легче модифицировать и обновлять.
	Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего
уровня. И те и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от
абстракций. Служит для создания слабосвязанных сущностей, которые легко тестировать, модифицировать и обновлять.

##		IoC, DI, Способы получения зависимостей, IoC-контейнер, Преимущества DI 
	Inversion of Control (IoC) - инверсия управления — это принцип, для написания слабо связанного кода. Суть которого в том, 
что объект не сам создает свои зависимости, а зависимости для этого объекта поставляются из вне. Например, при помощи агрегации
интерфейса, абстрактного класса или базового. А IoC-контейнер поможет поставить требуемые зависимости.
    Dependency Injection (DI) - внедрение зависимостей — это одна из реализаций этого принципа. Когда зависимый класс не сам
создает экземпляры других классов, а эти экземпляры передаются ему во время инициализации, а ответственность создания этих классов
передаются на третью сторону. Существует несколько способов получения зависимостей: 
    Constructor Injection - через конструктор используется интерфейс вместо конкретного класса
	Setter, Field и Method Injection - через свойства, поле, и параметр метода;
	Так же можно, через middleware и Startup: 
		через конструктор, свойство HttpContext.RequestServices или параметр метода Invoke в компонентах middleware;
		через IServiceCollection в методе ConfigureServices в классе Startup;
		через IApplicationBuilder в методе Configure в классе Startup;
    IoC-контейнер — это какая-то библиотека, фреймворк, программа, которая позволит вам упростить и автоматизировать
написание кода с использованием данного подхода, например, в ASP.NET.CORE есть встроенный контейнер служб IServiceProvider, а
сервисы регистрируются в методе Startup.ConfigureServices.
	DI - позволяет сделать компоненты программы слабосвязанными, а всю программу в целом более гибкой, более адаптируемой и
расширяемой, а также код удобнее читать т.к не придется просматривать весь код для того, чтобы увидеть то, какие зависимости вам
нужно будет предоставить для данного компонента. Они все видны в интерфейсе.
	Регистрация групп сервисов с помощью расширения, используется для того чтобы отдельные проекты могли зарегистрировать все 
что в них есть в главном API проекте

##		Время жизни объектов во встроенном DI ASP.NET Core.
	AddTransient() - при каждом обращении к сервису, создается новый объект сервиса. Т.е если в рамках одного request будет
несколько обращений к сервису, он будет создан несколько раз. Новый экземпляр объекта предоставляется каждому контроллеру и
каждому сервису.
	AddScoped() - для каждого запроса создается свой объект сервиса. Таким образом куда будет внедрен Scoped сервис получат один
и тот же объект, на время выполнения HTTP-запроса т.е пока существует запрос так же существует и объект. Объекты  одинаковы в
пределах запроса, но различаются в разных запросах.
	AddSingleton() создает один объект для всех последующих запросов. При этом объект создается только тогда, когда он
непосредственно необходим и после создания он продолжает существовать.

##		Можно ли из сервиса с одним временем жизни вызвать другой сервис с другим временем жизни?
	Не всегда, но можно, например, нельзя передавать через конструктор scoped в singleton объекты. Например есть singleton
Middleware в который инжектируется TimeService, а в него Timer и если один из них будет scoped, то во время выполнения будет
ошибка, для выхода из этой ситуации ни TimeService, ни ITimer не должны иметь жизненный цикл Scoped. То есть это может быть
Transient или Singleton.
	Тоже самое произойдет если инжектировать через метод Invoke в middleware - scoped-объекты.

##		Другие принципы: DRY, KISS, YAGNI, DAMP, AAA и GRASP.
	Don’t Repeat Yourself/Duplication Is Evil (DRY/DIE) — одинаковый код должен быть вынесен в отдельный метод.
	Keep It Simple, Stupid! (KISS) - делай максимально простую и понятную архитектуру, применяя шаблоны проектирования и не
изобретая велосипед.​
	You Ain’t Gonna Need It (YAGNI) - не добавляй функционал, пока он не нужен.
	Descriptive And Meaningful Phrases (DAMP) - принцип написания модульных тестов таким образом, чтобы происходящее в них можно
было понять без дополнительных комментариев и документации. Достигается использованием описательных имен и допускает небольшие
нарушения принципа DRY при необходимости.
	Arrange Act Assert (AAA) - правило создания модульных тестов – задать условия (Arrange), выполнить действие (Act) и проверить
итог (Assert).
	GRASP (General Responsibility Assignment Software Patterns) - GRASP представляет из себя набор принципов, определяющих
распределение ответственностей по классам в приложении:
	Information Expert (Информационный эксперт) – класс, который владеет максимумом необходимой информации для выполнения задачи,
то он и должен быть ответственен за исполнением этой задачи. Например, т.к если Account хранит информацию о счете то именно он
должен предоставить выписку с него.
	Creator (Создатель) – классы, создающие другие классы. Это может быть фабрика, пул и т.д.
	Controller (Контроллер) – объект, который несет в себе управляющие функции, он должен отвечать за обработку входных запросов и
решает кому должен делегировать запросы на выполнение. Яркий пример, Контроллер в шаблоне MVC. 
	Low Coupling (Низкая связанность) – написание кода должно быть на основе интерфейсов и абстракций, а не конкретных реализаций.
	High Cohesion (Высокое сцепление) – методы внутри классы должны быть тесно связаны между собой. 
	Pure Fabrication (Чистая выдумка) – представляет собой классы, которые не отображают реальных объектов из предметной области
приложения. Например, сервис или, репозиторий, который будет доставать и сохранять такой объект в базу данных.
	Indirection (Посредник) – необходим для устранения сильной связанности нескольких классов. Для этого возложите ответственность
на промежуточный объект, например, при помощи паттерна медиатор. Контроллер в MVC является посредником между Model и View.
	Protected Variations (Защищенные изменения) – определите объекты, которые наиболее вероятно будут подвержены изменениям, и
примените меры, по минимизации нежелательного влияний этих изменений на остальные части приложения.
	Polymorphism (Полиморфизм) – возможность объектов с одинаковой спецификацией иметь различную реализацию. В этом контексте
принцип тесно связан с GoF паттерном strategy. Это самый яркий пример реализации полиморфизма.

#		Формы нормализации таблиц, цель нормализации.
	Цель нормализации - исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении,
редактировании и удалении кортежей(строк таблицы). Каждая следующая нормализация находится и в предыдущей форме т.е переменная
отношения находится в какой-то нормальной форме, когда она находится в предыдущей нормальной форме(чтобы не повторяться)
	Первая НФ - переменная отношения находится в первой нормальной форме, когда каждый его кортеж содержит только одно значение
для каждого из атрибутов. Другими словами в каждом поле таблицы должно быть только одно значение и не должно быть повторяющихся
строк.
	Вторая НФ - когда каждый неключевой атрибутов зависит от первичного ключа целиком, а не от какой-то его части, если, например,
он составной. Исправляется это путем декомпозиции таблицы - разделение таблицы на несколько, в которых есть свой уникальный
первичный ключ.
	Третья НФ -  все атрибуты зависят только от первичного ключа, а не от других неключевых атрибутов. Исправляется декомпозицией
таблиц.
	Нормальная форма Бойса-Кода - когда ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов. 
Соответственно, требования нормальной формы Бойса-Кода предъявляются только к таблицам, у которых первичный ключ составной.
Таблицы, у которых первичный ключ простой, и они находятся в третьей нормальной форме, автоматически находятся и в нормальной
форме Бойса-Кода.
	Четвертая Нф - когда не содержит нетривиальных многозначных зависимостей. Другими словами устраняются нетривиальные 
многозначные зависимости. Многозначная зависимость выглядит следующим образом: таблица должна иметь как минимум три столбца,
например A, B и C, при этом B и C между собой никак не связаны и не зависят друг от друга, но по отдельности зависят от A, и для
каждого значения A есть множество значений B, а также множество значений C. Соответственно нужно декомпилировать на две таблицы:
 A => B, A => C; Например, есть таблица Студент, Курс, Хобби, то таким образом, мы можем наблюдать в этой таблице нетривиальную
 многозначную зависимость Студент => Курс и Студент => Хобби.
	Пятая НФ - когда после устранения нетривиальные зависимостей можно провести декомпозиция без потерь таким образом, чтобы при
объединении декомпозированых таблиц мы получили исходную таблицу. 

##		Связи таблиц.
    Связь один к одному образуется, когда одному ключевому столбцу соответствует только один ключевой объект в другой таблице.
Например, человек и паспорт.
	Связь один-ко-многим образуется, когда записи первой таблицы соответствует несколько записей в другой таблице, но запись в
другой таблице не может иметь более одной соответствующей ей записи в исходной таблице. Например, одна команда и много игроков.
	Связь «Многие ко многим» образуется, когда нескольким записям из одной таблицы соответствует несколько записей из другой
таблицы и организовывается посредством связывающей таблицы.	Например, работник и должности, должность и работники.

#		Реляционная база данных. Система управления базами данных
	Реляционная база данных  – это набор данных, которые организованны в виде таблиц, состоящих из столбцов и строк. В каждом
столбце таблицы хранится определенный тип данных, а в каждой ячейке – значение атрибута. Каждая строка представляет собой набор
связанных значений, относящихся к одному объекту, а строка может быть помечена уникальным идентификатором, называемым первичным
ключом, или с помощью внешних ключей.
	Система управления базами данных (СУБД) — это комплекс программных средств, позволяющая создавать базы данных и манипулировать
данными в них. Например, Oracle, MySQL, MS SQL Server и тд.

##		Нереляционные базы данных NoSQL, Key-value базы данных,	Документоориентированные БД.
	Нереляционные базы данных — это база данных, которая в отличие от SQL БД не использует схему строк и столбцов. В этих базах
данных применяется модель хранения, оптимизированная под конкретные требования хранения данных. Например, данные могут храниться
как "Key-value", документы JSON и другие.
	Key-value базы данных – это тип баз данных, которые хранят данные в виде пар «ключ-значение», где ключ это идентификатором, а
значения могут быть любыми, включая JSON. Преимущества: скорость работы и гибкость. Недостатки: плохо масштабируется и неэффективна
при работе с группой записей. Примером такой БД является Redis — это база данных, размещаемая в памяти, которая используется, в
основном, в роли кеша, который снижает нагрузку центральной базы данных приложения.
	Документоориентированные БД – это тип баз данных, которые хранят данные сгруппированные по коллекциям в виде документов,
например, JSON. Документ представляет собой набор атрибутов: ключ, который генерируется автоматически, и соответствующее ему
значение. В них отсутствует схема данных, что позволяет добавлять новую информацию при этом не требуя, чтобы все остальные записи
имели одинаковую структуру. Примером такой БД является MongoDB.

##		Назовите преимущества и недостатки NoSQL
	- Проще масштабировать поддержка master-slave, shards и peer-to-peer
	- Возможность хранения больших объемов неструктурированной информации.
	- Более простые технологии запросов в NoSQL позволяют совершать меньше ошибок. 
	- Не требуется глубоких знаний SQL-запросов. Это сильно снижает входной порог для начала работы с NoSQL хранилищами.

	- Привязка к конкретной NoSQL базе, при использовании SQL, проще перейти на другую SQL базу, чем в NoSQL, если не использовать
ORM который строит все запросы за вас и поддерживает несколько NoSQL баз.
	- Отсутствие схемы, а значит никто не гарантирует, что каждый разработчик не будет менять "архитектуру хранилища" как ему
вздумается.
	- Слабая поддержка транзакций на уровне БД (MongoDB к примеру с 4.0 уже поддерживает транзакции)

##		Структура реляционных баз данных.
	В реляционных базах данных информация хранится в связанных друг с другом таблицах, состоящих из столбцов и строк. Каждый
столбец таблицы хранит определенный тип данных, а в каждой ячейке – значение атрибута. Каждая строка представляет собой набор
связанных значений, относящихся к одному объекту, а строка может быть помечена уникальным идентификатором, называемым первичным
ключом, составным ключом, или с помощью внешних ключей, который ссылается на первичный ключ другой таблицы.
	Индексы используются для ускорения выполнения запросов к базе данных, позволяя быстро находить и извлекать данные.
	Триггеры - это автоматические выполняемые функции, например, при вставке, обновлении или удалении данных в таблице.
	Views - виртуальные таблицы, содержащие запросы, которые динамически извлекают используемые данные. Они упрощают SQL-операции, 
защищают данные, так как представления могут дать доступ к части таблицы, а не ко всей таблице. И позволяют возвращать
отформатированные значения из таблиц в нужной и удобной форме.

##		SQL, Транзакции(ACID). Проблемы параллельного доступа с использованием транзакций.
	SQL (Structured Query Language) – основной язык для работы с реляционными базами данных, который используется для добавления, 
обновления, удаления и извлечения наборов данных, а также для управления всеми аспектами работы базы данных.
	Транзакции – это один или несколько операторов SQL, выполненных в виде последовательности операций, и должны соответствовать
принципам ACID, то есть быть атомарными(Atomicity), согласованными(Consistency), изолированными(Isolation) и надежными(Durability),
а именно транзакция должна полностью выполнена иначе все изменения должны быть отменены; Транзакция должна выполнять все правила
и ограничениям, а данные после выполнения транзакции должны оставаться в согласованном состоянии, например, если в одном месте
произойдет списание, но в другом месте не будет зачисления, то данные останутся не в согласованном состояние; Изолированность -
транзакции выполняемые параллельно не должны влиять друг на друга; Надежность - все успешные изменения внесенные в базу данных
считаются постоянными и доступными даже в случае сбоя системы.
	При параллельном выполнении транзакций возможны следующие аномалии (проблемы):
	- потерянное обновление (lost update) — при одновременном изменении одного блока данных разными транзакциями теряются все
изменения, кроме последнего;
	- «грязное» чтение (dirty read) — чтение данных транзакции, которая впоследствии не подтвердится и откатится;
	- неповторяющееся чтение (non-repeatable read) — прочтенные данные в рамках одной и той же транзакции оказываются измененными;
	- фантомное чтение (phantom reads) — первая транзакция несколько раз читает строки по одним и тем же параметрам, а вторая
транзакция между чтением первой транзакции добавляет или изменяет эти данные, в результате появляются новые фантомные данные.

##		Уровни изоляции транзакций. Optimistic and pessimistic lock.
	Уровни изоляции транзакций - это степень защиты обеспечиваемой внутренними механизмами СУБД от всех или некоторых видов
несогласованности данных, возникающих при параллельном выполнении транзакций. В стандарте SQL-92 определено четыре уровня изоляции:
Read uncommitted, Read committed, Repeatable read и Serializable. Первый из них является самым слабым, последний — самым сильным,
каждый последующий включает в себя все предыдущие:
	- Read uncommitted (чтение незафиксированных данных) - защищает от lost update, но не от dirty read т.к каждая транзакция видит
незафиксированные изменения другой транзакции;
	- Read committed (чтение фиксированных данных) - защищает от dirty read т.к транзакции видят только зафиксированные изменения
из других транзакций. Большинство СУБД, по умолчанию используют именно этот уровень;
	- Repeatable read (повторяющееся чтение) - защищает от non-repeatable read, но не от phantom reads т.к. вторая транзакция не
может изменять данные, читаемые первой транзакцией, пока та не окончена, но может вставлять новые строки.
	- Serializable (упорядочиваемость) - защищает от phantom reads т.к. транзакции полностью изолируются друг от друга.
	Оптимистическая и пессимистическая блокировка (optimistic and pessimistic lock) - это два основных подхода к управлению
параллельным доступом к базе данных:
	- Оптимистическая блокировка - перед выполнением изменений в БД, транзакция проверяет, не были ли данные изменены другой
транзакцией, которые она собирается изменить, если нет, то транзакция может продолжить выполнение иначе, транзакция может
откатиться или предпринять другие действия для устранения конфликта.
	- Пессимистическая блокировка - перед выполнением изменений в БД, транзакция запрашивает блокировку на ресурс, который она
собирается изменить. Если ресурс заблокирован другой транзакцией, текущая транзакция будет ждать, пока ресурс не станет доступным.
Это может привести к замедлению работы системы в случае большого количества конкурирующих транзакций.

##		Команды: COMMIT, ROLLBACK, SAVEPOINT, LOCK TABLE, SET TRANSACTION, SET SESSION CHARACTERISTICS
	- SET TRANSACTION устанавливает характеристики текущей транзакции, например, уровень изоляции, режим доступа транзакции(чтение
или запись, или только чтение );
	- SET SESSION CHARACTERISTICS в отличии от SET TRANSACTION устанавливает характеристики транзакция в рамках сеанса, но SET 
TRANSACTION может их переопределить;
	- COMMIT - фиксирует все изменения, внесенные транзакцией в БД. После выполнения COMMIT изменения становятся видимыми другим
сеансам или пользователям.
	- ROLLBACK - отменяет полностью или частично изменения текущей транзакцией.
	- SAVEPOINT - устанавливает точку сохранения, к которой можно выполнить откат данных.
	- LOCK TABLE - блокирует всю таблицу в указанном режиме и запрещает или разрешает изменение данных другим транзакциям на то
время, пока вы с ней работаете.

#		Базовый синтаксис Select, оператор Select, AS, функции
	Select - это оператор, который позволяет получить данные из таблиц, а также и литералы: SELECT "Hello world"
	Перечисляя названия столбцов через запятую позволяет вывести информацию только по определённым столбцам таблицы, а не всю 
таблицу целиком: SELECT member_id, member_name FROM FamilyMembers
	* - используется для вывода всех полей из таблицы: SELECT * FROM FamilyMembers
	Оператор AS - это псевдоним, который позволяет переименовать столбец: SELECT member_name AS Name FROM FamilyMembers
	Литерал — это указанное явным образом значение, например, число 12 или строка "SQL".
	
	При составлении SQL запросов можно использовать встроенные функции. Например:
	UPPER - выводит строку в верхнем регистре:	SELECT UPPER("Hello world") AS upper_string;
	LOWER - выводит строку в нижнем регистре:	SELECT LOWER('SQL Academy') AS lower_string;
	YEAR - возвращает год для указанной даты:	SELECT YEAR("2022-06-16") AS year;
	INSTR - выполняет поиск подстроки в строке, возвращая позицию её первого символа:
												SELECT INSTR('sql-academy', 'academy') AS idx;
	LENGTH - возвращает длину указанной строки: SELECT LENGTH('sql-academy') AS str_length;
	LEFT - возвращает заданное количество крайних левых символов строки:
												LEFT(str, number_of_characters)
	TIMESTAMPDIFF(second, time_out, time_in), чтобы получить разницу во времени, например, в секундах между двумя датами.
	Если нужно получить первые три буквы и преобразовать их в заглавные, то используем функции LEFT и UPPER, где результат одной
функции будет аргументом для второй: 			SELECT UPPER(LEFT('sql-academy', 3)) AS str;

##		Исключение дубликатов, DISTINCT, WHERE, NOT, XOR, IS NULL, IS NOT NULL, BETWEEN, IN, LIKE, ESCAPE-символ
	DISTINCT - позволяет убрать из результата все повторения и может быть применено только к первому полю, а при применении
оператора к двум и более колонкам будут удаляться записи, которые имеют одинаковые значения по всем полям:
												SELECT DISTINCT 'поля_таблиц' FROM наименование_таблицы;
	Where - позволяет отфильтровать данные по определённому условию, а результатом сравнения любого значения с NULL является NULL,
но исключением является оператор эквивалентности <=>: :
			SELECT [DISTINCT] поля FROM имя_таблицы WHERE условие_на_ограничение_строк [логический_оператор другое_условие];
			SELECT * FROM Student WHERE first_name = "Grigri" AND YEAR(birthday) > 2000;
			NULL <=> NULL - получим true;
			NULL <=> 3 - false;
	NOT	- меняет значение оператора сравнения на противоположный;
	XOR	- возвращает true, если только один аргумент является истинным;
	IS NULL - позволяет узнать равно ли значение NULL, а если мы хотим найти все записи с полями не равными NULL, то нужно
использовать IS NOT NULL:						SELECT * FROM Teacher WHERE middle_name IS NULL; 		
												SELECT * FROM Teacher WHERE middle_name IS NOT NULL;

	BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами
значения min и max и эквивалентен условию: 		WHERE field >= min AND field <= max
												SELECT * FROM Payments WHERE unit_price BETWEEN 100 AND 500;
	IN - позволяет узнать входит ли проверяемое значение столбца в список определённых значений:
												SELECT * FROM FamilyMembers WHERE status IN ('father', 'mother');
	
	LIKE проверяет соответствует ли строка определенному шаблону. Шаблон может включать следующие специальные символы:
	-	% - последовательность любых символов, если символы стоят слева, то начинается; справа заканчивается, а между, то в любом 
месте строки;
	-	_ - любой единичный символ.
												WHERE поле_таблицы [NOT] LIKE шаблон_строки. 
				  SELECT name, email FROM Users WHERE email LIKE '%@hotmail.%'
	строка начнется на «begin» и заканчивающихся на «end»:
											... WHERE поле_таблицы LIKE 'begin%end';
	строка, имеющая длину 4 символа, при этом 3 последних обязательно должны быть «ext». Например, слова «text» и «next»:
											... WHERE поле_таблицы LIKE '_ext'
	ESCAPE-символ используется для экранирования специальных символов, если они являются частью строки, для этого нужно
использовать ESCAPE либо '\' перед символом. Например:
	id задач, прогресс которых равен 3%		SELECT job_id FROM Jobs WHERE progress LIKE '3!%' ESCAPE '!'; 
	имена содержат символ подчеркивания		SELECT * FROM users WHERE username LIKE '%\_%' ESCAPE '\';
	переменная содержит символ (\)			SELECT * FROM files WHERE path = 'C:\\folder\\file.txt'

##		Оператор ORDER BY, GROUP BY, Агрегатные функции, HAVING										
	ORDER BY - используется для упорядочивания записей, где ASC - сортировка по возрастанию (по умолчанию), а DESC - сортировка
по убыванию, а для сортировки результатов по двум или более столбцам их следует указывать через запятую:
	SELECT поля_таблиц FROM наименование_таблицы WHERE  ... ORDER BY столбец_1 [ASC | DESC]
														... ORDER BY столбец_1 [ASC | DESC], столбец_2 [ASC | DESC];
	GROUP BY - для группировки записей, в группы, а так же нельзя вывести любое другое поле, кроме литерала, результата
агрегатной функций и полей группировки - их может быть несколько перечисленных через запятую GROUP BY а,б,с.
	Все значения NULL считаются равными следовательно попадут в одну группу.
			SELECT [литералы, агрегатные_функции, поля_группировки] FROM имя_таблицы GROUP BY поля_группировки;
			SELECT home_type FROM Rooms GROUP BY home_type;
			SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type
	Выполненный запрос сначала разбивает все записи из таблицы Rooms на группы, опираясь на поле home_type. Далее, для каждой
группы суммирует все значения, взятые из поля price у каждой записи, входящей в текущую группу, и затем полученный результат
делится на количество записей в данной группе.

	Агрегатная функция – это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение. 
	Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT(*).
			SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type
	SUM(поле_таблицы)	Возвращает сумму значений
	AVG(поле_таблицы)	Возвращает среднее значение
	COUNT(поле_таблицы)	Возвращает количество записей
	MIN(поле_таблицы)	Возвращает минимальное значение
	MAX(поле_таблицы)	Возвращает максимальное значение

	Оператор HAVING - используется для фильтрации групп.
			SELECT home_type, AVG(price) as avg_price FROM Rooms GROUP BY home_type HAVING avg_price > 50

##		Порядок выполнения SQL запроса	
	Почему нельзя использовать WHERE и зачем нужен отдельный оператор для фильтрации групп? Все дело в порядке выполнения SQL 
запроса:
	SELECT [константы, агрегатные_функции, поля_группировки] - выбираются все столбцы в связке с from
	FROM имя_таблицы - сначала выполняется команда выборки таблиц, их объединения и возможные подзапросы под командой FROM;
	WHERE условия_на_ограничения_строк - фильтрация записей по определенным условиям;
	GROUP BY поля_группировки - формирование групп на основе записей после фильтрации;
	HAVING условие_на_ограничение_строк_после_группировки- фильтрация групп по определенным условиям;
	SELECT [константы, агрегатные_функции, поля_группировки] - Только потом применяется команда выборки столбцов SELECT, который 
возвращает результирующего набор указанных столбцов и расчет оконных функций под выборкой;
	ORDER BY условие_сортировки - сортировка полученных результатов, где тоже можно указать столбец расчета оконной функции для
сортировки. 

	Если использовать поле у образовавшихся групп ещё до их образования, то оператор WHERE можем отфильтровать записи из таблицы
до применения группировки и лишь затем выполнится агрегатная функция.

##		Виды многотабличных запросов JOIN. Внутреннее соединение INNER JOIN
	Соединение бывает: внутренним INNER (по умолчанию) и внешним OUTER, а внешнее соединение делится на левое LEFT, правое RIGHT
и полное FULL, а ON позволяет сопоставить таблицы друг другу, чтобы соединение сработало. 
			SELECT поля_таблиц FROM левая_таблица
			[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN правая_таблица
				ON условие_соединения
			[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
				ON условие_соединения]

	Внутреннее соединение INNER JOIN — это соединение, при котором находятся пары записей из двух таблиц, удовлетворяющие условию
соединения, образуя новую таблицу, которая содержит поля из первой и второй таблицы, но вместо INNER JOIN можно использовать Where.
Например соединение таблиц по общему полю good_id, в итоговую таблицу попадут записи с одинаковым значением good_id:
			FROM Payments INNER JOIN Goods ON Payments.good_id = Goods.good_id  
Соединение через оператор WHERE:
			SELECT family_member, member_name FROM Payments, FamilyMembers
			WHERE Payments.family_member = FamilyMembers.member_id

###		Внешнее соединение OUTER JOIN, Внешнее левое соединение (LEFT OUTER JOIN)
	Внешнее соединение может быть трёх типов: левое LEFT, правое RIGHT и полное FULL по умолчанию. Главным отличием внешнего
соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух таблиц (FULL).
	Внешнее левое соединение (LEFT OUTER JOIN) - это соединение, которое объединяет все значения из левой таблицы, по определенному
условию с значениями из правой таблицы, или заменяет их на NULL, если их нет.
			SELECT поля FROM левая_таблица LEFT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ 
Получение данных, относящихся только к левой таблице для этого нужно добавить WHERE правая_таблица.ключ IS NULL:
			SELECT поля FROM левая_таблица LEFT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
			WHERE правая_таблица.ключ IS NULL

###		Внешнее правое соединение (RIGHT OUTER JOIN)
	Внешнее правое соединение RIGHT OUTER JOIN - это соединение, которое объединяет все значения из правой таблицы, по определенному
условию значениями из левой таблицы, или заменяет их на NULL, если их нет.
			SELECT поля FROM левая_таблица RIGHT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
Получение данных, относящихся только к правой таблице для этого нужно добавить WHERE левая_таблица.ключ IS NULL:
			SELECT поля FROM левая_таблица RIGHT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
			WHERE левая_таблица.ключ IS NULL

###		Внешнее полное соединение (FULL OUTER JOIN)
	Внешнее полное соединение (FULL OUTER JOIN) - это соединение, которое объединяет записи двух таблиц, выполняя внутреннее
соединение и дополняет их значениями не вошедшими в результат внутреннего соединения из левой и правой таблицы, выполнив левое и
правое внешнее соединение, но они будут равны NULL. 
			SELECT поля FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
	Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно эмулировать, используя:
			LEFT JOIN => UNION ALL => RIGHT JOIN => WHERE левая_таблица.ключ IS NULL
	Получение данных, относящихся как к левой, так и к правой таблице:
			SELECT поля FROM левая_таблица INNER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
	Получение данных, не относящихся к левой и правой таблицам одновременно (обратное INNER JOIN):
			SELECT поля FROM левая_таблица FULL OUTER JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
			WHERE левая_таблица.ключ IS NULL OR правая_таблица.ключ IS NULL

##		Ограничение выборки, оператор LIMIT, TOP, OFFSET FETCH
	LIMIT - это оператор, который позволяет извлечь определенное количество записей из одной или нескольких таблиц, но если не
указать количество пропущенных записей, то их отсчёт будет вестись с начала таблицы.
			SELECT поля FROM список_таблиц LIMIT [количество_пропущенных_записей,] количество_записей_для_вывода;
Оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для
тех случаев, когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.
	Для того, чтобы вывести строки с 3 по 5, нужно использовать запрос:
			SELECT * FROM Company LIMIT 2, 3; или SELECT * FROM Company LIMIT 3 OFFSET 2;

##		Подзапросы. Подзапрос с одной строкой с одним столбцом
	Подзапрос — это запрос встроенный в другой запрос, который как и любой SQL запрос возвращает результирующий набор значений. Он
заключён в круглые скобки и обычно выполняется перед основным запросом. Подзапросы могут быть использованы в операторах SELECT, 
FROM, WHERE и других операторах. Подзапросы бывают следующих видов: одна строка и один столбец; несколько строк с одним столбцом;
несколько строк с несколькими столбцами.
	Подзапрос с одной строкой и с одним столбцом - это подзапрос, который возвращает одну запись. При использовании результата
подзапроса с операторами сравнения, важно, чтобы подзапрос возвращал именно скалярное значение иначе СУБД вернет ошибку:Subquery
returns more than 1 row». 
	Следующие запросы выводят название компании и члена семьи с определенной датой рождения:
			SELECT (SELECT name FROM company LIMIT 1) AS company_name;
			SELECT * FROM FamilyMembers WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);

###		Подзапросы с несколькими строками и одним столбцом, оператор ALL, IN, ANY 
	Подзапросы с несколькими строками и одним столбцом - это подзапрос, который возвращает несколько строк и один столбец, поэтому
его нельзя использовать с операторами сравнения. Однако его можно использовать 3 дополнительных операторами:
	- оператор ALL - вернёт TRUE, если все сравнения в наборе вернут TRUE. Например, для всех ли жилых помещений выполняется
условие, что оно дешевле чем 200:					SELECT 200 > ALL(SELECT price FROM Rooms)
	Выведите названия товаров из таблицы Goods, которые ещё ни разу не покупались ни одним из членов семьи (таблица Payments):
													Select good_name From Goods Where good_id <> All (Select good From Payments)
	- оператор IN - проверяет входит ли конкретное значение в набор значений. Например, если необходимо получить всю информацию о
владельцах жилья стоимостью больше 150: 			SELECT * FROM Users 
													WHERE id IN (SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150)
	- оператор ANY - возвращает TRUE, если хотя бы одно сравнение в наборе вернёт TRUE. Например, найти пользователей, которые
владеют хотя бы 1 жильем стоимостью более 150:		SELECT * FROM Users 
													WHERE id = ANY (SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150)

###		Многостолбцовые подзапросы
	Многостолбцовые подзапросы - это подзапросы, возвращающие несколько столбцов и несколько строк (производные таблицы).
Используется для сопоставления или сравнения значений в основном запросе со значениями в подзапросе. Например, если мы хотим
получить информацию о всех бронированиях, в которых цена жилья на момент брони (Reservations.price) соответствует текущей
стоимостью жилья (Room.price):						SELECT * FROM Reservations 
													WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
	Выведите список комнат (все поля, таблица Rooms), которые по своим удобствам (has_tv, has_internet, has_kitchen, has_air_con)
совпадают с комнатой с идентификатором "11":		Select * From Rooms
													Where (has_tv, has_internet, has_kitchen, has_air_con) IN (
													Select has_tv, has_internet, has_kitchen, has_air_con From Rooms Where id = 11)
###		Коррелированные подзапросы
	Коррелированные подзапросы - это подзапрос, который ссылается на один или несколько столбцов основного запроса, а так же
выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки из-за чего использование
коррелированных подзапросов может вызвать проблемы с производительностью, если содержащий запрос возвращает много строк.
	Все предыдущие подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы
могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе. Например, следующий
коррелируемый подзапрос находит кто и сколько потратил. Коррелированный подзапрос ссылается на столбец member_id из основного
запроса, а так же основной запрос в таблице FamilyMembers возвращает 8 записей и для каждой из них выполняется коррелированный
подзапрос:					SELECT FamilyMembers.member_name, (
								SELECT SUM(Payments.unit_price * Payments.amount) FROM Payments 
								WHERE Payments.family_member = FamilyMembers.member_id) AS total_spent
							FROM FamilyMembers;
	С помощью коррелированного подзапроса выведите имена всех членов семьи (member_name) и цену их самого дорогого купленного
товара. Если такого товара нет, выведите NULL: 	
							Select FamilyMembers.member_name, (
								Select Max(amount* unit_price) From Payments 
								Where FamilyMembers.member_id = Payments.family_member Group by family_member ) as good_price
							From FamilyMembers

##		Обобщённое табличное выражение, CTE, оператор WITH, Union [ALL], INTERSECT, EXCEPT
	Обобщённое табличное выражение или CTE (Common Table Expressions), оператор WITH - это временный результирующий набор данных,
к которому можно обращаться в последующих запросах, а его результат не сохраняется в схеме БД. В отличии от VIEW существует только
на время выполнения запроса. Они нужны для упрощения написания сложных запросов, улучшение их читабельности и дальнейшей поддержки.
Для создания CTE используется оператор WITH ... AS (подзапрос) для создания псевдонима с набором колонок, к которому можно будет
обратиться из другого запроса
	WITH название_cte [(столбец_1 [, столбец_2 ] …)] AS определить названия для столбцов получившегося табличного выражения
		(подзапрос), - результат можно использовать в других частях SQL запроса; , - если нужно более одного табличного выражения
		[название_cte [(столбец_1 [, столбец_2 ] …)] AS 
		(подзапрос)] …
	Создаём табличное выражение Aeroflot_trips, содержащие все полёты, совершенные авиакомпанией «Aeroflot»:
							WITH Aeroflot_trips (aeroflot_plane, town_from, town_to) AS
								(SELECT plane, town_from, town_to FROM Company
									INNER JOIN Trip ON Trip.company = Company.id 
									WHERE name = "Aeroflot")
							SELECT * FROM Aeroflot_trips;
	
	Union - объединяет результаты выполнения SQL запросов или таблиц со схожей структурой и убирает повторения в результирующей
таблице, а для отображения с повторением есть необязательный параметр ALL. Таблицы должны иметь одинаковое число столбцов, тот же
тип данных, стоящих в той же последовательности.
	- Не путайте операции объединения запросов с операциями объединения таблиц - JOIN и с подзапросами они выполняются для
связанных таблиц.
							SELECT поля_таблиц FROM список_таблиц ...
							UNION [ALL]
							SELECT поля_таблиц FROM список_таблиц ... ;
	Существует два других оператора, чьё поведение крайне схоже с UNION:
	- INTERSECT - в отличии от UNION возвращает записи только первого запроса, которые имеют совпадения во втором запросе, а EXCEPT
возвращает записи только первого запроса, которые не имеют совпадения во втором запросе.

##		Основные различия между View и CTE:
	- View создается и сохраняется в БД, а CTE является временным объектом и существует только в пределах одного запроса;
	- View и CTE можно использовать для упрощения сложных запросов, объединяя данные из разных таблиц и повторного использования,
но View может отобразить полученные данные, а CTE используется для того, чтобы создать временную таблицу для подзапроса внутри
основного запроса;
	- View может быть обновлен, удален;
	- CTE позволяет выполнить итерацию или рекурсивные операции в запросе.

##		Оператор CASE, функция IF, IFNULL, NULLIF
	Оператор CASE - позволяет писать условную логику, чтобы в зависимости от условий возвращать одно из множества возможных
значений, если ни одно из условий не будет выполнено, то вернётся NULL или значение после конструкции ELSE:
	Рассмотрим оператор CASE на примере определения этапа школьного образования.
				SELECT name,
					CASE
						WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (10, 11)			THEN "Старшая школа"
						WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (5, 6, 7, 8, 9)	THEN "Средняя школа"
						ELSE "Начальная школа"
					END AS stage
				FROM Class

	Условная функция IF - сравнивает два числа, а также функции IF можно вкладывать друг в друга, эмулируя оператор CASE:
				SELECT IF(условное_выражение, значение_1, значение_2);
				SELECT IF(10 > 20, "TRUE", "FALSE");

	Функции IFNULL и NULLIF направленны на обработку NULL значений. 
	Функция IFNULL - возвращает первый аргумент, если он не равно NULL, иначе возвращает альтернативное значение:
				SELECT поля, IFNULL(значение, альтернативное_значение);
				SELECT first_name, 
					IFNULL(middle_name, "Empty") as middle_name
	Функция NULLIF - возвращает NULL, если значение_1 равно значению_2, в иначе возвращает значение_1:
				NULLIF(значение_1, значение_2);
	
##		Операторы INSERT, UPDATE, DELETE и TRUNCATE.
	Оператор INSERT	INTO - предназначен для добавления новых записей в таблицу, а с помощью слова VALUES можно вставлять значения,
перечислив их в круглых скобках через запятую. Первичный ключ является уникальным значением и добавление уже существующего значения
приведёт к ошибке, поэтому в существует механизм с автогенерацией первичного ключа, например, в MySQL атрибут AUTO_INCREMENT, а в
PostgreSQL атрибут SERIAL:
				INSERT INTO имя_таблицы [(поле_таблицы, ...)]
					VALUES (значение_поля_таблицы, ...) | SELECT поле_таблицы, ... FROM имя_таблицы ...
				INSERT INTO Goods (good_id, good_name, type) 
					VALUES (20, 'Table', 2);
	 При добавлении новой записи с уникальными индексами решением может быть дополнительный запрос, направленный на выявление
максимального значения первичного ключа для генерации нового уникального значения.
				INSERT INTO Goods SELECT COUNT(*) + 1, поле_1, поле_n FROM Goods;

	Оператор UPDATE - предназначен для обновление существующих записей, а после оператора SET указать поля которые необходимо
обновить, но если не указать оператор WHERE, то будут обновлены все записи в таблице. Так же можно менять значения, опираясь на
предыдущие значение.
				UPDATE имя_таблицы 
					SET поле_таблицы1 = значение_поля_таблицы1, поле_таблицыN = значение_поля_таблицыN 
				[WHERE условие_выборки]
				UPDATE FamilyMembers SET member_name = "Addie Anthony" WHERE member_name = "Addie Quince";
				UPDATE Payments SET unit_price = unit_price * 2

	Оператор DELETE - предназначен для удаление данных, но если отсутствует оператор WHERE, то будут удалены все записи указанной
таблицы.
	Оператор TRUNCATE в отличии от DELETE просто удалит таблицу и пересоздаст её заново - этот вариант работает быстрее, поскольку
DELETE удаляет записи одну за другой. Некоторые СУБД используют TRUNCATE вместо DELETE, если он не содержит условия WHERE или LIMIT
				DELETE FROM имя_таблицы [WHERE условие_отбора_записей];
				TRUNCATE TABLE имя_таблицы;
	У оператора TRUNCATE есть ряд отличий:
	- Не срабатывают триггеры, в частности, триггер удаления;
	- Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций;
	- Сбрасывает счётчик идентификаторов до начального значения;
	- Чтобы использовать, необходимы права на изменение таблицы.
	Удаление записей при многотабличных запросах. Если в DELETE запросе используется JOIN, то необходимо указать из каких именно
таблиц требуется удалять записи:
				DELETE имя_таблицы_1 [, имя_таблицы_2] FROM	имя_таблицы_1 
					JOIN имя_таблицы_2
					ON имя_таблицы_1.поле = имя_таблицы_2.поле
				[WHERE условие_отбора_записей];
	Например, необходимо удалить все бронирования жилья, в котором отсутствует кухня:
				DELETE Reservations FROM Reservations
					JOIN Rooms
					ON Reservations.room_id = Rooms.id
				WHERE Rooms.has_kitchen = false;
	Если бы, помимо удаления бронирования, нам нужно было также удалить и жилье, то запрос приобрёл бы следующий вид:
				DELETE Reservations, Rooms FROM Reservations
					JOIN Rooms
					ON Reservations.room_id = Rooms.id
				WHERE Rooms.has_kitchen = false;

##		Операторы для создания и удаления таблиц и баз данных: CREATE, SHOW и DROP. IF [NOT] EXIST, USE, DESCRIBE, CASCADE
	CREATE DATABASE - предназначен для создания баз данных: CREATE DATABASE имя_базы_данных;
	SHOW DATABASES - предназначен для проверки создалась ли БД: SHOW DATABASES;
	DROP DATABASE - предназначен для удаления БД: DROP DATABASE имя_базы_данных;
	Конструкция IF [NOT] EXIST - предназначена, чтобы проверить существует ли база данных или таблица с таким именем или нет.
	Чтобы создать БД только при условии, что она не существует: CREATE DATABASE IF NOT EXIST имя_базы_данных;
	Чтобы удалить БД только при условии, что она существует:	DROP DATABASE IF EXIST имя_базы_данных;

	Оператор USE - предназначен, чтобы сначала выбрать БД, в которой будет создана или удалена таблица: 
				USE имя_базы_данных;
	Оператор CREATE TABLE - предназначен для создания таблицы:
				CREATE TABLE [IF NOT EXIST] имя_таблицы (
					столбец_1 тип_данных [атрибут],
					[столбец_n тип_данных [атрибут],]
				);
	Оператором DESCRIBE - предназначен для того, чтобы посмотреть описание созданной таблицы: DESCRIBE Users;
	DROP TABLE - предназначен для удаление таблицы: DROP TABLE [IF EXIST] имя_таблицы;
	ON DELETE RESTRICT - запрещает удалить таблицу, например, в таблице Users есть данные, то БД не даст этого сделать и выдаст
ошибку: Cannot delete or update a parent row: a foreign key constraint fails:
				CREATE TABLE Users (
					id INT,
					name VARCHAR(255) NOT NULL,
					company INT,
					PRIMARY KEY (id),
					FOREIGN KEY (company) REFERENCES Companies (id)
					ON DELETE RESTRICT ON UPDATE CASCADE
				);
	Если указать ON DELETE CASCADE, то при удалении компании были бы удалены все пользователи, ссылающиеся на эту компанию.
	Если указать ON DELETE SET NULL, то при удалении БД запишет NULL в поля company для всех пользователей, работавших в
удалённой компании.
	ON UPDATE CASCADE означает, что если компания изменит свой идентификатор, то все пользователи (Users) получат новый
идентификатор в поле company.

#		Масштабирование SQL баз данных. Репликация, подход master-slave, Шардинг, Вертикальный и Горизонтальный шардинг.
	Масштабирование баз данных - это процесс увеличения емкости и производительности БД для обработки растущего объема данных и
увеличения количества пользователей. В основе масштабирования данных лежит разделение данных на группы и выделение их на отдельные
сервера. Существует две основные стратегии — репликация и шардинг.
	Репликация - при репликации создается дубликат БД, соответственно, вместо одного сервера их несколько. Чаще всего используют
схему master-slave. Поскольку операций чтения данных часто намного больше, чем операций изменения данных. Поэтому, репликация
позволяет разгрузить основной сервер за счет переноса операций чтения на slave. Из минусов рассинхронизация данных и задержки в
копировании с мастера на slave. Зато это отличное средство для обеспечения отказоустойчивости. Её можно комбинировать с Sharding. 
	- Master — это основной сервер БД, куда поступают все данные. Все изменения в данных должны происходить на этом сервере;
	- Slave — это вспомогательный сервер БД, который копирует все данные с мастера. С этого сервера следует читать данные. Таких
серверов может быть несколько. 
	Шардинг (sharding) - это разделение одной БД на отдельные части так, чтобы каждую из них можно было вынести на отдельный
сервер существуют вертикальный и горизонтальный шардинг:
	- Вертикальный шардинг — это выделение таблицы или группы таблиц на отдельный сервер;
	- Горизонтальный шардинг — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц,
которые не умещаются на одном сервере.

##		Основы индексов в SQL Server
	Одним из важнейших путей достижения высокой производительности SQL Server является использование индексов. Индекс ускоряет
процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, как указатель в книге помогает вам
быстро найти необходимую информацию. Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными,
используя значения первичного ключа, то SQL Server сначала найдет значение индекса, а затем использует индекс для быстрого
нахождения всей строки с данными. Без индекса будет выполнен полный просмотр всех строк таблицы, что может оказать значительное
влияние на производительность. Недостатком является то, что доступ к таблице всегда происходит через индекс, это приводит к
дополнительной нагрузке на SQL Server.
	Индекс представляет собой сбалансированное бинарного дерево, но в узлах не по 1 элементу, а страницы, данные которых связаны
в отсортированный связанный список и каждый уровень дерева также связан с соседними узлами образовывая двунаправленный список.
Индексы создаются для столбцов таблиц и представлений, кроме столбцов, которые имеют большой размер: TEXT, IMAGE, VARCHAR и
делятся на кластеризованный и некластеризованный, а так же есть кучи.

###		Кучи, Кластеризованный и Некластеризованный индекс. Составной индекс, Уникальный индекс, Покрывающий индекс.
	Кучи – это данные, хранящиеся без какой-либо определенной сортировки, не имеющие индексов, доступ и поиск по таким данным
происходит последовательно при сканировании страниц, и может занимать довольно долгое время влияя негативно на производительность.
Кучи подходят для хранения небольшого количества данных.
	Кластеризованный индекс - это индекс, который хранит в своих узлах реальные данные таблиц в отсортированном виде по ключу, 
из-за этого нельзя создавать более одного кластеризованного индекса в таблице. Для выбора ключа лучше всего подходит ID поскольку
он всегда уникальный, короткий, а новые данные будут добавляться сразу в конец и не потребуется ребалансировка дерева, что
повысит производительность.
	Некластеризованный индекс - это индекс, который не хранит в своих узлах данные, а только указатели на данные в таблице или на
другую кластеризованную таблицу. Некластеризованный индекс нельзя отсортировать, но можно создать больше одного для одной таблицы.
	Составной индекс - этот индекс построенный по нескольким колонкам, но до 16 шт или размером до 900 байт. Как кластеризованный,
так и некластеризованный индексы могут быть составными.
	Уникальный индекс - этот индекс гарантирует уникальность всех строк в индексируемом столбце. Если индекс составной, то
уникальность должна быть в каждой вариации значения, а не у каждого столбца данного индекса.
	Покрывающий индекс - этот индекс позволяет запросу сразу получить все необходимые данные из листьев индекса без обращения к
записям самой таблицы. Покрывающие индексы быстрее остальных, но занимает много места.
	B-tree индекс - 

##		Оконная функция в SQL (OVER)
	Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для
этого набора строк в отдельном столбце. Она не изменяет строки, а добавляют некоторую дополнительную информацию о ней в отличии
от GROUP BY, который группирует данные сокращая к-во строк. Она выполняется после Select или ORDER BY, где тоже можно указать
столбец расчета оконной функции для сортировки.

#		Что такое ORM? В чем преимущества ORM? В чем недостатки ORM и когда ее лучше не использовать?
	ORM object-relational mapper - это технология, которая позволяет работать с БД используя .net объекты. Она создает слой между
базами данных и .net объектами, и автоматически генерирует SQL код, чтобы создать таблицы основанные на классах и наоборот.
	Преимущества: Избавляет разработчиков от написания SQL запросов, а весь генерируемый ORM код выверен и оптимизирован, поэтому
не требует дополнительного тестирования. Работая через ORM таблицы проще обновлять, поддерживать и повторно использовать, а многий
функционал доступен из "коробки", в отличие от написания запросов собственноручно.
	К основным минусам можно отнести потерю производительности поскольку ORM может не оптимально формировать SQL запросы. Сложнее
отслеживать ошибки и сами sql запросы, чем прямой вызов процедур или написания запросов. 
	Нет особо смысла использовать ORM, если между таблицами нет связей 1-to-1, 1-to-many или many-to-many или база данных будет
иметь в качестве интерфейса хранимые процедуры.
	Для примера Entity Framework / Entity Framework Core или NHibernate

##		В чем разница между Eager loading, Lazy Loading в EF и explicit loading?
	Eager loading - связанные данные будут загружены вместе с основными данными в одном запросе. Реализуется с помощью метода
Include(), который транслируется в JOIN. Это помогает избежать дополнительных запросов к БД при доступе к связанным данным.
	Explicit loading - явная загрузка связанных данных с помощью метода Load(), после загрузки данных можно повторно обращаться к
ним через свойство Local: foreach(var user in db.Users.Local). Local - представляет коллекцию, загруженную в память при помощи
методов Load() или ToList() благодаря этому EF не выполняет дополнительных запросов к БД, а работает загруженными данными.
	Lazy loading - это неявная автоматическую загрузку связанных данных при обращении к ним, но может посылать несколько запросов
для получения лишь одной записи или множество запросов, если навигационное свойство является коллекцией, поэтому нужно использовать
осторожно и проверять отправляемые запросы. Для использования нужно добавить прокси nuget пакет Microsoft.EntityFrameworkCore.Proxies.
Сконфигурировать контекста данных, вызвав метод UseLazyLoadingProxies() и отметить все навигационные свойства виртуальными, а
сами классы должны быть открыты для наследования.

##		Какие компоненты архитектуры Entity Framework вы знаете?
	Entity Framework is an object-relational mapper¹ (O/RM) that enables² .NET developers to work with a database using .net
objects. In addition, can also automatically generate the necessary SQL code to create database tables based on classes and
vice versa. Entity Framework fits between the Data Layer and the database. (преобразователь, позволяет) 
	The Architecture of the Entity Framework is composed¹ of the following components: (состоит)
- The Entity Data Model(EDM) - abstracts¹ the logical or the relational schema and exposes² the schema of the data using a 
three-layered approach:  (абстрагирует, раскрывает)
	- The Conceptual Model (C) contains the model classes and their relationships.
	- Mapping model (C-S) consists of information about how the conceptual model is mapped to the storage model.
	- Storage model (S) represents the schema of the underlying¹ database. That means the storage model is the database model
which includes tables, views, Keys, stored procedures, and their relationships. (лежащей в основе БД)
- LINQ to Entities - is a query language used to write queries against¹ the object model. It returns entities, which are defined
in the conceptual model. You can use LINQ here (query operator - from .. in .. select or extension methods). (к) 
- Entity SQL - is another query language (For EF 6 only) just like LINQ to Entities, however, it is a little more difficult.
- The Object Services Layer - is the Context;
- Entity Client Data Provider - the main responsibility of this layer is to convert LINQ-to-Entities or Entity SQL queries into
a SQL query that is understood by the underlying database. It communicates¹ with the ADO .Net data provider² which sends or 
retrieves³ data from the database. (взаимодействует, поставщиком, извлекает)
- ADO .NET Data Provider - this layer communicates with the database using standard ADO.Net.

###		Entity Framework Context Class. What is an Entity in the Entity Framework? Types of navigation properties.
	DbContext - it is a bridge between your entities and the underlying database which represents the session¹ of interaction
between the applications and the data source. (сессию) Instance represents a combination of the Unit Of Work and Repository
patterns such that¹ it can be used to² query from a database and group together changes that³ will then be written back to the
store as a unit⁴. (поэтому, для, которые, как единое целое).
	An Entity in Entity Framework - is a class that is included as a DbSet<TEntity> type property in the derived context class.
Entity Framework maps each entity and property to a database table and a column in the database table.
	Scalar Property in C# -	a scalar property maps to a single column in the database table. 
	Navigation Property in C# - it represents a relationship with another Entity. There are two types of navigation properties:
- Reference Navigation Property - it represents the one-to-one relationship between the entities. virtual Department Department
- Collection Navigation Property - it represents one-to-many relationships.				virtual ICollection<Employee> Employees
- Many-to-many relationships require a collection navigation property on both sides.

###		Entity States in Entity Framework
	That means the Entity State represents the state of an entity. An entity is always in any one of the following states:
- Added:	The entity is being tracked by the context but does not yet exist in the database.
- Deleted:	The entity is being tracked by the context and exists in the database, but has been marked for deletion from the
database the next time SaveChanges is called.
- Modified:	The entity is being tracked by the context and exists in the database, and some or all of its property values
have been modified.
- Unchanged:The entity is being tracked by the context and exists in the database, and its property values have not changed
from the values in the database.
- Detached:	The entity is not being tracked by the context.
	The point that you need to remember is Entity Framework builds and executes the INSERT, UPDATE, and DELETE commands based
on the state of an entity when the context.SaveChanges() method is called. 

###		Development Approach with Entity Framework. Automated Database Migration in Entity Framework Code-First Approach
	Database-First - we can use it if the database schema already exists.
	Code-First - we can use it when you do not have an existing database for your application. In the code-first approach, you
start writing your entities and context class first and then create the database from these classes using migration commands.
	Model-First - is similar to the Code First approach, but in this case, we use a visual EDMX designer to design our models.
	
	The Entity Framework provides a migration tool that automatically updates the database schema when our model changes
without losing any existing data or database objects. It uses a new database initializer called MigrateDatabaseToLatestVersion.
There are two kinds of Migration: Automated Database Migration and Code-Based Database Migration
	Code-Based Migration in Entity Framework Code First Approach - provides more control over the migration and allows us to
configure additional things such as setting a default value of a column, configuring a computed column, etc. In order to use
Code-Based Migration in Entity Framework, we need to execute the commands in the Package Manager Console in Visual Studio.

###		Inheritance and Entity type hierarchy mapping
	- Table-per-hierarchy and discriminator (TPH) configuration - it pattern is used by default. TPH uses a single table to
store the data for all types in the hierarchy, and a discriminator is used to identify which class each row represents.
	- Table-per-type (TPT) configuration - all the classes are mapped to individual tables. Properties that belong to a base or
derived type are stored in a table that maps to that type. Derived types also store a foreign key that joins the derived table with
the base table. Для реализации подхода TPT можно использовать два способа: атрибуты или Fluent API(метод ToTable()).
	- Table-per-concrete-type (TPC) configuration - all the types are mapped to individual tables and including inheritance
property. Each table contains columns for all properties on the corresponding entity type.

###		Default transaction behavior, Savepoints, external DbTransactions? Как выполнить транзакцию для нескольких контекстов
	By default, if the database provider supports transactions, all changes in a single call to SaveChanges are applied in
a transaction. If any of the changes fail, then the transaction is rolled back and none of the changes are applied to the
database.
	Так же можно обернуть блок кода в транзакцию, а для того чтобы закоммитить транзакцию, потом нужно выполнить:
		using var transaction = context.Database.BeginTransaction(); 
		transaction.Commit();
	Savepoints - when SaveChanges is invoked¹ and a transaction is already in progress² on the context, EF automatically creates a
savepoint before saving any data. Savepoints are points within³ a database transaction which may later be rolled back to, if an
error occurs or for any other reason. If SaveChanges encounters⁴ any error, it automatically rolls the transaction back to the
savepoint, leaving the transaction in the same state as if it had never started. (вызывается, выполняется, в, встречает)
	try 				=> transaction.CreateSavepoint("BeforeMoreBlogs");
	catch (Exception) 	=> transaction.RollbackToSavepoint("BeforeMoreBlogs");
	External DbTransactions - использование разных технологий доступа к данным для доступа к реляционной базе данных в одной
транзакции.
	Для совместного использования одного подключения DbConnection требуется передать подключение в контекст при его создании. Для
этого вместо метода OnConfiguring использовать конструктор с DbContextOptions<T> или в конструкторе принимать DbConnection,
которое сохраняется в параметре, а затем используется в DbContext.OnConfiguring.

#		Messaging. Что такое AMQP? Queue vs Topic, Exchanges и его типы. и другие внутренности - вопрос не закрыт.
	AMQP (Advanced Message Queuing Protocol) — это протокол для передачи сообщений между компонентами системы благодаря ему
независимые приложения могут обмениваться сообщениями, он осуществляет маршрутизацию, гарантирует доставку сообщений, распределение
потоков данных, подписку на нужные типы сообщений.
	Queue vs Topic - is that Queue may have many consumers, but it forwards each message to only one consumer this is called
Point-to-Point model(P2P). However Topic forwards a message from the producer to many consumers at once. It’s a broadcast.
This is called Publish-and-Subscribe (Pub/Sub) messaging.
	Что такое Exchanges в протоколе AMQP? 
	Unlike¹ some other messaging² middleware³ products and protocols, in AMQP, messages are not published directly to queues.
Messages are published to exchanges that route them to queue(s) using pre-arranged criteria called bindings. So, an exchange
accepts messages from a producer and routes them to message queues using bindings⁴. It is like the "mail" of the AMQP world.  
(в отличии от, для обмена сообщениями, промежуточное ПО, привязками)
	Типы Exchanges (Direct, Fanout, Topic, Headers, System) и зачем они нужны?
	- Direct - a direct exchange delivers messages to queues based on a message routing key attribute. A queue binds to the
exchange with a routing key K and then when a new message with routing key R arrives at the direct exchange, the exchange
routes it to the queue if K = R
	- Fanout¹ - a fanout exchange routes² messages to all of the queues that are bound to it and the routing key is ignored. 
If N queues are bound to a fanout exchange, when a new message is published to that exchange a copy of the message is
delivered to all N queues. Fanout exchanges are ideal for the broadcast routing of messages.
	- Topic - topic exchanges route messages to one or many queues based on matching between a message routing³ key and 
the pattern that was used to bind a queue to an exchange. Topic exchanges are commonly used for the multicast routing of 
messages.
	- Headers - Header exchanges are identical to topic exchanges, except that instead of using routing keys, messages are
routed based on header values
(разветвление, направляет, маршрутизации )

##		Что такое Azure Service Bus, в чем разница между Service Bus и обычной Queue? ReceiveAndDelete и PeekLock
	Service Bus это шина сообщений, которая в отличии от обычной Queue поддерживает: очереди (Queue), разделы (topic) и
очередь недоставленных сообщений (Dead-letter queue).
	Azure Service Bus - брокер сообщений для корпоративных облачных приложений с поддержкой queue и topic. Она хранит сообщения в
"брокере" (например, в очереди), пока принимающая сторона не будет готова к приему. Поддерживает надежную асинхронная доставку
сообщений, Queue, topic и очередью недоставленных сообщений (DLQ), транзакции, балансировку нагрузки и тд
	В чем разница между ReceiveAndDelete и PeekLock - When received in ReceiveAndDelete mode, messages will be gone from
the queue. With PeekLock mode messages will remain on the queue unless MaxDeliveryCount was exceeded and they will be
dead-lettered.

##		В чем отличие Kafka от Service Bus или другого брокера сообщений? - без ответа

#		Микросервисы. Способы коммуникации между микросервисами.​ Saga, eventual consistency. Two-Phase Commit. 	
	Способы коммуникации: REST API, gRPC, Message Broker (AMQP), SignalR и тд.
	SignalR (Web sockets) - использует двунаправленную связь в режиме реального времени для обмена сообщениями между клиентом и
сервером. Для обмена сообщениями между клиентом и сервером SignalR использует: WebSockets, Server-Side Events, Long Polling,
Forever Frame.
	Так же есть:
- MQTT — Message Queue Telemetry Transport 
- STOMP — Simple Text Oriented Messaging Protocol
- Service Mesh
	Как реализовать атомарность транзакции между несколькими микросервисами?
	Saga паттерн - the saga pattern is a failure¹ management² pattern that helps establish³ consistency in distributed applications
and coordinates transactions between multiple microservices to maintain data consistency. (отказами, управления, обеспечить)
A microservice publishes an event for every transaction, and the next transaction is initiated based¹ on the event's² outcome³.
(на основе, события, результата)
Используется, когда каждый сервис имеет свою собственную базу данных, бизнес-транзакция охватывает несколько сервисов, чтобы
обеспечить согласованность данных между сервисами, каждый запрос имеет компенсационный запрос, который выполняется при сбое
запроса. Это может быть реализовано двумя способами:
	- Choreography (Хореография) при отсутствии центра координации, каждый сервис создает и слушает события другого сервиса
и решает, следует ли предпринять действие или нет;
	- Orchestration (Оркестрация) — оркестратор берет на себя ответственность за принятие сагой решений и последовательность
бизнес-логики. Когда у вас есть контроль над всеми участниками процесса, когда все они находятся в одной области контроля, и вы
можете контролировать поток действий. 
	Saga в отличии Two-Phase Commit сначала выполняет commit, а потом в случае появления ошибки на определенном уровне 
транзакции начинает процесс компенсации. А Two-Phase Commit разделяет этот проце на два этапа: Фаза подготовки и Фаза
фиксации. Сначала он запрашивает готовы ли узлы принять транзакцию, а потом управляющий узел попросит их зафиксировать,
в противном случае, даже если один узел ответил отрицательно, он попросит откатить назад. Вместо этого Saga разбивает
работу на отдельные транзакции, последствия которых могут быть каким-то образом отменены после того, как работа была
выполнена и зафиксирована.
	Может быть нелегко определить, когда произошел сбой шага в операции, реализующей возможной согласованности (eventual
consistency). Шаг может не сразу завершиться неудачей, но вместо этого он может заблокироваться. Возможно, потребуется
реализовать некоторую форму механизма тайм-аута или даже circuit-breaker-pattern. Так же есть и другие проблемы реализации.
	Eventual consistency в микросервисной архитектуре - это паттерн при котором обновленные данные в конечном итоге
распространятся на все узлы в конечном итоге все клиенты начнут получает актуальные данные, пример DNS. Таким образом,
eventual consistency гарантирует применение изменений хотя с некоторой задержкой времени, особенно когда цепочка улов
велика.

##		Какие паттерны для микросервисов вы знаете? Как обеспечить security микросервисов? Какие способы хостинга
микросервисов вы знаете?- нет ответа
#		Какие Test Frameworks вы знаете и использовали на практике?	- нет ответа
##		Какие вспомогательные библиотеки вы знаете и использовали для написания тестов? - нет ответа
##		В чем разница между Integration и Unit тестами?
	При интеграционных тестах мы используем реальные модули системы (БД, сервис и тд), а не "мокную" версию.
Интеграционный тест показывает какой конкретно функционал не работает (регистрация, покупка товара и тд), но при этом не
покажет конкретное место модуля где проблема. С этим поможет юнит тест, по-этому важно иметь хорошее покрытие юнит тестами,
но в случае когда система большая, а тестами покрывать все нет времени, интеграционные тесты могут быть выходом, пока все
не будет покрыто unit тестами.

##		В чем разница между Dummy, Fake, Stubs, Spies, Mocks объектами?
	Dummy — это объекты, которые передаются в методы, но на самом деле не используются. В основном, это параметры методов, если
конечно, они не влияют в тесте на то, что мы хотим проверить). Иногда это просто NULL
	Fake — объекты, которые имеют внутреннюю реализацию, но обычно она сильно урезанная и их нельзя использовать в продакшене.
Memory database хороший пример Fake объекта.
	Stubs — предоставляют стандартные ответы на вызовы, сделанные во время теста, обычно не отвечая ни на что, кроме того, что
запрограммировано для теста.
	Spies — это Stubs, которые также записывают некоторую информацию в зависимости от того, как они были вызваны. Одной из форм
этого может быть сервис электронной почты, который записывает, сколько сообщений было отправлено.
	Mocks — объекты, заранее запрограммированные с ожиданиями, которые формируют спецификацию вызовов, которые они ожидают
получить. Проверки соответствия ожиданиям проводятся через вызовы к Mock-объекту.

#		Сетевое взаимодействие и протоколы
##		Что происходит, когда пользователь вбивает в браузер адрес google.com
	При наборе адреса, браузер предлагает варианты для автоподстановки, которые будут обновляться с каждой новой буквой в
зависимости от истории поиска и оставленных закладках, если они есть. После того как мы ввели адрес целиком и нажали Enter браузер
определяет это поисковой запрос или URL, если пользователь не вводит протокол или доменное имя, то браузер понимает, что это
поисковой запрос. Если это URL, то он проверяет есть ли это доменное имя в списке HSTS (HTTP Strict Transport Security)» - это
механизм принудительно активирующий соединение через HTTPS. Если нужный сайт есть в этом списке, то браузер отправляет ему запрос
через HTTPS иначе по HTTP. URL из которого браузер получает информацию, чтобы отправить HTTP сообщение, которое состоит из:
	- Protocol: HTTP/HTTPS
	- Адрес сервера: хост, по которому нужно сделать обращение. Он представлен доменным именем.
	- Resource: путь к ресурсу на сервере, например, «/», который показать главную страницу или другие параметры.
	После определения протокола браузер должен получить IP-адрес, который он получает через DNS из хоста, но сначала он проверяет
его наличие в своем кеше, в файле hosts или кеше ОС. Если нигде нет, то отправляет запрос к сетевому DNS-серверу, как правило, это
локальный роутер или DNS-сервер интернет-провайдера в конечном итоге на NS-сервер.
	После получения браузером протокола, ip-адреса и порта, который формируется из протокола 80 или 443. В случае с https
протоколом пакет передается с прикладного уровня, на уровень представления. На этом уровне происходит TLS HANDSHAKE, а именно обмен
сертификатами, проверка подлинности сертификатов и обмен публичными ключами в итоге устанавливается доверенное соединение на основе
сертификатов. Браузер отправляет сообщение серверу с TLS настройками, которые он поддерживает, а сервер отвечает клиенту
сообщением, содержащим выбранные настройки и публичный сертификат сервиса, подписанный центром сертификации. Клиент подтверждает
сертификат сервера с помощью своего списка центров сертификации и генерирует строку псевдослучайных байтов, шифруя её с помощью
публичного ключа сервера. Сервер расшифровывает случайные байты с помощью своего секретного ключа и генерирует симметричный
мастер-ключ. Клиент и сервер обмениваются сообщениями Finished, зашифрованными симметричным ключом, после совпадения
устанавливается  доверенное соединение.
	Для формирования сообщения, чтобы отправить его по HTTP протоколу нужно сформировать заголовок, который содержит методы,
расположение ресурса и версия протокола клиента. Следующей строкой Host: имя сервера. Далее множество других полей в формате
ключ-значение в зависимости от метода и тд.
	В общем после формирования сообщения на прикладном уровне он отправляется на транспортный уровень, на котором сервер и клиент
установят гарантированное соединение, а так же ОС встроит в пакет TCP заголовок. Протокол TCP обеспечивает надежную доставку
посредством нумерации и контроля порядка пакетов, а также подтверждения их передачи квитанциями. Также есть UDP, который не
гарантирует целостность и порядок доставленных пакетов.
	Далее пакет передается на сетевой уровень, гда встраивается IP заголовок. IP адрес мы получаем через DNS сервер.
	Далее пакет передается на физический и канальный уровень, который представляет, например, Ethernet. Добавляется заголовок
кадра, включающий MAC-адрес сетевой карты, (NIC) компьютера, а также MAC-адрес локального роутера. Если ядру ничего не известно о
MAC-адресе локального роутера, то для его нахождения отправляется широковещательный ARP-запрос.
	Далее запрос поступает на сервер, а благодаря порту, сервер определяет какому приложению поступил запрос, а также если на
сервере множество сайтов, то благодаря полю host в запросе, он определяет кому именно этот запрос предназначен. Ответом же будет
пакет, который содержит версию протокола, статус код, 200 - OK, html страницу и другую информацию, которая помогает браузеру
отображать страницу.
	Далее браузер берет html страницу и делает парсинг. Html достаточно сложный язык и страница как правило не парситься в один
заход. Сама страница состоит из DOCTYPE, например html 5 - это правило, по которому будет парситься страница; Сам html, head,
который содержит служебные теги, неотображаемые на странице, например, стили, скрипты и тд; body содержит информацию которую
пользователь увидит на экране. Итак браузер, парсит HTML и CSS, из первого строит DOM-tree, а из второго CSSOM, на их основе
будет построено Render-tree. На этапе Layout браузер вычисляет расположение элементов, создавая макет - Layout-tree, на его основе
браузер на этапе Paint рисует пиксели. В итоге, на уровне Compositing браузер делит полученные данные на слои и в результате
страница отображается пользователю. Но браузер продолжает слушать/следить за действиями пользователя и реагировать на них, а также
выполнять js-код, подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее). Скрипты могут
потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт к следующему этапу рендеринга.

##		Протоколы: HTTP, HTTP/2, HTTPS. Структура HTTP-сообщения, Структура URL-адреса, URI, Абсолютные и относительные URL
	HTTP (HyperText Transfer Protocol) - это протокол для обмена данными между клиентом и сервером, который изначально
предназначался для получения с серверов гипертекстовых документов в формате HTML, а сейчас изображений, видео и других ресурсов.
	HTTP/2 - это более производительная версия протокола HTTP/1.1. Основные отличия между HTTP и HTTP/2: 
	- Поддерживает мультиплексирование - позволяет отправлять несколько запросов и ответов одновременно по одному TCP-соединению;
	- Использует метод сжатия заголовков, что уменьшает объем передаваемых данных и ускоряет передачу;
	- Позволяет указывать приоритеты для различных запросов, что позволяет оптимизировать загрузку важных ресурсов первыми;
	- Поддерживает функцию серверного PUSH, которая позволяет серверу отправлять дополнительные ресурсы клиенту до того, как они
были запрошены, на основе анализа запросов и потребностей клиента;
	- HTTPS (HTTP с шифрованием) широко используется с HTTP/2 для обеспечения безопасной передачи данных.
	Существует два типа HTTP сообщений: запрос и ответ, у каждого совой формат. Запросы содержат следующие элементы:
	- HTTP-метод, URI (Uniform Resource Identifier) - путь к ресурсу, к которому вы обращаетесь, и версию протокола.
		GET /index.html HTTP/1.1
	- Заголовки, предоставляющие дополнительную информацию серверу, например: Host - адрес хоста нужен, чтобы указать, с какого
сайта клиент пытается получить данные. Адрес указывают в виде домена, но он сразу же меняется на IP-адрес перед отправкой запроса
с помощью DNS; Cookie — куки, отдаваемые браузером серверу; Authorization — реквизиты для базовой авторизации (логин, пароль)
	- Тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс и отделяется пустой строкой.
	Ответы содержат следующие элементы:
	- Версию HTTP-протокола, HTTP код состояния, сообщающий об успешности запроса или причине неудачи.
		HTTP/1.1 200 OK	
	- HTTP заголовки, подобно заголовкам в запросах;
	- Опционально: тело, содержащее пересылаемый ресурс. От заголовка тело отделяется пустой строкой.
	Структура URL-адреса:	http://blog.example.com:80/catalog/category/knifes?key1=value1&amp;amp;key2=value2#anchor
	http:// — протокол; blog — поддомен, домен третьего уровня; example — домен, домен второго уровня; com — доменная зона, домен
первого уровня; 80 — порт; /catalog/category/knifes - URL; key1=value1&key2=value2 — GET параметры запроса; anchor — якорь
	URI является общим термином и представляет весь идентификатор ресурса, который включает URL и URN
	Абсолютные и относительные URL - абсолютный URL полностью указывает путь к ресурсу, начиная с протокола и доменного имени, а
относительный URL указывает путь к ресурсу относительно текущей страницы или базового URL: /ru/docs/Learn
	Якоря Anchor -  чтобы давать ссылки не просто на HTML-страницу, а на определенное место на странице.

##		Методы HTTP-запросов и статус коды.
	Если при повторении одного и того же запроса на сервере ничего не меняется, запрос считается идемпотентным. Если повторение
одинакового запроса несколько раз изменяет состояние сервера, то он не идемпотентен и менее безопасен.
	Метод	Идемпотентность	Предназначение												Статус коды
	GET			да			получает информацию о ресурсе. Может быть закэширован		200, 400, 404
	POST		нет			создает ресурс												200, 201, 204, 304
	PUT			да			заменяет ресурс целиком										200, 204,
	DELETE		да			удаляет ресурс												200, 204,
	PATCH		да			редактирует ресурс, если нужно обновить только одно поле	200
	HEAD		да			не получает body, но отправляет	и получает HTTP-заголовки.	200, 

	OPTIONS - используется для запроса параметров соединения с ресурсом т.е указывает, какие методы поддерживаются. 
	CONNECT - запускает двустороннюю связь с запрошенным ресурсом. Может использоваться для доступа к сайту, который использует HTTPS
	TRACE - используется для выполнения циклической "эхо-проверки". Он позволяет клиенту отправлять запрос на сервер, который
возвращает тот же запрос обратно клиенту. Он полезен для отладки и проверки, так как он позволяет клиенту увидеть, какие изменения
происходят с запросом, когда он проходит через различные прокси и серверы. Важно отметить, что методы CONNECT и TRACE могут
вызывать проблемы безопасности, и многие серверы и прокси-серверы ограничивают или отключают их использование по умолчанию.
	Статус коды:
	1XX	- Информационные;
    2XX - success; 200 - Ok; 201 Created; 204(No Content);
    3XX - Redirection; 301 - Moved Permanently; 302 - Moved Temporarily; 304(Not Modified)
    4XX - Client Error; 400(Bad request); 401 не авторизован; 403 запрещено; 404(Not found); 408 - Request timeout;
418 I'm a teapot; 498(Invalid Token)
    5XX - Server Error; 500 - Internal server error; 502 Bad Gateway; 503 Service Unavailable; 504 - Gateway timeout.

##		WebSockets, особенности и основные Web Socket API events?
	WebSockets - это протокол связи, который обеспечивает двустороннюю связь в режиме реального времени через одно TCP-соединение
между клиентом и сервером. Они могут общаться через открытое соединение до тех пор, пока оно не будет закрыто одной из сторон.
	Обе стороны могут отправлять сообщения независимо друг от друга в режиме реального времени.
	Веб-сокеты предоставляют низкую задержку связи, поскольку поддерживают постоянное открытое соединение.
	Основные события Web Socket API включают:
	- open: Срабатывает при успешном открытии соединения между клиентом и сервером;
	- message: Срабатывает при получении сообщения от сервера;
	- error: Срабатывает при возникновении ошибки в процессе соединения или обмена данными;
	- close: Срабатывает при закрытии соединения.

##		Что такое Short polling и Long polling?
	Short polling - это техника при котором клиент регулярно отправляет запросы на сервер для получения обновлений;
	Long polling - клиент отправляет запрос на сервер, но не отвечает на него и не закрывает канал, пока не получит информацию, для
ответа, когда появляется сообщение – сервер отвечает на запрос, а клиент немедленно делает новый запрос.

##		Что такое HATEOAS, в чем его основная идея и преимущество?
	HATEOAS (Hypermedia as the Engine of Application State) - это архитектурный принцип в REST-совместимых веб-сервисах, который
устанавливает, что клиенты должны получать ссылки на ресурсы и действия от сервера, чтобы динамически перемещаться по приложению.
	Основная идея HATEOAS заключается в том, что клиенту не нужно заранее знать структуру или URL-адреса, а только базовый URL
веб-сервиса. Вместо этого, клиент обращается к серверу за ресурсом, и сервер возвращает не только сам ресурс, но и информацию о
доступных действиях и ссылках на другие связанные ресурсы.
	Преимущество HATEOAS заключается в том, что он повышает гибкость и устойчивость приложений, позволяя серверу изменять
структуру и URL-адреса ресурсов, не вызывая сбоев в клиентском коде. Это также упрощает взаимодействие между компонентами
системы, уменьшает связанность и способствует декомпозиции приложения на более мелкие сервисы.

##		CORS
	CORS (Cross-origin resource-sharing т.е совместное использование ресурсов между разными источниками) - технология браузеров,
которая разрешает веб-страницам доступ к ресурсам другого домена. Для того, чтобы разрешить user agent-у получить ресурс другого
домена, то нужно включить CORS в заголовок ответа от сервера и делается на стороне сервера. Это сделано для того, что сайт
с определенным доменом, не могли отправлять запросы на сайты, которые не входят в его обязанности. Иначе будет получена ошибка
ошибка CORS policy, хоть сам запрос выполнится успешно, но причина по которой ресурс будет неполученн - это Same-Origin Policy.
Источник - origin состоит из: протокол(например https), хост(напр example.com), порт
Существует класс атак подделка межсайтовых запросов Cross Site Request Forgery - CSRF+ от которых не защищает Same origin Policy.

##		HTTP cache. Private cache. Public cache/Shared cache. ETag. Как использовать HTTP-based кэш для Action в ASP.NET Core? 
	Кеширование - это сохранение копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы. Таким образом
снижается нагрузка на сервер и повышается производительность вебсайтов, серверу не приходится самому обслуживать всех клиентов, а
поскольку кеш ближе к клиенту, то ресурс передаётся быстрее. 
	shared cache - это публичный и общий кеш для совместного использования разными пользователями. Например, в локальной сети
провайдера или компании, может быть установлен прокси, обслуживающий множество пользователей, чтобы можно было повторно
использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.
	private cache - это приватный кеш, который предназначен для одного пользователя. Он используется для доступа к ранее
загруженным страницам при навигации назад/вперёд.
	ETag (Entity Tag) - это тэг, который может использовать сервер, чтобы понимать изменились ли данные на сервере, вернув 
заголовок "304 Not Modified", чтобы клиент использовал свою кешированную версию ресурса. Это позволяет уменьшить нагрузку на
сеть и сервер.
	Как использовать HTTP-based кэш для Action в ASP.NET Core? - с помощью ResponseCacheAttribute, а так же можно использовать
Response Caching Middleware 

#		REST. Какие требование к RESTful сервису? Richardson Maturity Model (RMM)
	REST (Representational State Transfer) - архитектурный стиль для взаимодействия компонентов распределённого приложения в сети.
Т.е это набор правил, как организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и
приложение можно было масштабировать. REST является архитектурой, которая была предложена в 2000-ие годы Роем Филдингом в его
диссертации. Рой является архитектором HTTP 1.1, соавтором интернет стандартов для HTTP и URI.
	Какие требование к RESTful сервису?
	- Client-server architecture - система должна быть разделена на клиент и сервер;
	- Отсутствие состояния (stateless) - сервер не должен хранить какую-либо информацию о клиентах. В запросе должна храниться вся
необходимая информация для обработки запроса;
	- Кэширование - каждый ответ должен быть отмечен является ли он кэшируемым или нет;
	- Uniform interface - универсальный интерфейс между компонентами системы. Каждый ресурс должен быть определен идентификатором
ресурса URI; взаимодействие с ресурсами через представления, например, JSON или XML; использованием стандартных HTTP-методов; 
использованием гиперссылок для связывания ресурсов (HATEOAS);
	- Layered system - допускается разделить систему на разные слои, но с условием, что каждый слой может взаимодействовать только
с компонентами ближайшего уровня и не связан запросами с другими;
	- Code-On-Demand(необязательный) - позволяется загрузка и выполнение кода или программы на стороне клиента.
	Что я получу если моя служба будет RESTful? - RESTful позволит улучшить масштабируемость компонентов, обеспечить безопасность,
независимое развертывание и т.д.
	Как определить является ли служба RESTful или нет? - если веб служба удовлетворяет всем критериям Филдинга:
	Уровень 0: Один URI, один HTTP метод - из методов используется только один, например POST, и один URI;
	Уровень 1: Несколько URI, один HTTP метод - нужно использовать несколько относительных URL, чтобы получить разные ресурсы;
	Уровень 2: Несколько URI, каждый поддерживает разные HTTP методы;
	Уровень 3: HATEOAS․ Ресурсы сами описывают свои возможности и взаимосвязи - позволяет возвращать действия в виде URL, которые
могут быть выполнены с интересующим вам ресурсом. Преимуществом HATEOAS является то, что оно дает возможность разработчикам
веб служб менять URI независимо от клиентов.

##		Какие реализации RPC протокола вы знаете? gRPC, JSON-RPC. RPC API vs REST API.
	RPC API позволяют вызывать удаленные функции на внешних серверах, как если бы они были локальными для своего приложения.
Например, вы можете добавить функцию чата в свое приложение, удаленно вызывая функции обмена сообщениями в другом приложении чата.
Существует несколько различных реализаций протокола RPC (Remote Procedure Call):
	- XML-RPC - это протокол RPC, который позволяет вызывать удаленные методы, передавая XML-код в теле HTTP-запроса;
	- JSON-RPC - это протокол RPC, который позволяет вызывать удаленные методы, передавая JSON-код в теле HTTP-запроса;
	- SOAP - является расширением протокола XML-RPC, но кроме вызова удаленных методов используется для обмена произвольными
сообщениями в формате XML;
	- gRPC - это протокол RPC, разработанный компанией Google. Он использует протокол бинарной сериализации Protobuf для передачи
данных и поддерживает множество языков программирования и платформ. Для того, чтобы начать работу с ним нужно описать схему т.е
все методы API, аргументы и тд на языке Protobuf. И поддерживает только HTTP/2 поэтому gRPC — протокол исключительно для общения
сервисов на стороне бэкенда.
	REST API в отличии от RPC API выполняют определенные операции с данными на удаленном сервере, используя HTTP методы, а не
как-будто они определены в своем приложении. Например, приложение может добавлять или изменять данные сотрудников на удаленном
сервере с помощью REST API.
	И REST, и RPC используют HTTP в качестве базового протокола. Самые популярные форматы сообщений в системах RPC и REST это
JSON и XML. Предпочтение отдается JSON из-за его читабельности и гибкости.

#		Аутентификации и Авторизации, OAuth2 и Roles, OpenID Connect, IdentityServer, виды токенов.
	Аутентификация - это процесс подтверждения права на доступ с помощью ввода логина и пароля.
	Авторизация - это проверка какие права и привилегии доступны пользователю, например, роли и права в контроллерах.
	Аутентификация и авторизация - Who are you? and What are you allowed to do?
	OAuth2 - это протокол авторизации, который позволяет предоставить третьей стороне ограниченный доступ к защищенным ресурсам
пользователя и выполнять действия от его лица без необходимости передачи логина и пароля. OAuth2 разделен на Roles:
	- Client - стороннее приложение, например, наше приложение на React;
	- Resource Owner - тот, кому принадлежит ресурс;
	- Resource Server - сервер с ресурсами, которые принадлежат Resource Owner, например, Web API или microservices;
	- Authorization Server - сервер, который авторизует, и выдает токены доступа клиентам, для доступа к Resource Server.
	Клиент запрашивает доступ к ресурсам, которые принадлежат Resource Owner и находятся на Resource Server, а доступ
предоставляется не по логину и паролю, а по токену, который предоставляется Authorization Server
	OpenID Connect (OIDC) - это надстройка над протоколом OAuth2, которая позволяет клиентам проверять личность пользователя
основываясь на аутентификации, выполняемая Authorization Server, и получать базовую информацию профиля пользователя, который вошел
в учетную запись. Он позволяет разработчикам аутентифицировать своих пользователей между сайтами и приложениями благодаря созданию
единой учетной записи для аутентификации на множестве не связанных между собой интернет ресурсов, используя услуги третьих лиц. 
	В .net приложениях используется IdentityServer - это сервер проверки подлинности, который реализует стандарты OIDC и OAuth 2.0
для ASP.NET Core. Пользователь разрешает Client(Приложение) пройти авторизацию, вводя логин и пароль, клиентское приложение
запрашивает токен доступа у IdentityServer путём предоставления информации о самом себе. Затем сервер авторизации проверяет
подлинность клиента и реквизиты владельца ресурса (логин и пароль). И создаёт для приложения access, Id и refresh -токены. Процесс
авторизации завершён. Клиентское приложение обращается за данными к защищенному Web API, предоставляя при этом токен доступа для
авторизации.
	Id-токен (токен идентификации) — результат аутентификации, который содержит идентификатор пользователя, а так же как и когда
пользователь проходил аутентификацию. Можно расширить своими данными.
	Access-токен (токен доступа) — позволяет получить доступ к ресурсам API. Клиенты запрашивают токены и пересылают их к API. Он
содержит информацию о клиенте и пользователе, а API использует эту информацию, чтобы авторизовать доступ к данным.
	Refresh-токен (токен обновления) — необязательный параметр, который сервер авторизации может возвратить в ответ на запрос
токена доступа.

##		Что такое JWT token? Из каких частей состоит? Зачем нужен Рефреш токен? Как инвалидировать JWT токен в ASP.NET?
	JSON Web Tokens (JWT) - это способ для безопасной передачи информации между клиентом и сервером с помощью шифрования. О1н
 представляет собой зашифрованное сообщение, которое состоит из трех частей, разделенных точкой header.payload.signature:
	- Header - содержит тип используемого токена, а так же алгоритм шифрования, обычно это SHA256, для его вычисления нужен лишь
один секретный ключ, или RS256 он является ассиметричным и создает два ключа: публичный и приватный. С помощью приватного ключа
создается подпись, а с помощью публичного проверяется подлинность подписи;
	- Payload - содержит данные, которые нужные для авторизации пользователя. Payload также известна как JWT-claims;
	- Signature - содержит подпись, которая создается с помощью шифрования Header и Payload, используя алгоритм base64url, далее
они хэшируются алгоритмом указанным в Header на основе секретного ключа, чтобы гарантировать целостность данных. 
	Чтобы проверить JWT у приложения есть секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном,
приложение выполняет тот же алгоритм подписывания к JWT, что в шаге 3, далее сравнивает со своей собственной подписью. Если
подписи совпадают, значит JWT валидный.
	Рефреш токен (RT) — предназначен для получение нового токена доступа. Они долгоживущие, но одноразовые. Основной сценарий
использования такой: как только старый JWT истекает, то с ним мы уже не можем получить приватные данные, тогда отправляем RT и нам
приходит новая пара JWT+RT. С новым JWT мы снова можем обращаться к приватным ресурсам. Конечно, рефреш токен тоже может
протухнуть, но случится это не скоро, поскольку живет он намного дольше своего собрата.
	Ключевая идея разделения токенов состоит в том, что, с одной стороны, токены авторизации позволяют нам легко проверять
пользователя без участия сервера авторизации, просто сравнением подписей. C другой стороны у нас есть рефреш, который позволяют
нам обновить токен доступа без ввода пароля от пользователя, но в этом случае нам все-таки потребуется выполнить операцию
обращения к серверу авторизации.
	Как инвалидировать JWT токен - невозможно узнать, был он скомпрометирован, или же нет, но можно изменить secret-key или
уменьшить время жизни Refresh token. Но смысл такой: У вас есть Access Token (в нашем случае JWT) и Refresh Token. Access Token —
короткоживущий, например, час; можно реализовать через exp, его можно не записывать в базу, проверяется только по подписи. RT —
живет дольше, например, 30 дней, записан в базу и проверяется по наличию в ней. Чтобы сгенерировать новый Access Token, нужно взять
Refresh Token из запроса, найти в БД и получить связанного с ним пользователя. Удалить текущий RT и сгенерить новую пару пару
токенов, а RT записываем в БД. В итоге:
	- Если кто-то украдет из клиентского приложения только Access Token, он проживет тот же час и протухнет;
	- Если кто-то украдет оба токена, то через час одна копия приложения успешно получит новую пару токенов, а вторую выкинет,
так как такого Refresh Token уже нет в базе. И тогда пользователь увидит, что его выкинуло и что-то заподозрит.

#		Какие веб серверы поддерживает ASP.NET Core по умолчанию? IIS, HTTP.sys, Kestrel. Kestrel vs. HTTP.sys
	Раньше .NET приложения развертывались на веб-сервере IIS, но поскольку .NET Core поддерживает кроссплатформенность, то от IIS
отказались. .NET Core использует два дополнительных http-сервера: HttpSys и Kestrel реализация сервера прослушивает HTTP-запросы и
передает их, объединенные в HttpContext, в конвейер middleware приложения.
	HTTP.sys работает только на платформе Windows, а Kestrel является кроссплатформенным. Кроме того, если приложение использует
Kestrel, то в качестве прокси-сервера оно может использовать также IIS, Apache и Nginx. Их задача получать запросы и перенаправлять
приложению. Такая схема, когда запросы идут не напрямую на Kestrel, а проходят через IIS/Apache/Nginx, позволяет задействовать
возможности, которые есть у этих веб-серверов, но отсутствуют у Kestrel. В частности, прокси-серверы позволяет скрыть приложения,
если они не должны быть доступны напрямую. Кроме того, веб-серверы позволяют управлять нагрузкой ко всем приложениям, и много
другое. Kestrel имеет следующие преимущества перед HTTP.sys:
	- Лучшая производительность и использование памяти, благодаря асинхронной обработке запросов;
	- Кроссплатформенность;
	- Гибкость, поскольку работает независимо от ОС;
	- Программный порт и настройка TLS;
	- Расширяемость, позволяющая использовать такие протоколы, как PPv2, и альтернативные транспорты.
	Http.Sys работает как shared kernel mode со следующими функциями, которых у Kestrel нет:
	- Port sharing;
	- Kernel mode windows authentication. Kestrel поддерживает только аутентификацию в пользовательском режиме;
	- Быстрое проксирование через передачу очереди;
	- Прямая передача файлов;
	- Response caching.

#		ASP.NET Core. Что такое middleware в ASP.NET Core? Создание и добавление в pipeline.
	ASP.NET Core - это кроссплатформенная, высокопроизводительная среда разработки с открытым исходным кодом для создания облачных
приложений.
	В ASP.NET Core middleware – это классы представляющие конвейер обработки HTTP-request и response, каждый middleware
обрабатывает входящие запросы и передает выполнение следующему middleware для дальнейшей обработки, после обработки запрос
возвращается в обратном направление. Порядок компонентов middleware в конвейере обработки влияет на безопасность, функциональность
и производительность приложения. По умолчанию ASP.NET Core предоставляет ряд встроенных компонентов middleware для часто
встречающихся задач таких как: Routing, Authentication, Authorization, Log, Exception, CORS, Health Check, Redirection и тд
	Для создания компонентов middleware используется параметр делегат:  private readonly RequestDelegate next; который возвращает
ссылку на следующий делегат в конвейере, а так же в классе должен быть определен метод InvokeAsync, который обрабатывает запрос. Он
возвращает Task и принимает объект HttpContext: public async Task InvokeAsync(HttpContext context);
	Для добавления компонента middleware в pipeline, нужно создать метод расширения для IApplicationBuilder и ввернуть метод
builder.UseMiddleware<T> с типом созданного middleware:	return builder.UseMiddleware<MyCustomMiddleware>();
	Так же можно реализовать интерфейс IMiddleware или класс как в предыдущем способе, но не использовать делегат, а внутри 
метода InvokeAsync() вызвать await next(), а перед ним код обработки HTTP-запроса.

##		Run, Use, Next, Map. В чем разница между app.Use и app.Run при добавлении middleware?
	Run() - это завершающй middleware метод, т.е. он не будет вызывать другой компонент middleware из конвейера даже, если будет
добавлен второй Run, то вызовется только первый. Соответственно должен использоваться в конце pipeline, но, чтобы его вызвать в
Use, должен быть next метод;
	Use() - is used to insert a new middleware component to the Request Processing Pipeline;
	Next() - is used to call the next middleware component in the request processing pipeline;
	Map() - используется, чтобы вызвать middleware по определенному URL: app.Map(“/UrlPath”, MapCustomMiddleware);
	MapWhen() - принимает в качестве параметра делегат Func<HttpContext, bool> и обрабатывает запрос, если функция, передаваемая
в качестве параметра возвращает true. Например, context.Request.Query.ContainsKey("id");
	UseWhen() - тоже принимает делегат, но после выполнения указанного middleware, возвращается обратно в конвейер;
	Use vs Run - app.Use позволяет вызывать следующий middleware в pipeline, а app.Run нет поскольку он не принимает на вход
параметр next. После достижения app.Run управление возвращается предыдущему middleware и смотрит был ли еще код после next(), если
да, то выполняет его и передает управление следующему.

##		Типы middleware.
	middleware можно разделить на такие типы:
	- Content-Generating Middleware - используется, когда нужно сгенерировать ответ внутри текущего middleware и отправить его
обратно клиенту без обращения к MVC приложению;
	- Short-Circuiting Middleware – используется, когда нужно проверить запрос по какому-то условию и решить, следует ли передать
его следующему компоненту или сразу вернуть ответ. 
	- Request-Editing Middleware – используется,  когда нужно отредактировать запрос, до того как он достигнет следующего middleware;
	- Response-Editing Middleware – используется, когда нужно отредактировать ответ.

##		Что такое Attribute routing в ASP.NET Core?
	Attribute routes позволяет определять маршруты над action методами контроллеров напрямую, а не указывать глобально. Пример
маршрутизации атрибутов:		[Route("Accounts/{id}")]
								public ActionResult GetAccount(int id) { … }

##		В чем разница между ConfigureServices и Configure в ASP.NET Core? Что такое wwwroot?
	ConfigureServices – используется для добавления сервисов и зарегистрировать их через интегрированный DI, например, можно
добавить EntityFramework в ConfigureServices и использовать его, инжектируя в конструктор.
	Configure – используется для настройки middleware т.е HTTP request pipeline конфигурируется через configure метод.
	В ASP.NET Core все статические ресурсы, такие как CSS, JavaScript, изображения хранятся в папке wwwroot, но имя этой папки
можно изменить с помощью UseWebRoot.

##		Как написать интеграционный тест в ASP.NET Core?
	Для этого подойдет класс TestServer. Подробнее как написать такие тесты можно почитать в статье выше.

##		Какие типы фильтров существуют в ASP.NET Core? Чуть подробнее нун.
	Фильтры авторизации - применяются для определения того, авторизован ли пользователь для выполнения запроса. Эти фильтры могут
сократить выполнение конвейера, если запрос не авторизован;
	Фильтры ресурсов - выполняются после фильтров авторизации, применяются для глобальной обработка исключений, модификации ответов
и предварительной обработки запросов. Метод OnResourceExecuting() выполняется до всех остальных фильтров и до привязки модели, а
метод OnResourceExecuted() выполняется после всех остальных фильтров;
	Фильтры действий - применяется только к действиям контроллера, запускается после фильтра ресурсов как до, так и после
выполнения метода контроллера;
	Фильтры RazorPages - применяется только к страницам RazorPages, выполняются перед и после обработки запроса страницей Razor 
Page;
	Фильтры результатов - применяется к результатам методов контроллера и страниц Razor Pages, выполняется как до, так и
после получения результата;
	Фильтры исключений - определяют действия в отношении необработанных исключений.

##		В чем разница между Continuously Integration, Continuous delivery и Continuous deployment
	Continuous integration - практика разработки ПО, при которой постоянно сливаются изменения в основную ветку, а также 
выполняется сборка и автоматическое тестирование собранного проекта. При непрерывной интеграции большое внимание уделяется
автоматизации тестирования, чтобы убедиться, что приложение не сломано, когда новые коммиты мержатся в основную ветку.
	Continuous delivery - это расширение CI, поскольку она автоматически развертывает все изменения кода в тестовой и/или продакшн
env'е после этапа билда. Это означает, что помимо автоматического тестирования есть и автоматизированный релиз.
	Continuous deployment еще один этап эволюции после delivery. Благодаря этой практике каждое изменение, которое проходит все
этапы pipeline и релизится клиентам без вмешательства членов команды, но только неудачный тест остановит внедрение. Непрерывное
развертывание - отличный способ ускорить цикл обратной связи с вашими клиентами и снять давление с команды, поскольку больше нет
даты релизов. Разработчики могут сосредоточиться на девелопменте, и они видят, как их работа релизится в "лайв" через несколько
минут после завершения работы над ней.

##		Clean architecture
	Состоит из уровней: представления, Core(состоящее из уровней приложения и домена), и инфраструктуры. 
	Presentation - отвечает за взаимодействие с пользователем и обработку запросов, пример, Web API.
		Controllers - контроллеры.
		Program.cs - 
	Core 
		Application - выполняет бизнес-логику и координирует работу между уровнями представления и домена. В нем  должна быть 
реализована вся логика запросов, получение валидация и тд, а именно: интерфейс Db контекста, который будет реализован в Persistence
			Common - содержит инфраструктуру т.е все что относится к поведению, исключения, интерфейсы, маппинг и тд.
			Cqrs - содержит команды и запросы для всех сущностей, которые состоят из Command и CommandHandler. 
				Используется библиотека MediatR
		Domain - Уровень домена содержит бизнес-логику и компоненты, отвечающие за работу с данными
			Entities - описываем набор таблиц;
			Dto - содержит набор EntityDto, в них же можно маппить;
	Infrastructure - занимается поддержкой структур приложения и связью с внешними системами (например, базами данных, API и т.д.).
		Persistence - уровень который ответственный с взаимодействием с БД( есть ссылка с Application and Domain)
			Configurations - описываем конфигурации сущности таблицы для Fluent из Domain.Entities	
Ссылки: 
	Clean Architecture - https://habr.com/ru/companies/otus/articles/732178/
	Заблуждения Clean Architecture - https://habr.com/ru/companies/mobileup/articles/335382/

#		Типы паттернов. Какие архитектурные паттерны вы знаете? - нет ответа 
	Паттерны делятся на паттерны поведения, порождающие паттерны и структурные паттерны:
	- Паттерны поведения - определяют алгоритм и эффективную коммуникацию между объектами, то есть их поведение. Например,
Стратегия* (Strategy), Шаблонный метод (Template Method), Посредник* (Mediator), Итератор* (Iterator), Наблюдатель (Observer),
Посетитель (Visitor), Команда (Command), Состояние, Цепочка обязанностей;
	- Порождающие паттерны - это паттерны, которые предназначены для создания объектов без внесения в программу лишних
зависимостей. Например, Абстрактная фабрика* (Abstract Factory), Фабричный метод* (Factory Method), Строитель* (Builder), Прототип
(Prototype), Одиночка* (Singleton)
	- Структурные паттерны - это паттерны, которые показывают различные способы построения связей между объектами, для того чтобы 
образовать более крупные структуры. Например, Адаптер* (Adapter), Мост (Bridge), Компоновщик* (Composite), Декоратор* (Decorator),
Фасад* (Facade), Приспособленец/Легковес (Flyweight), Заместитель* (Proxy)

##		Примеры и реализации паттернов поведения.
	Стратегия (Strategy) - это набор алгоритмов, которые можно взаимозаменять во время выполнения программы, например, навигатор
и стратегии(пешком, машиной, общественный транспорт), которыми можно добраться до точки назначения. Для этого создаем общий
интерфейс или базовый класс, а в наследниках реализуем разные стратегии, а в другом классе (Context) создаем интерфейс и
присваиваем ему конкретную реализацию, через конструктор, а через свойство меняем стратегию во время выполнения программы.
	Итератор (Iterator) - представляет доступ ко всем элементам составного объекта и позволяет последовательно обходить его как
единую коллекцию без раскрытия деталей её реализации, например, обойти достопримечательности в Риме можно самому выбрать порядок
их обхода или воспользоваться гидом. Мы, как клиентский код, выбираем один из итераторов, отталкиваясь от решаемой задачи и
доступных ресурсов. Для этого создаем интерфейс Iterator для обхода объекта, например, реализовав IEnumerator и интерфейс Aggregate
для создания объекта-итератора, а также реализовываем ConcreteIterator алгоритмы обхода объекта переданного в интерфейс Aggregate,
и реализовав ConcreteAggregate1, например, принимает List<T> клиент может перебирать содержимое этого объекта. В итоге клиенты
получают возможность работать с разными коллекциями унифицированным образом, а классы коллекций становятся проще за счет того, что
ответственность за перебор ее элементов возлагается на отдельную сущность.
	Посредник (Mediator) - позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один
класс-посредник. Объекты не взаимодействуют друг с другом напрямую, вместо этого они взаимодействуют через медиатр. Тем самым
достигается слабосвязанность взаимодействующих объектов. Например, пилоты самолета не общаются между собой напрямую, чтобы
договариваться о полете, для этого есть диспетчер, который их координирует. Еще один пример это контроллер в MVC является
посредником между представлением и моделью. Для этого создает интерфейс Медиатор с методом Notify, через который коллеги будут
уведомлять Медиатор также добавляем базовый для всех Коллег класс, в котором агрегируем ссылку на Медиатор, а также реализуем 
КонкретныйМедиатор и агрегируем в нем всех созданных Коллег, а в методе Notify выполняем логику взаимодействия как Диспетчер.


##		Примеры и реализации порождающих паттернов.
	Абстрактная фабрика (Abstract Factory) - позволяет создавать набор семейств взаимосвязанных или родственных объектов не
привязываясь к конкретным классам создаваемых объектов, например, абстрактная фабрика мебели и ее семейства продуктов, например,
кресел, диванов или столов, представленных в разных стилях или GUI элементы, кнопки, окна и тд, которые могут отображаться на
разных ОС по разному. Для этого создаем интерфейс абстрактной фабрики мебели и его наследников concreteFactory1 - concreteFactoryN,
которые содержат методы создания всей мебели одного семейства CreateProductA - CreateProductB, и интерфейсы для разных семейств
ProductA - ProductB, которые содержат методы создания мебели в разных стилях, эти интерфейсы возвращаются из методов абстрактной
фабрики. В результате получаем фабрики, которые создают разную мебель, но каждая из них специализируется на определенному стиле.
	Фабричный метод (Factory Method) - определяет общий интерфейс для создания объектов, но базовый класс делегирует создание
объектов классам-наследникам, например, есть разные вентиляторы, а за постройку конкретного вентилятора отвечает своя фабрика.
Для этого создается интерфейс продуктов и его разные реализации, а также интерфейс фабрики с методом создания продукта и разные
реализации фабрик, которые специализируются на конкретном продукте. В итоге создаем экземпляр конкретной фабрики и вызываем метод
Create(), чтобы создать продукт.
	Строитель* (Builder) - позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код
строительства для получения разных представлений объектов. Например, постройка разных домов, которые состоят из одинаковых этапов
строительства, но из разных материалов. Для этого создаем интерфейс Builder, в котором описаны шаги строительства объекта, и его
разные реализации они же еще хранят экземпляр строящегося объекта, а так же еще класс Директор, который определяет какие шаги
нужно выполнить для построения объекта.

##		Примеры и реализации структурных паттернов.
	Адаптер (Adapter) - позволяет преобразовывать интерфейс одного класса в интерфейс другого. Он позволяет объектам с
несовместимыми интерфейсами работать вместе. Например, европейской зарядке нужен адаптер, чтобы подключиться к розетке в США или
есть интерфейс, который оперирует XML формате и появился еще и JSON, поэтому нужен адаптер, который будет конвертировать XML в
JSON. Для этого создаем интерфейс с определенным действием и сервис, который должен выполнять это действие, а также сам адаптер,
который реализует интерфейс в понятном для сервиса виде. Клиент просто создает экземпляр адаптера, передавая в конструктор нужный
сервис и вызывает нужное действие.
	Декоратор (Decorator) - позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»,
например, человек и разная одежда, которая дает разные бонусы. Для этого создаем общий интерфейс для продуктов и их конкретные
реализации, а также абстрактный декоратор, который наследуется от общего интерфейса продуктов и содержит связь через отношение 
агрегации, и реализуем этот декоратор разными способами предавая дополнительные свойства исходному продукту. В итоге клиент
создает экземпляр продукта и присваивает ему конкретный декоратор присваивая новые бонусы.
	Фасад (Facade) - предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку. Например, служба 
поддержки - нем ненужно самим разбираться в структуре их компании, чтобы решить проблему, достаточно позвонить оператору, а он сам
свяжется с кем нужно и решит проблему. Для этого создаем Фасад и в нем агрегируем нужные системы, а также методы, которые будут
решать определенные задачи, а клиент просто будет их вызывать.


		Cloud платформы. Опыт работы с одним из клаудов: Azure AWS Google Cloud. Понимание в чем разница между SaaS, PaaS, IaaS
		Terraform, CloudFormation
		Dependency injection антипаттерны:
		Load Balancer. Что такое Load Balancer? Какие алгоритмы распределения нагрузки вы знаете?
		
		Dapper vs EF
		Что делает браузер, чтобы отобразить страницу
		Жизненный цикл ASP.NET MVC приложения.txt
		Основы архитектуры IIS-конвейера обработки запроса.txt
		Что происходит с HTTP-запросом от момента его поступления на 80-й порт и до передачи управления странице.txt
		Эффективная работа с EntityFramework Core
		В каких случаях может пригодиться ValueTask?
		Транзакции в NoSQL, как поддерживать целостность бд и что такое eventual consistency?
		Скорость записи и чтения в NoSQL по сравнению с SQL БД.
		B-Tree  https://habr.com/ru/companies/quadcode/articles/696498/
		expression c#
		Hangfire — многопоточный и масштабируемый планировщик задач
		assplitquery 	https://learn.microsoft.com/ru-ru/ef/core/querying/single-split-queries


--Ссылки:
CLRium #4: IDisposable: https://www.youtube.com/watch?v=eGE8YqGD5d8&ab_channel=%D0%9C%D0%B8%D0%BD%D0%B8-%D0%BA%D0%BE%D0%BD%D1%84%D0%B5%D1%80%D0%B5%D0%BD%D1%86%D0%B8%D0%B8CLRium
Наглядная таблица с разными Join - https://sql-academy.org/ru/guide/outer-join
Репозиторий - https://bool.dev/blog/detail/pattern-repozitoriy-poeaa
Интеграционные тесты в ASP.NET Core - https://bool.dev/blog/detail/integratsionnye-testy-v-aspnet-core-prilozhenii
Вопросы на собеседовании для Senior C# / .NET Developer - https://bool.dev/blog/detail/voprosy-na-sobesedovanii-dlya-senior-net-developer
Когда hashtable быстрее чем статический массив - https://www.youtube.com/watch?v=K4sYJHuNgmE&ab_channel=Winderton
lazyLoading - https://youtu.be/pzas6e-ArpM?t=1020
Объяснение полезных Git команд с помощью визуализации - https://bool.dev/blog/detail/vizualizatsiya-poleznykh-git-komand
Branching стратегии в Git - https://bool.dev/blog/detail/git-branching-strategies
https://www.youtube.com/watch?v=nFEkZXD2wFI&ab_channel=loftblog
https://www.youtube.com/watch?v=jBvkN8_c7t8&ab_channel=loftblog

https://softwareengineering.stackexchange.com/questions/200115/what-is-early-and-late-binding/200123#200123

Rabbit + masTransit монады
денормализация БД в noSql

Alt+enter+создать конструктор=конструктор с инициализированными полями ))
In order to understand the request processing pipeline execution order in ASP.NET Core Application, let us compare the above output with the following diagram which we have created in our Middleware in ASP.NET Core article.

А вот нашел статью от Eric Lippert, где он говорит, что:
Virtual dispatch is a form of late binding; the decision about which method to associate with the syntax b.M(d) is partially made by the compiler and partially made by the runtime.