# Списки:
## Связный список
		Linked List, Двусвязный список, Кольцевой односвязный список, Кольцевой двусвязный список, Преимущества и недостатки.
	Связный список (Linked List) представляет набор связанных узлов, каждый из которых хранит собственно данные и ссылку
на следующий узел.
	Для хранения данных предназначено свойство Data. 
	Для ссылки на следующий узел определено свойство Next.
Методы:
	AddLast - добавление элемента в конец списка:
		При помощи tail(хвост) - указывает всегда на последний элемент списка. Сложность O(1) 
		Без помощи tail(хвост) - 					Сложность O(n)
	AddFirst - добавление элемента в начало списка.	Сложность О(1)
	Remove - удаление элемента. 					Сложность O(n)
	Contains - для проверки наличия элемента. 		Сложность O(n)
	Clear - удаляет все ссылки;
	IEnumerable - можно реализовать, чтобы список можно было бы перебрать во внешней программе 	с помощью цикла foreach.
		
	Двусвязный список, Кольцевой односвязный список, Кольцевой двусвязный список
	Двусвязные списки также представляют последовательность связанных узлов, однако теперь каждый узел хранит ссылку
на следующий и на предыдущий элементы.
	Кольцевой односвязный список являются разновидностью связных списков. Их отличительной особенностью является то,
что условный последний элемент хранит ссылку на первый элемент, поэтому список получается замкнутым или кольцевым.
	Кольцевой двусвязный список представляет замкнутый список,  в котором указатель на элемент может перемещаться 
как вперед, так и назад по кругу.

	ПРЕИМУЩЕСТВА списков
	Самое большое преимущество связанного списка заключается в добавлении и удалении объектов из списка. 
Внесение изменений в середину списка выполняется очень быстро т.к для изменения нужно просто изменить ссылки
на новый узел. 
	НЕДОСТАТКИ списков
	Произвольный доступ к связанному списку выполняется очень медленно. Т.к нет прямого доступа к любому элементу списка. 
Например, если вам нужно получить пятисотый элемент списка, то придётся начинать с начала цепочки и следовать по её
указателю к следующему элементу, потом к следующему,  и так далее, повторяя пятьсот раз.

==============================================================================================
				Стек
				Stack
			Стек представляет собой структуру данных, которая работает по принципу LIFO 
			(Last In First Out - "последний пришел - первый вышел").

	При добавлении и удалении из стека последний добавленный элемент будет первым удаляемым.
Для стека нужно всего три метода: 
	Push добавляет объект в стек
	Pop удаляет объект из стека
	Top даёт самый последний объект в стеке.
----------------------------------------------------------------------------------------------
				Очередь
				Queue
			Очередь представляет собой структуру данных, которая работает по принципу FIFO 
			(First In First Out, «первым зашёл, первым вышел»).

	При добавлении и удалении из очереди первый добавляемый элемент будет первым извлекаемым. 
Очереди нужно только несколько методов: 
	Push_Back добавляет элемент к концу очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	_________________________________________________________________________________________			
				Двухсторонней очередью
				Dequeue
			Программистам часто нужно добавлять или удалять элементы из обоих концов очереди. 
			Такая структура называется двухсторонней очередью 

	Push_Back добавляет элемент к концу очереди;
	Push_Front добавляет элемент в начало очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Pop_Back удаляет элемент из конца очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	_________________________________________________________________________________________			
				Очередь с приоритетом
				PriorityQueue
			Очередь с приоритетом очень похожа на обычную очередь.
		Программа добавляет элементы с конца и извлекает элементы из начала. 
	Разница в том, что можно задавать приоритеты определённым элементам очереди. 
	Все самые важные элементы обрабатываются в порядке FIFO. 
	Потом в порядке FIFO обрабатываются элементы с более низким приоритетом. 
	И так повторяется, пока не будут обработаны в порядке FIFO элементы с самым низким приоритетом.

			ЗАКЛЮЧЕНИЕ

	Стеки, очереди, двухсторонние очереди и очереди с приоритетом 
можно реализовать на основе других структур данных. Это не фундаментальные структуры данных, 
но их часто используют. 

			ПРЕИМУЩЕСТВА
	Они очень эффективны, когда нужно работать только с конечными элементами данных, 
а серединные элементы не важны.
			НЕДОСТАТКИ
	Видимо зависят от на какой структуре данных они были реализованы, но это не точно)
==============================================================================================
        Массив
    Массив представляет собой механизм, позволяющий рассматривать набор элементов как единую коллекцию.      
    Базовым для всех массивов является абстрактный класс System.Array, производный от System.Object. Массивы всегда относятся к
ссылочному типу и размещаются в управляемой куче, а переменная в приложении содержит не элементы массива, а ссылку на массив.
Поддерживаются массивы:
    Одномерные (single-dimension) [] SZ-массивы или векторами - одномерный массив с нулевым начальным индексом;
    Многомерные (multidimension) [,] или больше [,,];
    Нерегулярные (jagged) массивы массивов [][].
    Производительность одномерных нерегулярных массивов с нулевым начальным индексом такая же, как у обычных векторов. Однако
обращение к элементу нерегулярного массива означает обращение к двум или больше массивам одновременно. 
    Доступ к элементам одномерного массива с нулевой нижней границей осуществляется быстрее, чем доступ к элементам многомерных
массивов или массивов с ненулевой нижней границей. 
	Недостатки простого массива являются, если вам нужно неизменное количество объектов, то массив вполне подходит. Но если 
нужно добавить в массив ещё один элемент, то в простом массиве этого сделать невозможно. Или если нужно удалить элемент из 
массива. В простом массиве это так же невозможно. Т.к вы привязаны к одному количеству элементов. 
_____________________________________________________________________________________________                
		Динамический массив List
	Динамический массив — это массив, который может менять свой размер. В основе List лежит Array, но он имеет два
дополнительных блока данных Count и Capacity. В них хранятся действительный размер простого массива и объём данных, который
может на самом деле храниться в простом массиве.
	Недостатки динамических массивов
    Допустим, массив очень велик, а вам нужно часто добавлять и удалять объекты. При этом объекты могут часто копироваться в
другие места, а многие указатели становиться недействительными. Если вам нужно вносить частые изменения в середине динамического
массива, то для этого есть более подходящий тип линейной структуры данных
	Также можно получить утечку памяти дело в том, что при увеличении массива растёт его Capacity, но методы Clear, Remove не
уменьшает размер Capacity соответственно при очистке массива мы не уменьшаем его реальный зарезервированный объём памяти. В 
таком случае лучше использовать присвоение новой ссылки List = new List;

#Деревья и кучи.
		Binary Heap, Binary Search Tree, АВЛ-дерева, Обходы дерева, Балансировка узлов
    Двоичная куча - binary heap - представляет собой полное бинарное дерево, т.е у каждого узла не более двух потомков,
а так же все уровни полностью заняты данными, а последний заполнен слева направо. Двоичная куча может быть минимальной
или максимальной: 
    В максимальной куче ключ любого узла всегда больше ключей его потомков или равен им; 
    В минимальной куче ключ любого узла меньше ключей его потомков или равен им.
    Для чтения элемента с самым высоким приоритетом О(1);
    Для добавления и извлечения элементов О(log(n));
    Сортировка O(nLog(n)).
    Max - получение максимального элемента О(1);
    DelMax - удаление максимального элемента О(log(n)) - т.к. нужно делать балансировку;
    Add - добавление элемента О(log(n)) - т.к. нужно делать балансировку.
Балансировка:
    Заключается в выполнении Swap корневого элемента с узловым и так далее рекурсивно до самой вершины, до тех пор пока
родительский элемент не будет больше чем потомки.
Удаление:
    После удаления элемента вместо него переносится самый крайний добавленный элемент,
далее этот элемент балансируется с потомками, если нужно.
Формулы:
    Левый потом: 2i+1; Правый потомок 2i+2; Предок (i-1)/2.
    Благодаря этим формулам можно легко древовидный вид преобразовать в линейный и реализовать на массиве, чтобы получать
быстрый доступ к элементам.

	Двоичное дерево поиска
    Дерево — это структура данных, состоящая из узлов. 
Свойства деревьев:
    Каждое дерево имеет корневой узел (вверху). Корневой узел имеет ноль или более дочерних узлов. Каждый дочерний узел
имеет ноль или более дочерних узлов, и так далее.
Двоичного дерева поиска свойства:
    Каждый узел имеет до двух дочерних узлов (потомков).
    Каждый узел меньше своих потомков справа, а его потомки слева меньше его самого.
    Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой
операции пропорционально логарифму общего числа элементов в дереве.
Сложность:
    Search    O(log n);
    Insert    O(log n);
    Delete    O(log n).
Элементы, не имеющие потомков, называются листьями. А тот, что не имеет предка — корнем. 

    АВЛ-дерево — это прежде всего двоичное дерево поиска, ключи которого удовлетворяют стандартному свойствам бинарного
дерева, но особенностью АВЛ-дерева является то, что оно является сбалансированным в следующем смысле: 
    для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу. 

	Обходы дерева:
    Префиксный: - Для копирования дерева с сохранением позиций элементов.
        1 - текущий элемент; 2 - левый элемент; 3 - правый элемент.
    Постфиксный: - При удалении элементов дерева.
        1 - левый элемент; 2 - правый элемент; 3 - текущий элемент.
    Инфиксный: - Возвращает отсортированное дерево.
        1 - левый элемент; 2 - текущий элемент; 3 - правый элемент.
        
	Балансировка узлов
    В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение ситуации, когда balance factor некоторых
узлов оказывается равными 2 или -2, т.е. возникает разбалансировка поддерева.
    Выполняется левый или правый поворот. 
                y           x
            x      c     a    y
        a     b            b   c
    Большой поворот применяется при условии h(s)>h(D) и сводится к двум простым — сначала правый поворот вокруг q и затем 
левый вокруг p.








            
                
