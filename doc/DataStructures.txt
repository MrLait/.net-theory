Списки:
				Связный список
				Linked List
			Связный список (Linked List) представляет набор связанных узлов, 
			каждый из которых хранит собственно данные и ссылку на следующий узел.

Другими словами 
	В реальной жизни связный список можно представить в виде поезда, 
каждый вагон которого может содержать некоторый груз или пассажиров 
и при этом может быть связан с другим вагоном.

	Для хранения данных предназначено свойство Data. 
	Для ссылки на следующий узел определено свойство Next.

Методы:
	AddLast - добавление элемента в конец списка:
		При помощи tail(хвост) - указывает всегда на последний элемент списка
			Сложность O(1) 
		Без помощи tail(хвост) 
			Сложность O(n) - т.к есть необходимость перебора элементов для 
		нахождения последнего увеличивает время на поиск и сложность алгоритма.
	AddFirst - добавление элемента в начало списка
		Сложность О(1) - т.к ничего искать не нужно, а только перекинуть ссылки.

	Remove - удление элемента.
		Сложность O(n) - т.к есть необходимость перебора элементов для 
		нахождения удаляемого элемента, что увеличивает время на поиск и сложность алгоритма.

	Contains - для проверки наличия элемента.
		Сложность O(n) - т.к просто осуществляется перебор.

	Clear - удаляет все ссылки;

	IEnumerable - можно реализовать, чтобы список можно было бы перебрать во внешней прграмме 
	с помощью цикла foreach.
_____________________________________________________________________________________________
				Двусвязный список
				Doubly linked lists
			Двусвязные списки также представляют последовательность связанных узлов, 
			однако теперь каждый узел хранит ссылку на следующий и на предыдущий элементы.
Методы все теже.
_____________________________________________________________________________________________
				Кольцевой односвязный список
				CircularLinkedList
			Кольцевой односвязный список являются разновидностью связных списков. 
			Их отличительной особенностью является то, что условной последний элемент 
			хранит ссылку на первый элемент, поэтому список получается замкнутым или кольцевым.
_____________________________________________________________________________________________
				Кольцевой двусвязный список
				CircularDoublyLinkedList
			Кольцевой двусвязный список представляет замкнутый список, 
			в котором указатель на элемент может перемещаться как вперед, так и назад по кругу.

	Каждый узел такого списка опять же будет представлять элемент, 
который хранит указатели на следующий и предыдущий узлы.
	Однако, несмотря на то, что формально список замкнут, и у него нет начала и конца, 
все равно для некоторого базового отчета в таком списке будет храниться ссылка на первый элемент, 
относительно которого будет идти добавление новых элементов. В тоже время в отличие от 
кольцевого односвязного списка теперь уже не надо хранить указатель на формально последний элемент списка.
_____________________________________________________________________________________________
				ПРЕИМУЩЕСТВА списков
	Самое большое преимущество связанного списка заключается в добавлении и удалении объектов из списка. 
Внесение изменений в середину списка выполняется очень быстро т.к для изменения нужно просто изменить ссылки
на новый узел. 
				НЕДОСТАТКИ списков
	Произвольный доступ к связанному списку выполняется очень медленно. Т.к нет прямого доступа к любому элемента списка. 
Например, если вам нужно получить пятисотый элемент списка,
то придётся начинать с начала цепочки и следовать по её указателю к следующему элементу, потом к следующему, 
и так далее, повторяя пятьсот раз.

==============================================================================================
				Стек
				Stack
			Стек представляет собой структуру данных, которая работает по принципу LIFO 
			(Last In First Out - "последний пришел - первый вышел").

	При добавлении и удалении из стека последний добавленный элемент будет первым удаляемым.
Для стека нужно всего три метода: 
	Push добавляет объект в стек
	Pop удаляет объект из стека
	Top даёт самый последний объект в стеке.
----------------------------------------------------------------------------------------------
				Очередь
				Queue
			Очередь представляет собой структуру данных, которая работает по принципу FIFO 
			(First In First Out, «первым зашёл, первым вышел»).

	При добавлении и удалении из очереди первый добавляемый элемент будет первым извлекаемым. 
Очереди нужно только несколько методов: 
	Push_Back добавляет элемент к концу очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	_________________________________________________________________________________________			
				Двухсторонней очередью
				Deque
			Программистам часто нужно добавлять или удалять элементы из обоих концов очереди. 
			Такая структура называется двухсторонней очередью 

	Push_Back добавляет элемент к концу очереди;
	Push_Front добавляет элемент в начало очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Pop_Back удаляет элемент из конца очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	_________________________________________________________________________________________			
				Очередь с приоритетом
				PriorityQueue
			Очередь с приоритетом очень похожа на обычную очередь.
		Программа добавляет элементы с конца и извлекает элементы из начала. 
	Разница в том, что можно задавать приоритеты определённым элементам очереди. 
	Все самые важные элементы обрабатываются в порядке FIFO. 
	Потом в порядке FIFO обрабатываются элементы с более низким приоритетом. 
	И так повторяется, пока не будут обработаны в порядке FIFO элементы с самым низким приоритетом.

			ЗАКЛЮЧЕНИЕ

	Стеки, очереди, двухсторонние очереди и очереди с приоритетом 
можно реализовать на основе других структур данных. Это не фундаментальные структуры данных, 
но их часто используют. 

			ПРЕИМУЩЕСТВА
	Они очень эффективны, когда нужно работать только с конечными элементами данных, 
а серединные элементы не важны.
			НЕДОСТАТКИ
	Видимо зависят от на какой структуре данных они были реализованы, но это не точно)
==============================================================================================
