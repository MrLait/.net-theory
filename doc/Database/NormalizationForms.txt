# Реляционная база данных 
    Реляционная база данных  – это набор данных с предопределенными связями между ними. Эти данные организованны в виде набора таблиц, 
состоящих из столбцов и строк. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке – значение атрибута. 
Каждая стока таблицы представляет собой набор связанных значений, относящихся к одному объекту или сущности, а строка может быть 
помечена уникальным идентификатором, называемым первичным ключом, или с помощью внешних ключей.

# Важные аспекты реляционных БД
    SQL (Structured Query Language) – основной интерфейс работы с реляционными базами данных. SQL используется для добавления, 
обновления и удаления строк данных, извлечения наборов данных для обработки транзакций и аналитических приложений, а также для 
управления всеми аспектами работы базы данных.

    Целостность данных – это полнота, точность и единообразие данных. Для поддержания целостности данных в реляционных БД используется 
ряд инструментов. В их число входят первичные ключи, внешние ключи, ограничения «Not NULL», «Unique», «Default» и «Check». 
Эти ограничения целостности позволяют применять практические правила к данным в таблицах и гарантировать точность и надежность данных. 
Большинство ядер БД также поддерживает интеграцию пользовательского кода, который выполняется в ответ на определенные операции в БД.

    Транзакции – это один или несколько операторов SQL, выполненных в виде последовательности операций, представляющих собой единую 
логическую задачу. Транзакция представляет собой неделимое действие, то есть она должна быть выполнена как единое целое и либо должна 
быть записана в базу данных целиком, либо не должен быть записан ни один из ее компонентов. Транзакция завершается либо 
действием COMMIT, либо ROLLBACK. Каждая транзакция рассматривается как внутренне связный, надежный и независимый от других транзакций 
элемент.

    Соответствие требованиям ACID
Для соблюдения целостности данных все транзакции в БД должны соответствовать требованиям ACID, то есть быть атомарными, 
единообразными, изолированными и надежными.    
    Атомарность – это условие, при котором либо транзакция успешно выполняется целиком, или, если какая-либо из ее частей 
не выполняется, вся транзакция отменяется. 
    Единообразие – это условие, при котором данные, записываемые в базу данных в рамках транзакции, должны соответствовать 
всем правилам и ограничениям, включая ограничения целостности, каскады и триггеры. 
    Изолированность - необходима для контроля над согласованностью и гарантирует базовую независимость каждой транзакции. 
    Надежность - подразумевает, что все внесенные в базу данных изменения на момент успешного завершения транзакции считаются постоянными.


# Нереляционные данные и базы данных NoSQL
    Нереляционные базы данных — это база данных, в которой в отличие от большинства традиционных систем баз данных не используется 
табличная схема строк и столбцов. В этих базах данных применяется модель хранения, оптимизированная под конкретные требования 
типа хранимых данных. Например, данные могут храниться как простые пары "ключ — значение", документы JSON или графов.
   
Термин NoSQL применяется к хранилищам данных, которые не используют язык запросов SQL, а запрашивают данные с помощью других 
языков и конструкций. На практике NoSQL означает "нереляционная база данных", даже несмотря на то, что многие из этих баз данных 
поддерживают запросы, совместимые с SQL. 

## Хранилища данных документов
    Хранилище данных документов управляет набором значений именованных строковых полей и данных объекта в сущности, 
которая называется документом. Обычно данные в этих хранилищах содержатся в виде документов JSON. Каждое значение поля может 
представлять собой скалярный элемент, например число, или сложный объект, например список или коллекция типа "родитель — потомок". 
    Данные в полях документа можно закодировать разными способами, например в формате XML, YAML, JSON, BSON, или хранить в виде 
обычного текста. Поля документов доступны системе управления хранилищем, что позволяет приложению выполнять запросы и применять фильтры, 
основанные на значениях этих полей.
Как правило, документ содержит все данные одной сущности. Например, сущность может содержать сведения о клиенте, заказе или и те, и другие. 
Один документ может содержать сведения, которые в реляционной СУБД обычно распределяются по нескольким реляционным таблицам. 
Хранилище документов не обязывает использовать одинаковую структуру для всех документов. Поддержка свободной формы обеспечивает 
большую гибкость. 
    Приложения могут хранить в документах разные данные в соответствии с текущими требованиями компании
    Приложение может получать документы по ключу документа. Это уникальный идентификатор документа. Часто к нему применяется хэширование 
для равномерного распределения данных.
    Могут создают ключ документа автоматически или указать ключ самому. 
    Приложение может запрашивать документы по значениям одного или нескольких полей. 
    Поддерживают индексирование, что ускоряет поиск документов по одному или нескольким индексированным полям. 
    Поддерживают обновления "на месте", то есть позволяют приложению изменять значения отдельных полей без перезаписи всего документа. 
    Операции чтения и записи для нескольких полей в одном документе обычно являются атомарными.
        
## Столбчатые хранилища данных
    Столбчатое хранилище данных или хранилище семейств столбцов упорядочивает данные по столбцам и строкам. Такие хранилища в простейшей 
форме почти неотличимо от реляционной базы данных, по крайней мере организационно. Преимущество столбчатого хранилища данных заключается в 
способности денормализованно структурировать разреженные данные, что связано со столбцово-ориентированным методом хранения данных.
    Столбчатое хранилище данных можно представить как набор табличных данных со строками и столбцами, в которых столбцы разделяются на 
определенные группы или семейства столбцов. Каждое семейство столбцов включает набор логически связанных столбцов, которые 
обычно извлекаются или управляются как единое целое. Другие данные, которые используются в других процессах, хранятся отдельно в других 
семействах столбцов. В семейство столбцов можно динамически добавить новые столбцы, а строки могут быть разреженными то есть строки не 
обязаны иметь значение для каждого столбца.

    В отличие от хранилища пар "ключ — значение" и баз данных документов, большинство столбчатых баз данных упорядочивают хранимые 
данные с помощью самих значений ключей, а не хэш-кодов от них. Ключ строки рассматривается как первичный индекс и обеспечивает доступ 
на основе определенного ключа или их диапазона. Некоторые реализации позволяют создавать вторичные индексы по определенным столбцам 
в семействе столбцов. Вторичные индексы позволяют получать данные по значениям столбцов, а не ключам строки.
Все столбцы одного семейства хранятся на диске в одном файле. Каждый файл содержит определенное число строк. Этот подход позволяет 
повысить производительность за счет снижения объема данных, которые необходимо считывать с диска, когда отправляется запрос на получение 
нескольких столбцов за раз.Операции чтения и записи для строки обычно являются атомарными в пределах одного семейства столбцов, 
хотя некоторые реализации обеспечивают атомарность по всей строке, охватывающую несколько семейств столбцов.

## Хранилище пар "ключ — значение"
    Хранилище пар "ключ — значение" по сути представляет собой большую хэш-таблицу. Каждое значение сопоставляется с уникальным ключом, 
и хранилище ключей использует этот ключ для хранения данных, применяя к нему некоторую функцию хэширования. Выбор функции хэширования 
должен обеспечить равномерное распределение хэшированных ключей по хранилищу данных. Большинство хранилищ пар "ключ — значение" 
поддерживают только самые простые операции запроса, вставки и удаления. Чтобы частично или полностью изменить значение, 
приложение всегда перезаписывает существующее значение целиком. В большинстве реализаций атомарной операцией считается чтение или запись 
одного значения. Запись больших значений занимает относительно долгое время. Приложение может хранить в наборе значений 
произвольные данные, но некоторые хранилища пар "ключ — значение" накладывают ограничения на максимальный размер значений. 
Программное обеспечение хранилища ничего не знает о значениях, которые в нем хранятся. Все сведения о схеме поддерживаются и применяются 
на уровне приложения. Эти значения по существу являются большими двоичными объектами, которые хранилище извлекает и сохраняет по 
соответствующему ключу.

    Хранилища пар "ключ — значение" рассчитаны на приложения, выполняющие простые операции поиска на основе значения ключа или 
диапазона ключей, но не очень подходят для систем, которым нужно запрашивать данные из нескольких таблиц хранилищ пар "ключ — значение", 
например присоединенные данные в нескольких таблицах. Кроме того, хранилища пар "ключ — значение" неудобны в сценариях, где могут 
выполняться запросы или фильтрация по значению, а не только по ключам. Например, с помощью реляционной базы данных можно найти запись, 
используя предложение WHERE для фильтрации неключевых столбцов, но в хранилищах "ключ-значение" обычно отсутствует возможность поиска в 
значениях, или, если они есть, требуется медленный Просмотр всех значений.
    Одно хранилище пар "ключ — значение" очень легко масштабируется, поскольку позволяет удобно распределить данные среди нескольких 
узлов на разных компьютерах.
    
## Хранилища данных графов
   Хранилища данных графов управляют сведениями двух типов: узлами и ребрами. Узлы в этом случае представляют сущности, а ребра определяют 
связи между ними. Узлы и грани имеют свойства, которые предоставляют сведения о конкретном узле или грани, примерно как столбцы в 
реляционной таблице. Грани могут иметь направление, указывающее на характер связи. Хранилища данных графов позволяют приложениям 
эффективно выполнять запросы, которые проходят через сеть узлов и ребер, а также анализировать связи между сущностями.
На схеме ниже представлены данные персонала организации, структурированные в виде графа. 

## Хранилища данных временных рядов
    Данными временных рядов называются наборы значений, которые упорядочены по времени. Соответственно хранилища данных временных 
рядов оптимизированы для хранения данных именно такого типа. Хранилища данных временных рядов должны поддерживать очень большое число 
операций записи, так как обычно в них в режиме реального времени собирается большой объем данных из большого количества источников. 
Эти хранилища также хорошо подходят для хранения данных телеметрии. Например, для сбора данных от датчиков Интернета вещей или счетчиков 
в приложениях или системах. Обновления в таких базах данных выполняются редко, а удаление чаще всего является массовой операцией.

## Хранилище данных объектов
    Хранилища данных объектов оптимизированы для хранения и извлечения больших двоичных объектов, например изображений, текстовых файлов, 
видео- и аудиопотоков, объектов данных и документов приложений большого размера, образы дисков виртуальных машин. Объект состоит из 
сохраненных данных, метаданных и уникального идентификатора доступа к объекту. Хранилища объектов поддерживают отдельные большие файлы, 
а также позволяют управлять всеми файлами за счет внушительного общего объема хранилища.
    Часто хранилища данных объектов используют как сетевые общие папки. Доступ к файлам, хранящимся в этих папках, 
можно получить через компьютерную сеть с использованием стандартных сетевых протоколов, например SMB. Учитывая соответствующие механизмы 
обеспечения безопасности и параллельного управления доступом, совместное использование данных позволяет распределенным службам обеспечить 
высокую масштабируемость доступа к данным для базовых операций низкого уровня, таких как простые запросы на чтение и запись.

## Хранилища данных внешних индексов
    Хранилища данных внешних индексов позволяют искать информацию, содержащуюся в других хранилищах данных и службах. 
Внешний индекс выступает в роли вторичного индекса любого хранилища данных. Кроме того, с его помощью можно индексировать большие объемы данных и предоставлять доступ к этим индексам почти в реальном времени.
Например, в файловой системе могут храниться текстовые файлы. По пути файл можно найти быстро, но поиск на основе содержимого выполняется медленно, так как сканируются все файлы. Внешний индекс позволяет создавать вторичные индексы, а затем быстро искать путь к файлам, соответствующим заданным условиям. Рассмотрим еще один пример использования внешнего индекса. Предположим, что хранилища пар "ключ — значение" поддерживают индексирование только по ключу. Вы можете создать вторичный индекс на основе значений данных и быстро найти ключ, однозначно определяющий каждый соответствующий элемент.
Индексы создаются в процессе индексирования, который может выполняться по модели извлечения, то есть по требованию хранилища данных, или по модели передачи, то есть по команде из кода приложения. В некоторых системах поддерживаются многомерные индексы и полнотекстовый поиск по большим объемам текстовых данных.
Хранилища данных внешнего индекса часто используются для поддержки полнотекстового поиска. В этих случаях поддерживается точный или нечеткий поиск. Нечеткий поиск находит документы, которые соответствуют набору условий, и вычисляет для них коэффициент совпадения с этим набором. Некоторые внешние индексы также поддерживают лингвистический анализ, который возвращает соответствия с учетом синонимов, категорий (например, при поиске по запросу "собаки" соответствием считается "питомцы") и морфологии (например, при поиске по запросу "бег" соответствием считается "бегущий").

# Сведения о формате JSON
    Данные JSON (нотация объектов JavaScript) представлены в виде пар "ключ — значение" в частично структурированном формате. 
JSON часто сравнивают с XML, так как они могут хранить данные в иерархическом формате. Дочерние данные в них представлены вместе с 
родительскими. Оба формата являются самоописывающими и удобочитаемыми для пользователя, однако документы JSON, как правило, намного меньше. 
Поэтому их чаще используют при сетевом обмене данными, особенно с появлением веб-служб на базе REST.
Файлы в формате JSON имеют несколько преимуществ по сравнению с CSV-файлами.
    JSON поддерживает иерархические структуры, упрощая хранение связанных данных в одном документе и представление сложных связей.
    Большинство языков предоставляют упрощенные библиотеки сериализации JSON или встроенную поддержку десериализации JSON в объекты.
    JSON поддерживает списки объектов, помогая избежать беспорядочных преобразований списков в реляционную модель данных.
    JSON — это широко используемый формат файлов для баз данных NoSQL, таких как MongoDB, Couchbase и Azure Cosmos DB.
    Так как множество данных передачи уже находится в формате JSON, большинство веб-языков изначально поддерживают работу с JSON или 
используют внешние библиотеки для сериализации и десериализации данных JSON. Благодаря этой поддержке JSON используют в логических 
форматах посредством представления структуры данных, форматах обмена для горячих данных и хранилищах для холодных данных.
________________________________________________________________________________

# Нормализация
    Удаление избыточности данных. Избыточность, когда мы храним большеданных, чем это необходимо.
    Избыточность ведет к:
        Увелиению занимаемого места на диске;
		Аномалиям включения, обновления, удаления.

## 1 Нф
    Переменная отношения находится в первой нормальной форме тогда и только тогда, когда в любом допустимом значении отношения
каждый его кортеж содержит только одно значение для каждого из атрибутов.
		
Другими словами:
	В каждой клеточке таблицы должно быть только одно значение;
	Не должно быть повторябщихся строк.
Пример:
До                                        После     
____________________________________        __________________________________
name            |   hobbies         |       name            | hobbies       |
Cуворов Алексей |   Коньки, Мотоцикл|       Cуворов Алексей | Коньки        |
____________________________________|       Суворов Алексей | Мотоцикл      |
                                          __________________________________|

## 2 Нф
    Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и 
каждый неключевой атрибутов неприводимо зафисит от ее потенциального ключа.

Другими словами:
	Таблица в 1НФ;
	Есть первичный ключ;
	Все атрибуты зависят от первичного ключа целикм, а не от какой-то его части.
	
	Решение декомпозиция таблицы - разделение таблицы на несколько, в кторых есть 
свой уникальный первичный ключ.

## 3 НФ
	Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и 
отсутствуют транзитивные функциональне зависимости неключевых атрибутов от ключевых.
		
Другими словами:
	Таблица в 2НФ;
	Все атрибуты зависят только от первичного ключа, но не от других атрибутов.

Решается декомпозицией таблиц

## Усиленная 3 НФ. Нормальная форма Бойска-Кода
	Переменная отношения находится в нормальной форме Бойска-Кода тогда и только тогда, когда каждая её нетривиальная и неприводимая 
слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.

Другими словами:
	Таблица в 3 НФ;
	Ключевые атрибуты не должны зависеть от не ключевых.

## 4 НФ
	Переменная отношения находится в четвертой нормальной форме, если она находится в нормальной форме Бойска-Кода и не содержит
нетривиальных многознаных зависимостей.

Другими словами:
	Таблица в НФ Бойска-Кода;
	Устраняются нетривиальные многозначные зависимости.
		
До									После декомпозиции
________________________________________	____________________	________________________
name_id |   hobbies     |   project     |   name_id |   hobbies |   name_id |   project     |
1       |   Коньки      |   Сантехник   |   1       |   Коньки  |   1       |   Сантехник   |
1       |   Мотоцикл    |   Дизайнер    |   1       |   Мотоцикл|   1       |   Дизайнер    |
________________________________________|   ____________________|   ________________________|

## 5 НФ. Проекционно-соединительная нормальная форма
	Переменная отношения находится в пятой нормальной форме тогда и только тогда, когда каждая нетривиальная зависимость соединения в ней
определяется потенциальным ключом или ключами этого отношения.

Другими словами:
	Таблица в 4 НФ;
	Устраняются нетривиальные зависимости;
	Провести декомпозиция без потерь. таким образом, что бы при объединении 
декомпозированных таблиц мы получили исходную таблицу.

# Связи таблиц
## Связь «Один к одному»
    Связь один к одному образуется, когда ключевой столбец присутствует в другой таблице, 
в которой тоже является ключом либо свойствами столбца задана его уникальность.
    Например: перенос паспортных данных сотрудника в другу таблицу с целью обезопасить персональные данные,
доступ к которой предоставляется ограниченному кругу лиц.
    или может использоваться для разделения очень широких таблиц.

## Связь один-ко-многим
	Записи первой таблицы соответствует несколько записей в другой таблице, 
но запись в другой таблице не может иметь более одной соответствующей ей записи в исходной таблице.

## Связь «Многие ко многим»
	Если нескольким записям из одной таблицы соответствует несколько записей из другой таблицы, 
то такая связь называется «многие ко многим» и организовывается посредством связывающей таблицы.	

people - id | name | last_name и books - id | name | author
    Что бы сохранить связь (кому какая книга нравится) нужна связь многие ко многим, 
которая реализуется посредством третьей таблици:
people_book_like - people_id | book_id | liked_time
________________________________________________________________________________
# База данных (БД) 
    База данных — это организованная структура, предназначенная для хранения информации.
## СУБД
    СУБД — это комплекс программных средств, предназначенных для создания структуры новой базы, наполнения ее содержимым, редактирования 
содержимого и визуализации информации. Например Access, MSSql
    В отличие от табличного процессора Excel, Access имеет более развитые средства для отбора данных из взаимосвязанных таблиц, 
формирования новых таблиц и отчетов.

## Типы таблиц и ключей в реляционных базах данных
    Реляционные базы данных характеризуются наличием некоторых типов таблиц и ключей, позволяющих определить отношения между таблицами. 
Для того чтобы понять принципы разработки реляционных баз данных, требуется дать определения различных типов реляционных ключей и таблиц:
    Базовая таблица. 
В реляционной базе данных базовой таблицей называется таблица, которая включает один или несколько столбцов свойств объекта и содержит 
первичный ключ, который однозначно определяет этот объект. Более того, базовая таблица должна содержать первичный ключ. 
Базовые таблицы часто называют первичными, поскольку они имеют первичный ключ.
    Промежуточная таблица. 
Таблица, не являющаяся базовой, которая используется для обеспечения связей между другими таблицами, называется таблицей отношений. 
Ключевые поля в таблицах отношений должны быть внешними ключами, связанными с первичными ключами базовой таблицы. Таблица отношений 
состоит только из внешних ключей и не содержит независимых элементов данных.
    Первичный ключ. 
Первичный ключ состоит из набора значений, которые однозначно определяют запись базовой таблицы. Любому значению первичного ключа 
должна соответствовать одна и только одна строка таблицы. Первичный ключ включает одно поле только в том случае, если это поле не 
содержит повторяющихся значений.
    Составные ключи. 
Если для выполнения условий, накладываемых на значения первичного ключа, заданный ключ включает несколько полей таблицы, то тогда он 
называется составным.
    Внешние ключи. 
Внешний ключ — это столбец, значения которого соответствуют значениям первичного ключа другой связанной таблицы. 

## Основные объекты: 
    Основные объекты окна БД имеют следующее назначение:
    Таблица — основное средство для хранения информации в БД;
    Запрос — это инструмент для извлечения необходимой информации из исходных таблиц и представления ее в удобной форме;
    Форма — это основное средство для ввода данных, управления СУБД и вывода результатов на экран монитора;
    Отчет — это специальное средство для формирования выходных документов и вывода их на принтер;
    Макросы в Access представляют собой совокупность внутренних команд, предназначенных для автоматизации работы с БД;
    Модули являются программами, создаваемыми средствами языка VBA, и похожи на макросы в Word и Excel.

## Хранимые процедуры
    Хранимые процедуры представляют собой набор команд SQL, которые могут компилироваться и храниться на сервере. Таким образом, вместо 
того, чтобы хранить часто используемый запрос, клиенты могут ссылаться на соответствующую хранимую процедуру. Это обеспечивает лучшую 
производительность, поскольку данный запрос должен анализироваться только однажды и уменьшается трафик между сервером и клиентом.
Концептуальный уровень можно также повысить за счет создания на сервере библиотеки функций.

    Это может быть полезным тогда, когда:
        многочисленные приложения клиента написаны в разных языках или работают на других платформах, но нужно использовать ту же 
базу данных операций
   
    Хранимые процедуры и функции (подпрограммы) могут обеспечить лучшую производительность потому, что меньше информации требуется для 
пересылки между клиентом и сервером. Выбор увеличивает нагрузку на сервер БД, но снижает затраты на стороне клиента. 
Используйте это, если много клиентских машин (таких как Веб-серверы) обслуживаются одной или несколькими БД.

Привилегии:
    CREATE ROUTINE для создания хранимых процедур
    ALTER ROUTINE необходимы для изменения или удаления процедур. Эта привилегия автоматически назначается создателю  процедуры (функции)
    EXECUTE привилегия потребуется для выполнения подпрограммы. Автоматически назначается создателю процедуры (функции). 

Синтаксис хранимых процедур и функций:
    Хранимые подпрограммы создаются с помощью выражений 
    CREATE PROCEDURE или CREATE FUNCTION. 
Хранимая подпрограмма вызывается, используя выражение CALL, причем только возвращающие значение переменные используются в качестве выходных. 
Функция может быть вызвана подобно любой другой функции и может возвращать скалярную величину. Хранимые подпрограммы могут вызывать 
другие хранимые подпрограммы.

## Триггеры
    Триггер представляет собой хранимую процедуру, которая активизируется при наступлении определенного события. Например, можно задать 
хранимую процедуру, которая срабатывает каждый раз при удалении записи из транзакционной таблицы - таким образом, обеспечивается 
автоматическое удаление соответствующего заказчика из таблицы заказчиков, когда все его транзакции удаляются.

Синтаксис создания триггера
    именем триггера
    именем пользователя
    Время_триггера
Определяет время свершения действия триггера. 
BEFORE означает, что триггер выполнится до завершения события срабатывания триггера, а 
AFTER означает, что после. Например, при вставке записей наш триггер срабатывал до фактической вставки записи и вычислял сумму;
    Событие_срабатывания_триггера
Здесь все проще. Тут четко обозначается, при каком событии выполняется триггер.
INSERT: т.е. при операциях вставки или аналогичных ей выражениях (INSERT, LOAD DATA, и REPLACE)
UPDATE: когда сущность (строка) модифицирована
DELETE: когда запись удаляется (запросы, содержащие выражения DELETE и/или REPLACE)

## Структура индекса
https://habr.com/ru/post/247373/
    Индексы создаются для столбцов таблиц и представлений. 
Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. 
Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными, 
используя значения первичного ключа, то SQL Server сначала найдет значение индекса, 
а затем использует индекс для быстрого нахождения всей строки с данными. 
Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, 
что может оказать значительное влияние на производительность.
Ускорение работы с использованием индексов достигается в первую очередь за счёт того, 
что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.

Индексы используются для увеличения производительности БД, но есть случаи, когда нам стоит избегать их использования:
Не стоит использовать индексы для небольших таблиц.
Не стоит использовать индексы для таблиц, в которых, как предполагается, 
будут часто добавляться новые данные, либо эти данные будут изменяться.
Не стоит использовать индекс для колонок, с которыми будут производиться частые манипуляции.
Не стоит использовать индексы для колонок, которые имеют много значений NULL.

##Представления или Views 
представляют виртуальные таблицы, содержащие запросы, 
которые динамически извлекают используемые данные.

Представления дают нам ряд преимуществ. 
Они упрощают комплексные SQL-операции. 
Они защищают данные, так как представления могут дать доступ к части таблицы, а не ко всей таблице. 
Представления также позволяют возвращать отформатированные значения из таблиц в нужной и удобной форме.

