# IIS и HTTP.SYS
    В первую очередь начинает работу веб-сервер IIS Internet Information Services от компании Microsoft, который
при помощи драйвера HTTP.SYS в режиме ядра Kernel прослушивает HTTP и HTTPS входящие запросы, кэширует, 
анализирует и перенаправляет их зарегистрированному приложению в нужный пул приложений, который 
может быть как веб-сайтом, так и виртуальным каталогом внутри веб-сайта IIS. 
    IIS определяет число запросов, которые могут обрабатываться единовременно на одном ядре процессора 
компьютера. Если количество входящих запросов превышает это число, то все дополнительные запросы помещаются в 
очередь ожидания, которая также имеет свой лимит. Таким образом, запросы пользователей никуда не пропадают, 
и они вообще не замечают каких-то перебоев в работе сайтов под управлением IIS. Если же и данная очередь 
уже заполнена, то входящий запрос отвергается, а браузеру в ответ посылается статусный код ошибки 503.

    Когда от пользователя приходит новый запрос он перехватывается драйввером HTTP.SYS. 
W3SVC обращается к WAS. В свою очередь WAS считывает данный из файла ApplicationHost.config 
пул приложения и конфигурационные настройки сайта. Служба WAS передаёт эту информацию WWW-службе, 
а та уже, в свою очередь, настраивает HTTP.sys на прослушку конкретных портов, разбор IP и заголовка 
запрашиваемого сайта и, возможно, других параметров драйвера. Сам запрос попадает в очередь
порта завершения ввода-вывода (I/O completion port), и так же создается кэширование вывода.

# Процесс Svchost.exe
## World Wide Web Publishing Service (W3SVC)
   World Wide Web Publishing Service сокращенно WWW service - это адаптер для HTTP.SYS, работающий
в контексте процесса Svchost.exe и выполняющий функции в 7.0+ версии:
    Настройки драйвера HTTP.sys;
    Мониторинг показателей производительности веб-сайтов. Ведёт счётчики производительности 
и предоставляет их показатели веб-сайтами и кэшу IIS.   

## Windows Process Activation Service (WAS)
    Windows Process Activation Service (WAS) - это служба запускается системой в единственном экземпляре и управляет: 
    Рабочими процессами; 
    Временем жизни рабочих процессов;
    Считывает конфигурационную информацию о веб-приложениях и пулах приложений из файла ApplicationHost.config;
    Выполняет сопоставление между пулами приложений и рабочими процессами. Если соответствующий 
пулу приложения рабочий процесс еще не запущен, то менеджер приложение его запускает.

# Application Pool
    Пока конфигурировался HTTP.SYS cлужба WAS запускает рабочий процесс W3WP.exe для пула приложений, 
если он ещё не был запущен:
    Загружает в него согласно конфигурации приложения требуемые обработчики протоколов процессов (process protocol handler PPH); 
    Посредством менеджера приложений ApplicationManager создаёт внутри рабочего процесса домен приложения, в котором 
будет хоститься приложение. Менеджер приложений загружает код приложения в домен приложения и требуемые обработчики 
протоколов уровня приложения (AppDomain protocol handlers ADPH) для обработки сообщений по соответствующим сетевым протоколам.

    Обработчики протоколов – потокозависимые компоненты внутри рабочего процесса, 
ответственные за обмен данными между конкретным адаптером и рабочим процессом.     
    Менеджер приложений управляет созданием и утилизацией доменов приложений (application domains), 
которые хостятся внутри рабочего процесса.
    В конфигурационном файле веб-сервера ApplicationHost.config вместе с настройками приложений хранятся 
связки (bindings), определяющие параметры входящих запросов, которые будут направляться данному 
приложению. Такими параметрами являются название сетевого протокола, IP-адрес сервера, доменное имя и порт сайта. 
Эти параметры должны быть уникальными среди работающих приложений для однозначной идентификации 
целевого приложения. 

    Пул приложений стал нововведением в IIS 6 и был призван обеспечить изоляцию веб-приложений друг от друго и тем 
самым повысить стабильность работы веб-сервера в целом. Код приложения выполняется внутри процесса Windows – w3wp.exe. 
Поэтому исключение внутри веб-приложения приведёт к краху только этого процесса и никак не повлияет на доступность 
веб-приложений в других пулах и работу служб IIS. Более того, служба WAS попытается заново запустить упавший сайт, 
и внешние клиенты могут даже не заметить проблем в работе сервера.

# ASP.NET
    И так в результате прихода запроса с расширением, например, .aspx; .ashx; .mvc. будет перехвачено 
ISAPI - aspnet_isapi.dll, который обращает к проессу ASP.NET.
    Далее ApplicationManager создаёт внутри рабочего процесса домен приложения, в котором будут храниться объекты связанный
с нашим веб-сайтом.
    В созданном домене приложения будет конфигурироватся объект класса HostingEnvironment, который предоставляет 
доступ к информации о приложении, в частности, он сообщает имя и каталог приложения.
    После создания домена приложения также создаются и инициализируются такие объекты, как 
    HttpContext, 
    HttpRequest - содержит информацию о текущем запросе, включая файлы cookie и 
информацию о браузере;
    HttpResponse - cодержит ответ, отправляемый клиенту, который включает в себя все 
обработанные выходные данные и файлы cookie.

    Запрос, который пришел от клиента он попадает в HttpContext, а именно данные, который получили от клиена
превращаются в свойство объекта HttpRequest.
    Для обработки HttpContext, создается HttpAplication. Если в приложении определен 
файл Global.asax, то ASP.NET в качестве приложения создает экземпляр Global.asax, 
который наследуется от класса HttpApplication.
    
    Если придет одновременно несколкьо запросов, то будет созданно нескоько HttpContext и 
HttpAplication, каждый запрос будет обробатываться в отдельном потоке, для повышения 
производительностьи запросы могут использовать уже созданный HttpAplication.
    
    Запрос начинает обрабатываться в конвейере класса HttpApplication

# МАРШРУТИЗАЦИЯ (CORE ROUTING)
    Начальной точкой всей системы маршрутизации является UrlRoutingModule.
Этот модуль зарегестрирован по умолчанию во всех приложениях ASP.NET MVC, а весь набор маршрутов 
определяется в файле RouteConfig.cs. А сама регистрация маршрутов происходит в методе 
Application_Start строкой RouteConfig.RegisterRoutes(RouteTable.Routes). 
Для каждого приложения имеется только один объект коллекции маршрутов RouteTable.

В IIS 6 модуль UrlRoutingModule регистрируется в файле web.config.
Модуль HTTP – это класс.NET, реализующий интерфейс IHttpModule.

    Задача маршрутизации состоит в том, чтобы:
    Распознать и проанализировать входящий URL; 
    Заполнить контекст запроса, который могут использовать последующие компоненты.
    
    Система маршрутизации в проверяет, соответствует ли входящий URL какому-то файлу на диске, таких как .gif, .jpeg.
или WebForms (.aspx). Если да, то маршрутизация завершается и IIS продолжает обработку запроса.
    Но, если входящий URL не соответствует файлу на диске,а например, запросы к контроллерам MVC, то 
система маршрутизации исследует текущую конфигурацию для того, чтобы определить как обработать входящий URL.
    В системе маршрутизации есть Таблица маршрутизации, которая хранится в статичной коллекции RouteTable. 
Каждая запись в коллекции представляет собой шаблон для допустимых URL адресов и указывает на обработчик 
маршрута route handler – объект, реализующий интерфейс IRouteHandler, который принимает и обрабатывает запрос. 
    Для поиска соответствия запроса HTTP конкретному маршруту из RouteTable.Routes, 
система маршрутизации начинает сканировать коллекцию RouteTable.Routes сверху вниз и выбирает первый найденный маршрут, 
соответствующий входящему запросу. Найдя его, система маршрутизации передает управление обработчику маршрута, 
обеспечивая его контекстом запроса, описывающим выбранный маршрут и все параметры URL адреса.

# КОНТРОЛЛЕРЫ И ДЕЙСТВИЯ (CONTROLLERS AND ACTIONS)
    К этому моменту система маршрутизации выбрала маршрут из коллекции RouteTable.Routes и 
проанализировала параметры URL адреса. Вся эта информация помещена в контекст запроса. 

    Для приложений ASP.NET MVC большинство маршрутов из RouteTable.Routes соответствуют одному обработчику MvcRouteHandler, 
Это стандартный обработчик, встроенный в ASP.NET MVC. MvcRouteHandler с помощью контекста запроса вызвает соответствующий контроллер.
По умолчанию он использует фабрику контроллеров DefaultControllerFactory реализует интерфейс IControllerFactory, 
который использует определенное соглашение именования контроллеров для того, чтобы выбрать правильный контроллер для входящего запроса.

    Констроллер предсавляет класс, который должен реализовывать интерфейс IController и реализовывать метод Execute().
Параметр requestContext метода Execute хранит полную информацию о контексте запроса, сформированном системой маршрутизации, 
включая параметры URL адреса, и, кроме того, обеспечивает доступ к объектам Request и Response.

    На практике необходимости реализовывать IController напрямую – можно наследовать контроллеры от класса Controller. 
Это стандартный базовый контроллер ASP.NET MVC, который добавляет необходимую инфраструктуру для обработки запросов. 
Что наиболее важно, он вводит в систему методы действий (action methods). 
Это значит, что все public методы контроллера достижимы через URL (такие методы и называются «методы действий»). 
Методы действия возвращают результат действий (action result) объекты, наследуемые от ActionResult, он описывает 
результат выполнения действия. 
    Например, если вы хотите отрендерить представление, следует вернуть ViewResult. Или для перенаправления HTTP 
запроса к другому методу действия следует вернуть RedirectToRouteResult. 
    Кроме того, существует очень гибка система фильтров (filters). 
Это атрибуты .NET (например, [Authorize]), которыми вы можете помечать классы контролеров или методы действий, 
встраивая какую-либо логику до или после выполнения методов действий, или до или после запуска результатов действий. 
Существуют несколько встроенных фильтров, например фильтры исключений и фильтры авторизации. 
Фильтры могут применяться в стольких различных местах, что им не нашлось места на схеме!

## РЕЗУЛЬТАТЫ ДЕЙСТВИЙ И ПРЕДСТАВЛЕНИЯ (ACTION RESULTS AND VIEWS)
    • Система маршрутизации сопоставила входящий URL с конкретным маршрутом и подготовила объект, содержащий контекст запроса. 
Выбранный из RouteTable.Routes маршрут обозначил обработчик MvcRouteHandler для обработки запроса.
    • MvcRouteHandler использовал контекст запроса и фабрику контроллеров для того, 
чтобы выбрать и вызвать соответствующий контроллер.
    • Контроллер вызвал один из своих методов действий.
    • Метод действия вернул объект ActionResult.

В этот момент, ASP.NET MVC выполняет запуск результата ActionResult.

## ВИЗУАЛИЗАЦИЯ ПРЕДСТАВЛЕНИЯ
    Уделим особое внимание одному особенному классу, наследованному от ActionResult – ViewResult.
Этот класс способен найти и визуализировать соответствующий шаблон представления, передав ему структуру данных ViewData, 
сформированном в методе действия. 
Это и есть то, что называется «движок отображения» («view engine») (класс .NET, реализующий интерфейс IViewEngine).

    WebFormViewEngine - механизм представвленя по умолчанию. 
Его шаблоны представления являются страницами ASPX WebForms (.aspx) 
 - это серверные страницы, используюшиеся в традиционной технологии ASP.NET WebForms. 
Страницы WebForms имеют свой собственный конвейер обработки, начинающийся с компиляции ASPX/ASCX «на лету» и 
проходящий через серию событий, называющийся жизненным циклом страницы. 
    В отличие от традиционного ASP.NET, в ASP.NET MVC эти страницы должны быть максимально простыми, 
поскольку, согласно принципам MVC, представления могут отвечать только за генерацию HTML кода. 
Это значит что, вам не требуется детально понимать жизненный цикл страниц WebForms. 
С соблюдением принципов разделения ролей приходят простота и удобство сопровождения кода.