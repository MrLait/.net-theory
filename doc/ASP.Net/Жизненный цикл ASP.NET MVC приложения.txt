# IIS и HTTP.SYS
    Когда от пользоввателя приходит запрос
    В первую очередь начинает работу веб-сервер IIS Internet Information Services от компании Microsoft, который
перехватывает запросы при помощи драйвера HTTP.SYS в режиме ядра Kernel, прослушивая HTTP и HTTPS входящие запросы, кэширует, 
анализирует и перенаправляет их зарегистрированному приложению в нужный пул приложений, который может быть как веб-сайтом, 
так и виртуальным каталогом внутри веб-сайта IIS. 
    IIS определяет число запросов, которые могут одновременно обрабатываться на одном ядре процессора. 
Если количество входящих запросов превышает это число, то все дополнительные запросы помещаются в очередь ожидания. 
Таким образом, запросы пользователей никуда не пропадают, и они вообще не замечают каких-то перебоев в работе сайтов. 
Если же очередь заполнена, то входящий запрос отвергается, а браузеру в ответ посылается статусный код ошибки 503.

# Процесс Svchost.exe
    Далее драйвер HTTP.SYS обращается к три даби сервису.
## World Wide Web Publishing Service (W3SVC)
   World Wide Web Publishing Service - это адаптер для HTTP.SYS, работающий в контексте процесса Svchost.exe 
и начиная с версии IIS 7.0+ он выполняет функции:
    Настройки драйвера HTTP.sys;
    Мониторинг показателей производительности веб-сайтов.  

    После обращения драйвера к WWW service. Aдаптер WWW service обращаеся к службе WAS.
## Windows Process Activation Service (WAS)
    Windows Process Activation Service (WAS) - это служба запускается системой в единственном экземпляре и управляет: 
    Рабочими процессами; 
    Временем жизни рабочих процессов;
    Считывает конфигурационную информацию о веб-приложениях и пулах приложений из файла ApplicationHost.config;
    Выполняет сопоставление между пулами приложений и рабочими процессами. Если соответствующий пулу приложения рабочий процесс 
еще не запущен, то посредством менеджера приложения его запускает.

    И так - служюа WAS считывает из файла ApplicationHost.config конфигурационную информацию о веб-приложениях 
и пулах приложений, которую передает WWW service, а та уже, в свою очередь, настраивает HTTP.sys на 
прослушку конкретных портов, разбор IP и заголовка запрашиваемого сайта и других параметров драйвера. (bindings)
Эти параметры должны быть уникальными среди работающих приложений для однозначной идентификации целевого приложения. 
Сам запрос попадает в очередь порта завершения ввода-вывода (I/O completion port), и так же создается кэширование запросов.
    
# Application Pool
    Пока конфигурировался HTTP.SYS cлужба WAS запускает рабочий процесс W3WP.exe для пула приложений, если он ещё не был запущен.
    Посредством менеджера приложений ApplicationManager создаёт внутри рабочего процесса домен приложения, в котором 
будет хоститься приложение. ApplicationManager управляет созданием и удалений доменов приложений

    Пул приложений появился в IIS 6, что обеспечить изоляцию веб-приложений друг от друга, повысив стабильность работы веб-сервера. 
Т.к. приложения выполняется внутри процесса Windows – w3wp.exe исключение внутри веб-приложения приведёт к краху только этого процесса 
и никак не повлияет на доступность веб-приложений в других пулах и работу служб IIS. Более того, служба WAS попытается заново запустить 
упавший сайт, и внешние клиенты могут даже не заметить проблем в работе сервера.

# ASP.NET
    После создания ApplicationManager-ом домена приложения, конфигурируется объект класса HostingEnvironment, который предоставляет 
доступ к информации о приложении, в частности, имя и каталог приложения.
    После создания домена приложения также создаются и инициализируются такие объекты, как 
    HttpContext содержит объекты:
        HttpRequest - содержит информацию о текущем запросе, включая файлы cookie и информацию о браузере;
        HttpResponse - cодержит ответ, отправляемый клиенту, который включает в себя все обработанные выходные данные и файлы cookie.
    
    Для обработки HttpContext, создается объект HttpAplication. Если в приложении определен файл Global.asax, который наследуется 
от класса HttpApplication, то ASP.NET в качестве приложения создает его экземпляр.
    
    Если придет одновременно несколкьо запросов, то будет созданно нескоько HttpContext и HttpAplication, каждый запрос
будет обробатываться в отдельном потоке, а для повышения производительностьи запросы могут использовать уже созданный HttpAplication.
    
    Запрос начинает обрабатываться в конвейере класса HttpApplication, где он перехватывается системой маршрутизации.
# МАРШРУТИЗАЦИЯ (CORE ROUTING)
    Начальной точкой всей системы маршрутизации является module UrlRoutingModule. Модуль HTTP – это класс, реализующий интерфейс IHttpModule.
Этот модуль зарегестрирован по умолчанию во всех приложениях ASP.NET MVC. Так же весь набор маршрутов определяется в классе RouteConfig.cs. 
А сама регистрация маршрутов происходит в методе Application_Start класса MvcApplication, в котором есть статический метод RegisterRoutes
класса RouteConfig и принимающий параметр (RouteTable.Routes). 
Для каждого приложения имеется только одина статическая коллекция маршрутов RouteTable.
            
    Задача системы маршрутизации состоит в том, чтобы:
        Распознать и проанализировать входящий URL; 
        Заполнить контекст запроса.
    
    Система маршрутизации проверяет, соответствует ли входящий URL какому-то файлу на диске, таких как .gif, .jpeg. или WebForms (.aspx).
Если да, то маршрутизация завершается и IIS продолжает обработку запроса. Но, если входящий URL не соответствует файлу на диске, а например,
контроллеру MVC, то система маршрутизации исследует текущую конфигурацию для того, чтобы определить как обработать входящий URL.
    Для этого в системе маршрутизации есть Таблица маршрутизации, которая хранится в статичной коллекции RouteTable, где каждая запись 
в коллекции представляет собой шаблон допустимых URL адресов и указывает на обработчик маршрута route handler – объект, 
реализующий интерфейс IRouteHandler, который принимает и обрабатывает запрос. 
    Для поиска соответствия HTTP запроса конкретному маршруту из RouteTable.Routes, система маршрутизации начинает её сканировать сверху 
вниз и выбирает первый подходящий маршрут, соответствующий входящему запросу. Найдя его, система маршрутизации передает управление 
обработчику маршрута, обеспечивая его контекстом запроса, описывающим выбранный маршрут и все параметры URL адреса.

# КОНТРОЛЛЕРЫ И ДЕЙСТВИЯ (CONTROLLERS AND ACTIONS)
    К этому моменту система маршрутизации выбрала маршрут из коллекции RouteTable.Routes и проанализировала параметры URL адреса. 
Вся эта информация помещена в контекст запроса. 
    Для приложений ASP.NET MVC большинство маршрутов из RouteTable.Routes соответствуют одному обработчику MvcRouteHandler - это 
стандартный обработчик, встроенный в ASP.NET MVC. MvcRouteHandler с помощью контекста запроса использует определенное соглашение 
именований контроллеров для того, чтобы вызвать правильный контроллер для входящего запроса. По умолчанию он использует 
фабрику контроллеров DefaultControllerFactory, который реализует интерфейс IControllerFactory.

    Констроллер предсавляет класс, который должен реализовывать метод Execute() интерфейса IController. Параметр requestContext 
метода Execute хранит полную информацию о контексте запроса, которая сформированна системой маршрутизации и обеспечивает доступ к 
объектам Request и Response.
    На практике необходимости реализовывать IController напрямую нет – можно наследовать контроллеры от класса Controller. 
Это стандартный базовый контроллер ASP.NET MVC, который добавляет необходимую инфраструктуру для обработки запросов, включая 
методы действий (action methods) - это публичне методы контроллера, которые достижимы через URL. Методы действия возвращают 
результат действий - это объекты, наследуемые от ActionResult, они описывают результат выполнения действия. 
    Например, если вы хотите отрендерить представление, следует вернуть ViewResult. Или для перенаправления HTTP запроса 
к другому методу действия следует вернуть RedirectToRouteResult. 
    Кроме того, существует система фильтров (filters). Это атрибуты .NET (например, [Authorize]), которыми вы можете помечать 
классы контролеров или методы действий, встраивая какую-либо логику до или после выполнения action methods или запуска ViewResult. 
Существуют несколько встроенных фильтров, например фильтры исключений и фильтры авторизации. 

## РЕЗУЛЬТАТЫ ДЕЙСТВИЙ И ПРЕДСТАВЛЕНИЯ (ACTION RESULTS AND VIEWS)
    • Система маршрутизации сопоставила входящий URL с конкретным маршрутом и подготовила контекст запроса. 
Выбрала маршрут из RouteTable.Routes, который соответствует обработчику запрсов MvcRouteHandler.
    • MvcRouteHandler использовал контекст запроса и фабрику контроллеров для того, чтобы выбрать и вызвать соответствующий контроллер.
    • Контроллер вызвал один из своих методов действий.
    • Метод действия вернул объект ActionResult.
В этот момент, ASP.NET MVC выполняет запуск результата ActionResult.

## ВИЗУАЛИЗАЦИЯ ПРЕДСТАВЛЕНИЯ
    Для того чтобы визуализировать представление существует класс, наследованный от ActionResult – ViewResult.
Этот класс способен найти и визуализировать соответствующий шаблон представления, передав ему структуру данных ViewData, сформированном 
в методе действия. Результат рендера записывается в ответ на запрос

________________________________________________________________________________________
Удалено из ApplicationPool 
Загружает в него согласно конфигурации приложения требуемые обработчики протоколов процессов (process protocol handler PPH); 
ApplicationManager загружает код приложения в домен приложения и требуемые обработчики протоколов уровня приложения (AppDomain protocol handlers ADPH) для обработки сообщений по соответствующим сетевым протоколам.
Обработчики протоколов – компоненты внутри рабочего процесса, ответственные за обмен данными между адаптером и рабочим процессом.     

И так в результате прихода запроса с расширением, например, .aspx; .ashx; .mvc. будет перехвачено ISAPI - aspnet_isapi.dll, который обращает к процессу ASP.NET.

Удалено из Маршрутизация
    В IIS 6 модуль UrlRoutingModule регистрируется в файле web.config.          

Удалено из ВИЗУАЛИЗАЦИЯ ПРЕДСТАВЛЕНИЯ
    Это и есть то, что называется «движок отображения» («view engine») (класс .NET, реализующий интерфейс IViewEngine).
    WebFormViewEngine - механизм представвленя по умолчанию. Его шаблоны представления являются страницами ASPX WebForms (.aspx)  - это серверные страницы, используюшиеся в традиционной технологии ASP.NET WebForms. 
Страницы WebForms имеют свой собственный конвейер обработки, начинающийся с компиляции ASPX/ASCX «на лету» и проходящий через серию событий, называющийся жизненным циклом страницы. 
    В отличие от традиционного ASP.NET, в ASP.NET MVC эти страницы должны быть максимально простыми, поскольку, согласно принципам MVC, представления могут отвечать только за генерацию HTML кода. 
Это значит что, вам не требуется детально понимать жизненный цикл страниц WebForms. С соблюдением принципов разделения ролей приходят простота и удобство сопровождения кода.