#Основы архитектуры IIS-конвейера обработки запроса
##HTTP.SYS
    На транспортном уровне IIS использует прослушивателей протоколов (protocol listeners), 
которые располагаются поверх стека TCP/IP. 
    Наиболее интересный нам такой компонент – это системный драйвер HTTP.sys, 
который встроен в ядро ОС и работает с протоколами HTTP и HTTPS, регистрирующийся самостоятельно на 
прослушку всех портов, на которые будут приходить запросы к сайтам в IIS.
    Встроенный в ядро HTTP.sys стал нововведением в IIS 6, заместив собой Windows Socket API – 
компонент перехвата HTTP- и HTTPS-запросов на пользовательском уровне в IIS более ранних версий. 
    Драйвер принимает все входящие запросы и перенаправляет их в нужный пул приложений. 
Если рабочий процесс, в котором хостится требуемый пул, остановлен (сбой, таймаут простоя, 
смена конфигурации и т.п.) или ещё запускается, то HTTP.sys сохраняет входящие запросы в специально 
отведённой для каждого пула очереди. Таким образом, запросы пользователей никуда не пропадают, 
и они вообще не замечают каких-то перебоев в работе сайтов под управлением IIS.
    Ещё HTTP.sys умеет кешировать ответы, поэтому некоторые запросы обрабатываются без передачи 
на уровень приложения, а также проводит первичный разбор URI запроса и его валидацию 
в соответствии с RFC 2396 и журналирование запросов/ответов.
    Расположение %SystemRoot%\system32\drivers\http.sys.

##World Wide Web Publishing Service (W3SVC) - Svchost
    Данная служба сокращённо WWW service была представлена в IIS 6 в качестве отдельного компонента 
для работы с протоколами HTTP/HTTPS и управления рабочими процессами приложений и 
выполняла следующие функции:
    Администрирование драйвера HTTP.sys;
    Управление рабочими процессами;(В IIS 7 вынесена в WAS)
    Мониторинг показателей производительности веб-сайтов.
Эта служба функционирует в Windows Server 2003 в контексте процесса Svchost.exe 
    настройки можно посмотреть в реестре HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W3Svc 
в отличие от всех остальных служб IIS, которые исполняются в контексте процесса Inetinfo.exe, 
и реализована в Iisw3adm.dll.

    В IIS 7.x функция управления процессами была вынесена в отдельную службу – WAS в целях 
универсализации архитектуры. Теперь WWW-служба стала по своей сути одним из адаптеров, 
специализируясь на протоколах HTTP/HTTPS – работа поверх драйвера HTTP.sys. 
Однако WWW-служба остаётся краеугольным компонентом IIS, поэтому её настройка отличается от настройки 
адаптеров к другим протоколам; она функционирует в том же рабочем процессе, что и WAS, 
и реализована в той же самой библиотеке.

    Раз уж зашла речь об адаптерах к прослушивателям протоколов (protocol listener adpater), 
то давайте чуть задержимся и посмотрим, какие они бывают. 
В принципе IIS 7.x можно настроить для обработки запросов по любым протоколам помимо типовых HTTP и FTP,
например, POP3, SMTP, Gopher. Вы даже вольны придумать свой протокол для своей веб- или WCF-службы 
и реализовать для него все нужные компоненты, если не жалко своего времени. 
Скорее всего, адаптеры и прослушиватели для наиболее распространённых протоколов доступны для 
свободного и коммерческого скачивания – этого я не проверял. 
Но прежде всего стоить обратить внимание на стандартные службы, поставляемые с .NET Framework и 
интегрированные с IIS:
    NetTcpActivator для протокола TCP;
    NetPipeActivator для Named Pipes;
    NetMsmqActivator для Message Queuing (ака MSMQ).

    Но всё-таки наиболее важным для нас адаптером является именно WWW-служба, 
т.ч. остановимся чуть подробнее на двух оставшихся от IIS 6 функциях:
    
    Администрирование и конфигурирование HTTP(S). 
    В момент обновления конфигурации веб-сайтов, служба WAS передаёт эту информацию WWW-службе, 
а та уже, в свою очередь, настраивает HTTP.sys на прослушку конкретных портов, разбор IP и заголовка 
запрашиваемого сайта и, возможно, других параметров драйвера. 
    В обратную сторону W3SVC обращается к WAS, когда в очередь запросов в HTTP.sys поступает новый, 
    – для получения рабочего процесса-обработчика данного запроса.

    Отслеживание показателей производительности. 
    WWW-служба ведёт счётчики производительности, используя для этого драйвер HTTP.sys, 
и предоставляет их показатели веб-сайтами и кэшу IIS. 

##Windows Process Activation Service (WAS)
    Итак, WWW-служба в IIS 7.x, как и в IIS 6, продолжает выполнять задачи по администрированию HTTP.sys 
и управлению показателями производительности веб-сайтов. А вот задача управления рабочими процессами 
вынесена в отдельную службу – WAS. Она запускается системой в единственном экземпляре, 
считывает конфигурацию из файла 
    %SystemRoot%\System32\inetsrv\Config\ApplicationHost.config 
и настраивает через соответствующие адаптеры прослушивателей протоколов в соответствии с указанной 
в нём информации. Напомним, что для протоколов HTTP/HTTPS адаптером является служба W3SVC, 
а прослушивателем – драйвер HTTP.sys. При перехвате прослушивателем запроса он через свой адаптер 
обращается к службе WAS для получения рабочего процесса приложения, которому будет передан запрос 
для обработки и формирования ответа клиенту.

    При активации нужного для обработки пользовательского запроса приложения задействуются следующие компоненты:
    Адаптеры прослушивателей (Listener adapters) – специальные службы Windows, 
работающие с конкретным протоколом и взаимодействующие с WAS для направления запросов к правильному 
рабочему процессу.
    Собственно WAS. Она ответственна за создание рабочих процессов и управление их временем жизни.
    Исполняемый файл w3wp.exe – шаблон рабочего процесса.
    Менеджер приложений управляет созданием и утилизацией доменов приложений (application domains), 
которые хостятся внутри рабочего процесса.
    Обработчики протоколов – протоколозависимые компоненты внутри рабочего процесса, 
ответственные за обмен данными между конкретным адаптером и рабочим процессом. 
Есть 2 типа обработчиков протоколов: 
    у процесса (process protocol handler — PPH) 
    и у домена приложения (AppDomain protocol handlers — ADPH).

    Ниже на рисунке представлен пример схемы компонентов внутри некоего экземпляра рабочего процесса 
приложения. 
    Когда служба WAS запускает рабочий процесс, она загружает в него согласно конфигурации 
приложения требуемые обработчики протоколов процессов (PPH) и посредством менеджера приложений ApplicationManager 
создаёт внутри рабочего процесса домен приложения, в котором будет хоститься приложение. 
Менеджер приложений загружает код приложения в домен приложения и требуемые обработчики 
протоколов уровня приложения (ADPH) для обработки сообщений по соответствующим сетевым протоколам.

    Как отмечалось выше, .NET Framework несёт в себе реализацию компонент для протоколов HTTP/HTTPS 
(наш любимый ASP.NET), net.tcp, net.pipe и MSMQ. Стеки протоколов HTTP/HTTPS и FTP всё-таки более 
тесно интегрированы в IIS и ОС, поэтому настройку для нового протокола лучше продемонстрировать 
на примере менее популярных дотнетовских протоколов. 
    Итак, после установки фреймворка в файле конфигурации IIS ApplicationHost.config появляется записи:
<system.applicationHost>
    <listenerAdapters>
        <add name="http" />
        <add name="net.tcp" 
          identity="S-1-5-80-3579033775-2824656752-1522793541-1960352512-462907086" />
         <add name="net.pipe" 
           identity="S-1-5-80-2943419899-937267781-4189664001-1229628381-3982115073" />
          <add name="net.msmq" 
            identity="S-1-5-80-89244771-1762554971-1007993102-348796144-2203111529" />
           <add name="msmq.formatname" 
             identity="S-1-5-80-89244771-1762554971-1007993102-348796144-2203111529" />
    </listenerAdapters>
</system.applicationHost>

А соответствующие компоненты PPH и ADPH настраиваются в дотнетовском machine.config:
<system.web>
   <protocols>
      <add name="net.tcp" 
        processHandlerType="System.ServiceModel.WasHosting.TcpProcessProtocolHandler"
        appDomainHandlerType="System.ServiceModel.WasHosting.TcpAppDomainProtocolHandler"
        validate="false" />
      <add name="net.pipe" 
        processHandlerType="System.ServiceModel.WasHosting.NamedPipeProcessProtocolHandler"
          appDomainHandlerType="System.ServiceModel.WasHosting.NamedPipeAppDomainProtocolHandler”/>
      <add name="net.msmq"
        processHandlerType="System.ServiceModel.WasHosting.MsmqProcessProtocolHandler"
        appDomainHandlerType="System.ServiceModel.WasHosting.MsmqAppDomainProtocolHandler"
        validate="false" />
   </protocols>
</system.web>

В конфигурационном файле веб-сервера ApplicationHost.config вместе с настройками приложений хранятся 
связки (bindings), определяющие параметры входящих запросов, которые будут направляться данному 
приложению. 
Такими параметрами являются название сетевого протокола, IP-адрес сервера, доменное имя и порт сайта. 
Эти параметры должны быть уникальными среди работающих приложений для однозначной идентификации 
целевого приложения. Служба WAS отслеживает это ограничение и не даст вам запустить сайт, 
у которого это условие не соблюдено, либо предложит остановить сайт с такой же связкой.
    <bindings>
        <binding protocol="http" bindingInformation="109.120.157.xxx:80:dddddd.info" />
        <binding protocol="http" bindingInformation="109.120.157.xxx:80:www.ddddd.info" />
    </bindings>

    Обратите внимание, что в стандартном режиме эксплуатации IIS служба WAS, служба-адаптер для каждого 
прослушивателя протокола (в т.ч. W3SVC) и сами драйверы/прослушиватели каждого из протоколов 
(в т.ч. HTTP.sys) запущены в ОС в единственном экземпляре. Но отдельные запросы могут направляться 
разным приложениям в разных рабочих процессах. С другой стороны, отдельно взятому приложению могут 
направляться запросы по разным протоколам через соответствующие адаптеры. 
Видимо, для корректной реализации такого поведения и была придумана архитектурная связка 
драйвер протокола – адаптер драйвера протокола – служба активации 
(своеобразный регулировщик, точнее — маршрутизатор) – рабочий процесс.

##Пул приложений (w3wp.exe)
    При конфигурации веб-приложения помимо привязок (binding) к параметрам запросов и прочих настроек 
указывается принадлежность к пулу приложений. Пул приложений стал нововведением в IIS 6 и был призван 
обеспечить изоляцию веб-приложений друг от друго и тем самым повысить стабильность работы веб-сервера 
в целом. Суть заключается в том, что код приложения выполняется внутри специального процесса Windows – 
w3wp.exe. Поэтому исключение внутри веб-приложения приведёт к краху только этого процесса и никак не 
повлияет на доступность веб-приложений в других пулах и работу служб IIS. 
Более того, служба WAS попытается заново запустить упавший сайт, и внешние клиенты могут даже не 
заметить проблем в работе сервера.

    Для управления некоторыми параметрами отдельно взятого рабочего процесса w3wp.exe в IIS 
используется пул приложений. Наиболее часто используемыми из них являются учётная запись, 
под которой будет запущен процесс, ограничения для очереди запросов, различные таймеры и счетчики 
для автоматического перезапуска процесса, архитектура x86/x64 (в IIS 7.x) и некоторые другие. 
Т.о. можно говорить о тождественности процесса w3wp.exe и пула приложений.

    Ключевым нововведением в концепции пулов приложений в IIS 7.x стал новый параметр – 
модель управления контейнером, который может принимать 2 значения: 
классическая (Classic mode) и встраиваемая модель (Integrated mode).
    Чтобы объяснить разницу между этими режимами работы, потребуется знакомство с понятием «модуль» 
(Module) в IIS 6/7.x и событийной моделью обработки запросов в связке IIS + ASP.NET. 
Тема эта достойна отдельной статьи, но меня на неё уже, увы, не хватит, судя по всему. 
Здесь же представлю вашему вниманию лишь общие, ключевые моменты.

    Итак, IIS при обработке запроса пропускает его внутри рабочего процесса через последовательность 
модулей. Например фильтрация, перенаправление, кэширование, аутентификация, авторизация. 
Каждый такой модуль ассоциируется с определённым событием, а их последовательность составляют 
событийную модель обработки запросов. Модули делятся на нативные (Native) и управляемые (Managed). 
Нативные модули поставляются вместе с IIS, а управляемые – в составе .NET Framework (ASP.NET). 
В общем-то, вы можете управлять ими в определённой степени на уровне конфигурации веб-приложения, 
но взаимодействовать из кода своего ASP.NET-сайта вы можете только с управляемыми модулями.

    Классическая модель управления контейнером обеспечивает обратную совместимость с режимом изоляции 
рабочих процессов в IIS 6 – запросы к ASP.NET-сайту сначала проходят через нативные модули, 
а затем передаются в Aspnet_isapi.dll для обработки модулями в управляемой среде. 
Такое разделение между IIS и ASP.NET приводит к дублированию некоторых функций, 
например, аутентификации и авторизации. И вы не имеете возможности управлять программно поведением 
нативных модулей 
(пример хоть и не самый животрепещущий, но всё же – раздел «Убираем заголовок Server» в этой статье).
    Встраиваемая модель предполагает более тесное взаимодействие между IIS и ASP.NET. 
Запрос в такой архитектуре обработки пропускается через установленную последовательность событий, 
в каждом из которых запрос пропускается через нативный и управляемые модули. 
В таком режиме модели обработки запросов IIS и ASP.NET объединены в единую модель, 
что позволяет избежать дублирования функций и получить больший контроль над обработкой запроса.

    На практике самое важное, что необходимо учитывать при разработке и развёртывании веб-приложений, 
– это частичная несовместимость этих двух режимов. Т.е. при переводе сайта 
(точнее пула приложений, в котором работает сайт) из классической модели во встраиваемую 
практически всегда потребуется корректировка кода (хоть, возможно, и не значительная), 
а также тщательное тестирование.

##Домен приложения, приложение
    Непосредственными контейнерами веб-приложения являются приложение и домен приложения 
(Application Domain, AppDomain). 
Зачастую эти два понятия отождествляются, но всё-таки это немного разные вещи. 
Приложение – это понятие IIS, а домен приложения – из ASP.NET. 
Причём в общем случае в приложении может быть несколько доменов. 
Приложением вы можете управлять из консоли IIS, а доменом приложения – в основном программно. 
Так, например, перезапускается приложение из консоли. А когда мы пересохраняем web.config, 
то перезагружается именно домен приложения, не трогая IIS-приложение.

    Более важным с практической точки зрения является то, что приложение/домен приложения 
является sandbox-ом для кода вашего ASP.NET-сайта не с такой надёжной изоляцией, как в случае с пулом. 
Приведу один из моих любимых вопросов, которые я задавал соискателям на собеседованиях. 
Пусть имеются веб-сайт-1 и веб-сайт-2, а также некая библиотека MyLib.dll, 
в которой определён класс MyClass1 со статическим полем Field1. Итак, оба сайта работают 
под управлением одного пула приложений и используют одну и ту же библиотеку MyLib.dll. 
Веб-сайт-1 записывает в MyClass1.Field1 = 16. 
Вопрос: увидит ли веб-сайт-2 сделанные изменения? Напрашивается ответ «Нет». 
Но почему? Потому что, для IIS-приложений выделяются непересекающиеся адресные пространства, 
даже если они работают внутри единого рабочего процесса, поэтому в память веб-приложений загружаются 
свои копии сборок (прошу не придираться к возможным неточностям в терминах работы с памятью 
в .NET Framework).

    Ещё один важный момент, который хотелось бы здесь отметить. 
По умолчанию каждый отдельный рабочий процесс может использовать все имеющиеся на сервере 
процессоры/ядра, а пул приложений работает на одном рабочем процессе и, следовательно, 
веб-приложение работает внутри одного IIS-приложения. 
Тем не менее, вы можете настроить web garden, увеличив кол-во рабочих процессов на пул и, 
следовательно, число IIS-приложений на одно веб-приложение. Вы без труда сможете найти на просторах 
интернета информацию о web garden, поэтому опускаю здесь подробности. Е
динственное, хотелось бы предупредить, что данное средство не является инструментом увеличения 
производительности, т.к. по умолчанию и так используются все вычислительные мощности сервера. 
Наоборот, на синхронизацию работы 2+ рабочих процессов уходил «лишнее» время CPU. 
Делается это в основном для увеличения доступности веб-приложения. 
Нельзя здесь также не упомянуть о веб-ферме (web farm), как о простейшем средстве балансировки 
нагрузки в IIS – об этом тоже достаточно статей в Сети. Это другой пример распределённого 
веб-приложения. Впрочем, с тем же nginx встроенная балансировка нагрузки в IIS конкуренции не 
выдерживает, и в реальных высоконагрузочных системах вам придётся изобретать свой велосипед или 
задействовать продукты сторонних производителей.