#Что происходит с HTTP-запросом от момента его поступления на 80-й порт и до передачи управления странице
##IIS
    В первую очередь начинает работу веб-сервер IIS(Internet Information Services) от Microsoft. 
При поступлении HTTP запроса драйвер HTTP.SYS ядра Windows анализирует комбинацию URL/port number/IP address, 
сопоставляет их и перенаправляет зарегистрированному приложению, которое может быть как 
веб-сайтом IIS, так и виртуальным каталогом внутри веб-сайта IIS.
    Приложения ASP.NET MVC основаны на ASP.NET, необходимо включить ASP.NET в одном из в двух управляемых конвейерных режимах (managed pipeline modes):
    С помощью расширения ISAPI (aspnet_isapi.dll), ассоциированного с определенными расширениями файлов из URL адреса,
например, .aspx; .ashx; .mvc. Или без ассоциации с определенным расширением и тогда aspnet_isapi.dll будет обрабатывать 
все запросы, несмотря на расширение файлов.
    В интегрированном режиме, который поддерживается IIS 7+ .NET является естестввенной частью конвейера обработки запросов, 
поэтому не нужно использовать расширение ISAPI, ассоциированное с расширениями файлов. 
Именно это делает легким использование маршрутизации с чистыми URL адресами без расширений имен файлов.

    В общем как только система ASP.NET принимает входящий запрос, она оповещает все 
зарегистрированные модули HTTP о том, что пришел новый запрос. 
Модуль HTTP – это класс .NET, реализующий интерфейс IHttpModule.
    Начальной точкой всей системы маршрутизации core routing system является UrlRoutingModule.
Этот модуль зарегестрирован по умолчанию во всех приложениях ASP.NET MVC. В IIS 6 модуль UrlRoutingModule регистрируется в файле web.config.

##МАРШРУТИЗАЦИЯ (CORE ROUTING)
    Когда UrlRoutingModule вступает в обработку запроса, он запускает систему маршрутизации System.Web.Routing. 
Задача маршрутизации состоит в том, чтобы распознать и проанализировать входящий URL и заполнить контекст запроса (request context), 
который могут использовать последующие компоненты, например, ASP.NET MVC использует его для передачи управления 
соответствующему контроллеру MVC и заполнения параметров методов действий.
    Система маршрутизации в первую очередь проверяет, соответствует ли входящий URL какому-то файлу на диске. 
Если да, то маршрутизация завершается и IIS продолжает обработку запроса. 
Для статичных файлов, таких как .gif, .jpeg, .png, .css или .js 
это значит, что IIS будет обрабатывать их стандартным способом, т.к. они существуют на диске.
Подобно этому, традиционные страницы ASP.NET WebForms (.aspx) будут обработаны обычным способом.
    Однако, если входящий URL не соответствует файлу на диске, например, запросы к контроллерам MVC, 
которые являются классами .NET, а не файлами, тогда система маршрутизации исследует 
текущую конфигурацию для того, чтобы определить как обработать входящий URL.

    В системе маршрутизации есть Таблица маршрутизации, которая хранится в статичной коллекции RouteTable. 
Каждая запись в коллекции представляет собой шаблон для допустимых URL адресов. 
В шаблон могут опционально входить необязательные заполнители, например, /blog/{year}/{entry}) и ограничения (constraints), 
которые ограничивают диапазон допустимых значений для каждого из параметров. 
Каждая запись указывает на обработчик маршрута (route handler) – объект, реализующий интерфейс IRouteHandler, который принимает и обрабатывает запрос. 
Для того, чтобы заполнить коллекцию RouteTable.Routes, нужно добавить соответствующий код в метод RegisterRoutes() файла Global.asax.cs.
    Для поиска соответствия запроса HTTP конкретному маршруту из RouteTable.Routes, 
система маршрутизации начинает сканировать коллекцию RouteTable.Routes сверху вниз и выбирает первый найденный маршрут, 
соответствующий входящему запросу. Найдя его, система маршрутизации передает управление обработчику маршрута, 
обеспечивая его контекстом запроса, описывающим выбранный маршрут и все параметры URL адреса.

##КОНТРОЛЛЕРЫ И ДЕЙСТВИЯ (CONTROLLERS AND ACTIONS)
    К этому моменту система маршрутизации выбрала маршрут из коллекции RouteTable.Routes и 
проанализировала параметры URL адреса. Вся эта информация помещена в контекст запроса. 
Итак, в каком месте на сцену вступают контроллеры и действия?

    Для приложений ASP.NET MVC большинство маршрутов из RouteTable.Routes соответствуют одному обработчику MvcRouteHandler, 
Это стандартный обработчик, встроенный в ASP.NET MVC. MvcRouteHandler знает, как с помощью контекста запроса вызвать соответствующий контроллер.
    Он делает это, используя фабрику контроллеров (controller factory). 
По умолчанию он использует фабрика DefaultControllerFactory, которая использует определенное соглашение именования контроллеров для того, 
чтобы выбрать правильный контроллер для входящего запроса.
    Однако, если вы заменяете встроенную фабрику DefaultControllerFactory какой-либо другой реализацией интерфейса 
IControllerFactory или наследником класса DefaultControllerFactory, тогда вы должны изменить эту логику.

##ЧТО ДОЛЖНЫ ДЕЛАТЬ КОНТРОЛЛЕРЫ
    Минимальное требование к классу контроллера состоит в том, что он должен реализовывать интерфейс IController:
        public interface IController
        {
            void Execute(RequestContext requestContext);
        }
    Это очень простой интерфейс! Он специфицирует то, что контроллер должен реализовать метод Execute(). 
Заметьте, что параметр requestContext хранит полную информацию о контексте запроса, сформированном системой маршрутизации, 
включая параметры URL адреса, и, кроме того, обеспечивает доступ к объектам Request и Response.

##ЧТО КОНТРОЛЛЕРЫ ДЕЛАЮТ ОБЫЧНО
    Чаще всего нет необходимости реализовывать IController напрямую – можно наследовать контроллеры от класса System.Web.Mvc.Controller. 
Это стандартный базовый контроллер ASP.NET MVC, который добавляет необходимую инфраструктуру для обработки запросов. 
Что наиболее важно, он вводит в систему методы действий (action methods). 
Это значит, что все public методы контроллера достижимы через URL (такие методы и называются «методы действий») 
и, кроме того, это значит, что не нужно самостоятельно реализовывать метод Execute().
    Хотя методы действий могут выводить результат прямо в HTTP response, так не рекомендуется делать. 
По причинам удобства тестирования и повторного использования кода в методах действий лучше возвращать результат действий (action result) 
(объект, наследованный от ActionResult), который описывает результат выполнения действия. 
Например, если вы хотите отрендерить представление, следует вернуть ViewResult. 
Или для перенаправления HTTP запроса к другому методу действия следует вернуть RedirectToRouteResult. 
ASP.NET MVC позаботится о выполнении результата в нужный момент конвейера обработки запросов.
    Кроме того, существует очень гибка система фильтров (filters). 
Это атрибуты .NET (например, [Authorize]), которыми вы можете помечать классы контролеров или методы действий, 
встраивая какую-либо логику до или после выполнения методов действий, или до или после запуска результатов действий. 
Существуют несколько встроенных фильтров, например фильтры исключений и фильтры авторизации. 
Фильтры могут применяться в стольких различных местах, что им не нашлось места на схеме!

##РЕЗУЛЬТАТЫ ДЕЙСТВИЙ И ПРЕДСТАВЛЕНИЯ (ACTION RESULTS AND VIEWS)
    • Система маршрутизации сопоставила входящий URL с конкретным маршрутом и подготовила объект, содержащий контекст запроса. 
Выбранный из RouteTable.Routes маршрут обозначил обработчик MvcRouteHandler для обработки запроса.
    • MvcRouteHandler использовал контекст запроса и фабрику контроллеров для того, 
чтобы выбрать и вызвать соответствующий контроллер.
    • Контроллер вызвал один из своих методов действий.
    • Метод действия вернул объект ActionResult.

В этот момент, ASP.NET MVC выполняет запуск результата ActionResult.

##ВИЗУАЛИЗАЦИЯ ПРЕДСТАВЛЕНИЯ
    Уделим особое внимание одному особенному классу, наследованному от ActionResult – ViewResult.
Этот класс способен найти и визуализировать соответствующий шаблон представления, передав ему структуру данных ViewData, сформированном в методе действия. 
Это и есть то, что называется «движок отображения» («view engine») (класс .NET, реализующий интерфейс IViewEngine).

    WebFormViewEngine - механизм представвленя по умолчанию. 
Его шаблоны представления являются страницами ASPX WebForms (.aspx) 
 - это серверные страницы, используюшиеся в традиционной технологии ASP.NET WebForms. 
Страницы WebForms имеют свой собственный конвейер обработки, начинающийся с компиляции ASPX/ASCX «на лету» и 
проходящий через серию событий, называющийся жизненным циклом страницы. 
    В отличие от традиционного ASP.NET, в ASP.NET MVC эти страницы должны быть максимально простыми, 
поскольку, согласно принципам MVC, представления могут отвечать только за генерацию HTML кода. 
Это значит что, вам не требуется детально понимать жизненный цикл страниц WebForms. 
С соблюдением принципов разделения ролей приходят простота и удобство сопровождения кода.























