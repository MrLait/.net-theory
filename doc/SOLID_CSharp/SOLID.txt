                     Single Responsipility Principle
                     Принцип единственной обязанности
            У класса должна быть только одна причина для изменения

    Под обязанностью здесь понимается набор функций, которые выполняют единую задачу. 
Суть этого принципа заключается в том, что класс должен выполнять одну единственную задачу. 
Весь функционал класса должен быть целостным, обладать высокой связностью
----------------------------------------------------------------------------------------------
                    Open/Closed Principle
                    Принцип открытости/закрытости
        Сущности программы должны быть открыты для расширения, но закрыты для изменения.

    Суть этого принципа состоит в том, что система должна быть построена таким образом, 
что все ее последующие изменения должны быть реализованы с помощью добавления нового кода, 
а не изменения уже существующего.
----------------------------------------------------------------------------------------------
                    Liskov Substitution Principle
                    Принцип подстановки Лисков   - Представляет собой некоторое руководство по созданию иерархий наследования
        Если для каждого объекта o1 типа S 
        существует объект o2 типа T, такой, что для любой программы P, определенной в терминах T, поведение P не изменяется при замене o2 на o1, 
        то S является подтипом T.

    То есть иными словами класс S может считаться подклассом T, если замена объектов T на объекты S не приведет к изменению работы программы.
    В общем случае данный принцип можно сформулировать так: 
        Должна быть возможность вместо базового типа подставить любой его подтип.

    Существует несколько типов правил, которые должны быть соблюдены для выполнения принципа подстановки Лисков. 
Прежде всего это правила контракта. - Контракт представляет собой некоторый интерфейс базового класса, 
некоторые соглашения по его использованию, которым должен следовать класс-наследник. 
Контракт задает ряд ограничений или правил, и производный класс должен выполнять эти правила:

----Предусловия (Preconditions) не могут быть усилены в подклассе. 
Другими словами подклассы не должны создавать больше предусловий, чем это определено в базовом классе, для выполнения некоторого поведения

    Предусловия представляют набор условий, необходимых для безошибочного выполнения метода.
Причем объектом предусловий могут быть только общедоступные СВОЙСТВА или ПОЛЯ класса или ПАРАМЕТРЫ метода. 
ПРИВАТНОЕ поле не может быть объектом для предусловия, так как оно не может быть установлено из ВЫЗЫВАЮЩЕГО кода.

----Постусловия (Postconditions) не могут быть ослаблены в подклассе. 
То есть подклассы должны выполнять все постусловия, которые определены в базовом классе.

----Инварианты (Invariants) — все условия базового класса - также должны быть сохранены и в подклассе

    Инварианты - это некоторые условия, которые остаются истинными на протяжении всей жизни объекта. 
Как правило, инварианты передают внутреннее состояние объекта.
-----------
    Во всех трех вышеперечисленных случаях проблема решается в общем случае с помощью абстрагирования и выделения общего функционала, 
который уже наследуют классы Account и MicroAccount. То есть не один из них наследуется от другого, а оба они наследуются от одного общего класса.
    Таким образом, принцип подстановки Лисков заставляет задуматься над правильностью построения иерархий классов и применения полиморфизма, 
позволяя уйти от ложных иерархий наследования и делая всю систему классом более стройной и непротиворечивой

----------------------------------------------------------------------------------------------------------------------------------------------
                    Interface Segregation Principle
                    Принцип разделения интерфейсов
            Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.

    Когда классы имеют "жирный интерфейс", то есть слишком раздутый интерфейс, 
не все методы и свойства которого используются и могут быть востребованы. Таким образом, интерфейс получатся слишком избыточен.
В итоге мы приходим к жесткой зависимости между различными частями интерфейса, которые могут быть не связаны при его реализации.
    В этом случае интерфейс класса разделяется на отдельные части, которые составляют раздельные интерфейсы. 
Затем эти интерфейсы независимо друг от друга могут применяться и изменяться. 
В итоге применение принципа разделения интерфейсов делает систему слабосвязанной, и тем самым ее легче модифицировать и обновлять.
----------------------------------------------------------------------------------------------------------------------------------------------
                    Dependency Inversion Principle
                    Принцип инверсии зависимостей
            Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
            Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

    Cлужит для создания слабосвязанных сущностей, которые легко тестировать, модифицировать и обновлять.
    
# Inversion of Control 
    Инверсия управления IOC — это абстрактный принцип, для написания слабо связанного кода. 
Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на 
детали конкретной реализации других компонентов.
Т.е объект не сам создает свои заввисимости, а когда для этого объекта зависимости поставляются из вне. Например при помощи агрегации
интерфейса, абстрактного класса или базового.

# Dependency Injection
    Dependency Injection (внедрение зависимостей) — это одна из реализаций этого принципа.
    Constructor Injection (помимо этого есть Setter Injection и Method Injection — если в двух словах, то везде используется интерфейс 
вместо конкретного класса, например в типе свойства или в типе аргумента метода):

# IoC
    IoC-контейнер — это какая-то библиотека, фреймворк, программа если хотите, которая позволит вам упростить и автоматизировать написание 
кода с использованием данного подхода на столько, на сколько это возможно. Их довольно много.
    

    
