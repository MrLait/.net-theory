		Паттерны поведения
	Cтратегия» (Strategy), Шаблонный метод, Медиатор, Итератор, Observer, Visitor, Команда, Состояние, Цепочка обязанностей.
	
	Паттерн «Стратегия» (Strategy) - определяет набор алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
В зависимости от ситуации мы можем изменять алгоритм, который хотим использовать.
	Другими словами: создаем интерфейс или базовый класс, а в наследниках реализуем алгоритм, далее в другом классе создаем
интерфейс и присваиваем ему конкретную реализацию.

	Шаблонный метод - определяет алгоритма и позволяет подклассам переопределять некоторые шаги алгоритма, не изменяя его
структуры в целом. т.е - это каркас, в который наследники могут подставить реализации недостающих элементов.
	Шаблонный метод позволяет создать небольшой каркас для решения определенной задачи, когда базовый класс описывает основные 
шаги решения, заставляя наследников предоставить недостающие куски головоломки.
	? AbstractClass (LogReader) — определяет невиртуальный метод , который вызывает внутри примитивные операции
	? ConcreteClass (LogFileReader) — реализует примитивные шаги алгоритма.
	Другими словами: создаем абстрактный класс, с набором абстрактных методов, и один невертуальный метод, в котором эти методы
вызываются определяя шаблон, а в наследниках абстрактные методы переопределяются, реализовывая свое поведение алгоритма.

	Медиатор - определяет объект, инкапсулирующий способ взаимодействия множества объектов. Это клей, связывающий несколько
независимых классов между собой. Он избавляет классы от необходимости ссылаться друг на друга, позволяя тем самым их независимо
изменять и анализировать.
	Заменяет взаимодействие "все со всеми" взаимодействием "один со всеми".
	Другими словами: создаем абстрактный класс Mediator, который отправляет уведомления, создаем абстрактный класс Collegue, 
который принимает в конструкторе класс Mediator, а в виртуальном методе через Mediator происходит отправка сообщения. Далее
Реализовываем эти абстракции: создавая множество коллег, которые добавляются как свойства в реализации Mediator. Таким образом
Mediator сможет отправлять конкретному коллеге сообщения, а они будут на него реагировать. 
Примеров использования паттерна «Посредник»: MVC, где контроллер является посреднико между представлением и моделью.

	Итератор представляет доступ ко всем элементам составного объекта и позволяет последовательно обходить ее как единую коллекцию
без раскрытия деталей её реализации.
	Итераторы предоставляют абстрактный интерфейс для доступа к содержимому объекта, не раскрывая клиентам их внутреннюю структуру.
В результате получается четкое разделение ответственностей: клиенты получают возможность работать с разными коллекциями
унифицированным образом, а классы коллекций становятся проще за счет того, что ответственность за перебор ее элементов возлагается
на отдельную сущность.
	Другими словами. Создаем Iterator, который может реализовывать интерфейс IEnumerator для обхода коллекции через foreach, а 
так же реализовываем сам алгоритм обхода коллекции, который может отличаться от типа коллекциии ConcreateIterator. Далее создаем
абстрактный класс/интерфейс Aggregate, который представляет объект, по которому может перемещаться итератор, например может
реализовывать IEnumerable для foreach и соответственно ConcreteAggregate1 (List<T>) — конкретная реализация Aggregate. 
Далее клиент используя ConcreteAggregate1 может перебирать содержимое этого объекта.

	Observer - наблюдатель уведомляет все заинтересованные стороны о произошедшем событии или об изменении своего состояния, 
реализуя зависимость типа «один ко многим».
	Другими словами: создаем интерфейс ISubject-наблюдаемый объект, в котором описываем методы подписки/отписки/увеления, и
Observer определяем интерфейс наблюдателя, которым пользуется издатель для отправки оповещения метод Update(ISubject subject),
принимающий наблюдаемый объект(this). Далее сответственно реализиуем эти интерфейы: ConcreteObserver и ConcreteSubject. А клиент
создаёт объекты издателей и подписчиков, а затем регистрирует подписчиков на обновления в издателях.
	
	Visitor - Посетител, позволяет добавить новую операцию для объектов других классов, не изменяя код этих классов. 
Паттерн Посетитель предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких
классах. Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. Вместо этого вы будете
передавать эти объекты в методы посетителя.
	Другими словами: Создаем интерфейс для класса, который нужно расширить IElement, который должен реализовать метод Accept, 
который в качестве аргумента может получать любой объект, реализующий интерфейс посетителя.
	void Accept(IVisitor visitor) =>  visitor.Visit(this);
Далее создаем Интерфейс Посетителя IVisitor, который объявляет набор методов посещения, соответствующих классам Element. Сигнатура
метода посещения позволяет посетителю определить конкретный класс компонента, с которым он имеет дело. Далее создать конкретный
класс, в котором разместить новое поведение, реализовав интерфейс IVisitor, например сераилазацию в HtmlVisitor и XmlVisitor.
	Метод расширения vs Visotor
	Для целой группы разных объектов с одним интерфейсом вы не можете вызвать метод расширения. Точнее можете, но в методе
расширения придется иметь дело с одним интерфейсом IAccount, и вы не сможете сделать разные реализации для разные аккаунтов.
А с визитором это сделать можно.

	Паттерн «Команда» инкапсулирует запросы или простоые операции в объекты, позволяя передавать их как параметры при вызове
методов, ставить запросы в очередь или хранить историю, а также поддерживать отмену операций.
	Другими словами: Создаем ICommand, который содержит метод Execute, для выполнения команда. Далее создаем обекты с реализациями
конкретных команд и реализуем метод Execute(), в котором вызывается определенный метод, определенный в классе Receiver.
Получатель содержит бизнес-логику программы. Обычно команды перенаправляют вызовы получателям. Но иногда, чтобы упростить
программу, вы можете избавиться от получателей, «слив» их код в классы команд. Создаем Invoker Отправитель, который хранит ссылку
на объект команды и обращается к нему, когда нужно выполнить какое-то действие. Отправитель работает с командами только через их
общий интерфейс. Он не знает, какую конкретно команду использует, так как получает готовый объект команды от клиента.
Клиент создаёт объекты конкретных команд, передавая в них все необходимые параметры, среди которых могут быть и ссылки на объекты
получателей. После этого клиент связывает объекты отправителей с созданными командами.
	
	Паттерн «Состояние»  позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что
изменился класс объекта.
	Другими словами: Создаем контекст - наш объект, который должен менять состояние в зависимости от метода и хранит ссылку на 
на общий интерфейс объекта состояния. Создаем сам абстрактный класс или интерфейс State с набором методов для изменения его
состояний, а далее конкретные объекты Состояния, которые меняются в зависимости от методов
	
	Паттерн «Цепочка обязанностей» позволяет передавать запрос по цепочке потенциальных обработчиков, пока один из них не
обработает запрос. Каждый объект в этой цепочке при получении запроса выбирает, либо закончить обработку запроса, либо передать
запрос на обработку следующему по цепочке объекту. Аргументы позволяют уведомить инициатора, что событие обработано с помощью
метода Handle() или путем установки свойства Handled в True.
	Другими словами: создаем что-то вроде односвязного списка из обработчиков. Для этого создаем общий для всех конкретных
обработчиков интерфейс IHandler, в котором определена ссылка на следующий обработчик и метод, который принимает объект для
обработки. Так же можно создать Базовый обработчик — опциональный класс, который позволяет избавиться от дублирования одного и
того же кода во всех конкретных обработчиках. Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке.
Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Соответственно
сам конкретный обработчик, который решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту.
Клиент может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы
Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.
	
		Порождающие паттерны
Порождающие паттерны предназначены для решения типовых проблем создания объектов. В некоторых случаях разработчик хочет гарантировать, что будет создан лишь один
экземпляр некоторого класса. Иногда такая потребность диктуется спецификацией системы, в которой сказано, что в системе должен быть лишь один считыватель
мыслей пользователя. Но гораздо чаще такой подход применяется из-за того, что
он обеспечивает глобальную точку доступа к некоторому объекту. Это позволяет
любому объекту получить доступ к любой точке системы, что избавляет разработчика от необходимости продумывать обязанности классов и выделять их зависимости.

	Паттерн «Синглтон»(Singleton) гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа
к нему.
	Другими словами: создается статический конструктор и два статических поля _instance и _syncRoot = new object()
И статический метод с реализация на основе блокировки с двойной проверкой создания _instance.
	
	Паттерн «Абстрактная фабрика» (Abstract Factory)








