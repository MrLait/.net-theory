# Списки:
## Связный список
				Linked List
			Связный список (Linked List) представляет набор связанных узлов, 
			каждый из которых хранит собственно данные и ссылку на следующий узел.

Другими словами 
	В реальной жизни связный список можно представить в виде поезда, 
каждый вагон которого может содержать некоторый груз или пассажиров 
и при этом может быть связан с другим вагоном.

	Для хранения данных предназначено свойство Data. 
	Для ссылки на следующий узел определено свойство Next.

Методы:
	AddLast - добавление элемента в конец списка:
		При помощи tail(хвост) - указывает всегда на последний элемент списка
			Сложность O(1) 
		Без помощи tail(хвост) 
			Сложность O(n) - т.к есть необходимость перебора элементов для 
		нахождения последнего увеличивает время на поиск и сложность алгоритма.
	AddFirst - добавление элемента в начало списка
		Сложность О(1) - т.к ничего искать не нужно, а только перекинуть ссылки.

	Remove - удление элемента.
		Сложность O(n) - т.к есть необходимость перебора элементов для 
		нахождения удаляемого элемента, что увеличивает время на поиск и сложность алгоритма.

	Contains - для проверки наличия элемента.
		Сложность O(n) - т.к просто осуществляется перебор.

	Clear - удаляет все ссылки;

	IEnumerable - можно реализовать, чтобы список можно было бы перебрать во внешней прграмме 
	с помощью цикла foreach.
_____________________________________________________________________________________________
				Двусвязный список
				Doubly linked lists
			Двусвязные списки также представляют последовательность связанных узлов, 
			однако теперь каждый узел хранит ссылку на следующий и на предыдущий элементы.
Методы все теже.
_____________________________________________________________________________________________
				Кольцевой односвязный список
				CircularLinkedList
			Кольцевой односвязный список являются разновидностью связных списков. 
			Их отличительной особенностью является то, что условный последний элемент 
			хранит ссылку на первый элемент, поэтому список получается замкнутым или кольцевым.
_____________________________________________________________________________________________
				Кольцевой двусвязный список
				CircularDoublyLinkedList
			Кольцевой двусвязный список представляет замкнутый список, 
			в котором указатель на элемент может перемещаться как вперед, так и назад по кругу.

	Каждый узел такого списка опять же будет представлять элемент, 
который хранит указатели на следующий и предыдущий узлы.
	Однако, несмотря на то, что формально список замкнут, и у него нет начала и конца, 
все равно для некоторого базового отчета в таком списке будет храниться ссылка на первый элемент, 
относительно которого будет идти добавление новых элементов. В тоже время в отличие от 
кольцевого односвязного списка теперь уже не надо хранить указатель на формально последний элемент списка.
_____________________________________________________________________________________________
				ПРЕИМУЩЕСТВА списков
	Самое большое преимущество связанного списка заключается в добавлении и удалении объектов из списка. 
Внесение изменений в середину списка выполняется очень быстро т.к для изменения нужно просто изменить ссылки
на новый узел. 
				НЕДОСТАТКИ списков
	Произвольный доступ к связанному списку выполняется очень медленно. Т.к нет прямого доступа к любому элементу списка. 
Например, если вам нужно получить пятисотый элемент списка,
то придётся начинать с начала цепочки и следовать по её указателю к следующему элементу, потом к следующему, 
и так далее, повторяя пятьсот раз.

==============================================================================================
				Стек
				Stack
			Стек представляет собой структуру данных, которая работает по принципу LIFO 
			(Last In First Out - "последний пришел - первый вышел").

	При добавлении и удалении из стека последний добавленный элемент будет первым удаляемым.
Для стека нужно всего три метода: 
	Push добавляет объект в стек
	Pop удаляет объект из стека
	Top даёт самый последний объект в стеке.
----------------------------------------------------------------------------------------------
				Очередь
				Queue
			Очередь представляет собой структуру данных, которая работает по принципу FIFO 
			(First In First Out, «первым зашёл, первым вышел»).

	При добавлении и удалении из очереди первый добавляемый элемент будет первым извлекаемым. 
Очереди нужно только несколько методов: 
	Push_Back добавляет элемент к концу очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	_________________________________________________________________________________________			
				Двухсторонней очередью
				Deque
			Программистам часто нужно добавлять или удалять элементы из обоих концов очереди. 
			Такая структура называется двухсторонней очередью 

	Push_Back добавляет элемент к концу очереди;
	Push_Front добавляет элемент в начало очереди;
	Pop_Front удаляет элемент из начала очереди; 
	Pop_Back удаляет элемент из конца очереди; 
	Front позволяют получить доступ к двум концам очереди;
	Back позволяют получить доступ к двум концам очереди.
	_________________________________________________________________________________________			
				Очередь с приоритетом
				PriorityQueue
			Очередь с приоритетом очень похожа на обычную очередь.
		Программа добавляет элементы с конца и извлекает элементы из начала. 
	Разница в том, что можно задавать приоритеты определённым элементам очереди. 
	Все самые важные элементы обрабатываются в порядке FIFO. 
	Потом в порядке FIFO обрабатываются элементы с более низким приоритетом. 
	И так повторяется, пока не будут обработаны в порядке FIFO элементы с самым низким приоритетом.

			ЗАКЛЮЧЕНИЕ

	Стеки, очереди, двухсторонние очереди и очереди с приоритетом 
можно реализовать на основе других структур данных. Это не фундаментальные структуры данных, 
но их часто используют. 

			ПРЕИМУЩЕСТВА
	Они очень эффективны, когда нужно работать только с конечными элементами данных, 
а серединные элементы не важны.
			НЕДОСТАТКИ
	Видимо зависят от на какой структуре данных они были реализованы, но это не точно)
==============================================================================================
                Массив
            Массив представляет собой механизм, позволяющий рассматривать набор элементов
            как единую коллекцию.
            
    Базовым для всех массивов является абстрактный класс System.Array, производный от System.Object.
Массивы всегда относятся к ссылочному типу и размещаются в управляемой куче, 
а переменная в приложении содержит не элементы массива, а ссылку на массив.

Массивы бывают:

    Одномерные (single-dimension) []
        SZ-массивы или векторами - одномерный массив с нулевым начальным индексом;
    Многомерные (multidimension) [,] или больше [,,];
    Нерегулярные (jagged) массивы массивов [][].
        Производительность одномерных нерегулярных массивов с нулевым
начальным индексом такая же, как у обычных векторов. 
Однако обращение к элементу нерегулярного массива означает обращение к двум или 
больше массивам одновременно. 

    Доступ к элементам одномерного массива с нулевой нижней границей осуществляется 
быстрее, чем доступ к элементам многомерных массивов или массивов с ненулевой нижней границей. 
Есть специальные команды для работы с одномерными массивами с нулевой нижней границей, которые позволяют
JIT-компилятору генерировать оптимизированный код. 
Т.к первый индекс равен нулю, отсутствует необходимость вычислять смещение.
_____________________________________________________________________________________________
                Недостатки простого массива
    Если вам нужно неизменное количество объектов, то массив вполне подходит. 
Но если нужно добавить в массив ещё один элемент, то в простом массиве этого сделать невозможно. 
Или если нужно удалить элемент из массива. В простом массиве это так же невозможно. 
Т.к вы привязаны к одному количеству элементов. 
_____________________________________________________________________________________________                
                Динамический массив
                List
            Динамический массив — это массив, который может менять свой размер. 
            
Другими словами:
    Это простой массив, однако имеющий ещё два дополнительных блока данных. 
В них хранятся действительный размер простого массива и объём данных, 
который может на самом деле храниться в простом массиве.
                
                Недостатки динамических массивов
    Допустим, массив очень велик, а вам нужно часто добавлять и удалять объекты. 
При этом объекты могут часто копироваться в другие места, а многие указатели становиться недействительными. 
Если вам нужно вносить частые изменения в середине динамического массива, 
то для этого есть более подходящий тип линейной структуры данных

#Деревья и кучи.

## Куча(Двоичная куча)
## Binary Heap

    Двоичная куча - binary heap - представляет собой полное бинарное дерево, 
т.е у каждого узла не более двух потомков, а так же все уровни полностью заняты данными,
а последний заполнен слева направо.

Двоичная куча может быть минимальной или максимальной: 
    В максимальной куче ключ любого узла всегда больше ключей его потомков или равен им; 
    В минимальной куче  ключ любого узла меньше ключей его потомков или равен им.


Сложность:
    Для чтения элемента с самым высовким приоритетом О(1);
    Для добавления и извличение элементов О(log(n));
    Сортировка O(nLog(n)).

Методы:
    Max - получение максимального элемента О(1);
    DelMax - удаление максимального элемента О(log(n)) - т.к. нужно делать балансировку;
    Add - добавление элемента О(log(n)) - т.к. нужно делать балансировку.

Балансировка:
    Заключается в выполении Swap корневого элемена с узловым и так далее рекукрсивно
до самой вершины, до тех пор пока родительский элемент не будет больше чем потомки.

Удаление:
    После удаления элемента вместо него переносится самый крайний добавленный элемент,
далее этот элемент балансируется с потомками, если нужно.

Формулы:
    Левый потом: 2i+1;
    Правый потомок 2i+2;
    Предок (i-1)/2.
    
    Благодаря этим формулам можно легко древовидный вид преобразовать 
в линейный и реализовать на массиве, чтобы получать быстрый доступ к элементам.

## Двоичное дерево поиска
## Binary Search Tree

    Дерево — это структура данных, состоящая из узлов. 
    
Cвойства деревьев:
    Каждое дерево имеет корневой узел (вверху);
    Корневой узел имеет ноль или более дочерних узлов;
    Каждый дочерний узел имеет ноль или более дочерних узлов, и так далее.

Двоичного дерева поиска свойства:
    Каждый узел имеет до двух дочерних узлов (потомков).
    Каждый узел меньше своих потомков справа, а его потомки слева меньше его самого.

    Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. 
Они устроены так, что время каждой операции пропорционально логарифму общего числа элементов в дереве.

Сложность:
    Search    O(log n);
    Insert    O(log n);
    Delete    O(log n).
    
Элементы, не имеющие потомков, называются листьями. А тот, что не имеет предка — корнем. 

## АВЛ-дерева
    АВЛ-дерево — это прежде всего двоичное дерево поиска, ключи которого 
удовлетворяют стандартному свойствам бинарного дерева, но особенностью АВЛ-дерева 
является то, что оно является сбалансированным в следующем смысле: 
    для любого узла дерева высота его правого поддерева отличается от 
    высоты левого поддерева не более чем на единицу. 

### Обходы дерева:
    Префиксный: - Для копирования дерева с сохранением позиций элементов.
        1 - текущий элемент; 2 - левый элемент; 3 - правый элемент.
    Постфиксный: - При удалении элементов дерева.
        1 - левый элемент; 2 - правый элемент; 3 - текущий элемент.
    Инфиксный: - Возвращает отсортированное дерево.
        1 - левый элемент; 2 - текущий элемент; 3 - правый элемент.
        
### Балансировка узлов
    В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение 
ситуации, когда balance factor некоторых узлов оказывается равными 2 или -2, 
т.е. возникает расбалансировка поддерева.
    Выполняется левый или правый поворт. 
                y           x
            x      c     a    y
        a     b            b   c
        
    Большой поворот применяется при условии h(s)>h(D) и сводится к 
двум простым — сначала правый поворот вокруг q и затем левый вокруг p.









            
                
